
../../initrfs/init:     file format elf32-i386
../../initrfs/init
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x20000660

Program Header:
    LOAD off    0x00001000 vaddr 0x20000000 paddr 0x20000000 align 2**12
         filesz 0x000012c6 memsz 0x000012c6 flags r-x
    LOAD off    0x00003000 vaddr 0x20002000 paddr 0x20002000 align 2**12
         filesz 0x000010fb memsz 0x0004303c flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000012c6  20000000  20000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000001  20002000  20002000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       000000a8  20003000  20003000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 00000053  200030a8  200030a8  000040a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          0004103c  20004000  20004000  000040fb  2**5
                  ALLOC
  5 .stab         00004b00  00000000  00000000  000040fc  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      000000b4  00000000  00000000  00008bfc  2**0
                  CONTENTS, READONLY
  7 .stabstr      00001df0  00000000  00000000  00008cb0  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
20000000 l    d  .text	00000000 .text
20002000 l    d  .data	00000000 .data
20003000 l    d  .rodata	00000000 .rodata
200030a8 l    d  .rodata.str1.1	00000000 .rodata.str1.1
20004000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 init.c
20004000 l     O .bss	00000004 state
20004020 l     O .bss	00040000 files
00000000 l    df *ABS*	00000000 tar.c
2000033c l     F .text	00000045 tar_parse_number
00000000 l    df *ABS*	00000000 process.c
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    df *ABS*	00000000 console.c
20002000 l     O .data	00000001 color
20044020 l     O .bss	00000004 kprintf_res
00000000 l    df *ABS*	00000000 rpc.c
20044024 l     O .bss	00001000 rpcHandlers
20003090 l     O .rodata	00000018 C.2.870
00000000 l    df *ABS*	00000000 driver.c
00000000 l    df *ABS*	00000000 memory.c
00000000 l    df *ABS*	00000000 stdlib.c
20000ef8 l     F .text	00000069 pop_unused_node
00000000 l    df *ABS*	00000000 string.c
200011c0 g     F .text	00000031 strcpy
20000b3b g     F .text	0000003e inb
20000ca9 g     F .text	00000039 register_driver
200006e5 g     F .text	0000003e kputc
20000a83 g     F .text	0000003c fModify
20000688 g     F .text	00000050 syscall
20000907 g     F .text	00000042 rpc_init
200006d8 g     F .text	0000000d setclr
20000d00 g     F .text	00000026 memcpy
2000004e g     F .text	00000102 dRead
20000daa g     F .text	00000057 pcalloc
20000d6d g     F .text	0000003d pfree
20000f61 g     F .text	00000108 malloc
20000c32 g     F .text	0000003c register_irq_rpc
20000492 g     F .text	00000017 execn
2000111b g     F .text	000000a5 strtoknc
200004a9 g     F .text	0000003c thread
20000150 g     F .text	0000008a createDriver
2000087c g     F .text	0000003d rpc_check_future
200008b9 g     F .text	0000004e rpc_map
2004502c g     O .bss	00000004 first_free
20000000 g     F .text	0000001d dModify
20000854 g     F .text	00000028 rpc_register_handler
20000afd g     F .text	0000003e inw
20045030 g     O .bss	00000004 malloced
200010c9 g     F .text	00000034 calloc
2000001d g     F .text	00000027 dCall
200004e5 g     F .text	0000003e getargsptr
20000a0c g     F .text	0000003c fWrite
20000458 g     F .text	0000003a exec
20000560 g     F .text	000000ec execp
20000660 g     F .text	00000026 _start
20000abf g     F .text	0000003e inl
20001069 g     F .text	00000060 realloc
2000122a g     F .text	00000052 strtok
20000d26 g     F .text	00000047 memcmp
20000e01 g     F .text	0000000f palloc
20000bf4 g     F .text	0000003e outb
20045024 g     O .bss	00000004 first_unused
20000ce4 g     F .text	0000001c memset
200001da g     F .text	00000161 main
20000986 g     F .text	0000004a rpc_handler
20045038 g     O .bss	00000004 fr
2000074a g     F .text	0000003b kputn
2000127c g     F .text	0000004a strcmp
20000a48 g     F .text	0000003b fCall
20045034 g     O .bss	00000004 sp
20000723 g     F .text	00000027 kputs
20045028 g     O .bss	00000004 first_used
20000bb6 g     F .text	0000003e outw
20000949 g     F .text	0000003d rpc_return
20000b79 g     F .text	0000003d outl
20000785 g     F .text	000000ce kprintf
200011f1 g     F .text	00000039 strclone
20000523 g     F .text	0000003d exit
2000064c g     F .text	00000014 execpn
20000381 g     F .text	000000d7 tar_extract
200009d0 g     F .text	0000003c fRead
20000044 g     F .text	0000000a dWrite
20001100 g     F .text	0000001b strlen
20000c6e g     F .text	0000003b register_path
20000e10 g     F .text	000000e8 free



Disassembly of section .text:

20000000 <dModify>:

static uint32_t state;

static struct file* files[INITRFS_MAX_FILE_COUNT];

int dModify(int resourceID, void* data) {
20000000:	55                   	push   %ebp
20000001:	89 e5                	mov    %esp,%ebp
20000003:	83 ec 08             	sub    $0x8,%esp
	kprintf("initrfs driver modify");
20000006:	83 ec 0c             	sub    $0xc,%esp
20000009:	68 00 30 00 20       	push   $0x20003000
2000000e:	e8 72 07 00 00       	call   20000785 <kprintf>
20000013:	83 c4 10             	add    $0x10,%esp
	return 0;
20000016:	b8 00 00 00 00       	mov    $0x0,%eax
}
2000001b:	c9                   	leave  
2000001c:	c3                   	ret    

2000001d <dCall>:

int dCall(int arg0, void* data) {
2000001d:	55                   	push   %ebp
2000001e:	89 e5                	mov    %esp,%ebp
20000020:	83 ec 08             	sub    $0x8,%esp
	state = 0;
20000023:	c7 05 00 40 00 20 00 	movl   $0x0,0x20004000
2000002a:	00 00 00 
	kprintf("initrfs driver call");
2000002d:	83 ec 0c             	sub    $0xc,%esp
20000030:	68 16 30 00 20       	push   $0x20003016
20000035:	e8 4b 07 00 00       	call   20000785 <kprintf>
2000003a:	83 c4 10             	add    $0x10,%esp
	return 0;
2000003d:	b8 00 00 00 00       	mov    $0x0,%eax
}
20000042:	c9                   	leave  
20000043:	c3                   	ret    

20000044 <dWrite>:

int dWrite(int resourceID, void* data) {
20000044:	55                   	push   %ebp
20000045:	89 e5                	mov    %esp,%ebp
	return 0;
20000047:	b8 00 00 00 00       	mov    $0x0,%eax
}
2000004c:	5d                   	pop    %ebp
2000004d:	c3                   	ret    

2000004e <dRead>:

int dRead(int resourceID, void* data) {
2000004e:	55                   	push   %ebp
2000004f:	89 e5                	mov    %esp,%ebp
20000051:	53                   	push   %ebx
20000052:	83 ec 14             	sub    $0x14,%esp
	struct driver_data* drvData = data;
20000055:	8b 45 0c             	mov    0xc(%ebp),%eax
20000058:	89 45 f4             	mov    %eax,-0xc(%ebp)
	if(drvData == 0) return 0;
2000005b:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
2000005f:	75 0a                	jne    2000006b <dRead+0x1d>
20000061:	b8 00 00 00 00       	mov    $0x0,%eax
20000066:	e9 e0 00 00 00       	jmp    2000014b <dRead+0xfd>

	if(drvData->pos >= files[resourceID]->size) {
2000006b:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000006e:	8b 08                	mov    (%eax),%ecx
20000070:	8b 58 04             	mov    0x4(%eax),%ebx
20000073:	8b 45 08             	mov    0x8(%ebp),%eax
20000076:	8b 04 85 20 40 00 20 	mov    0x20004020(,%eax,4),%eax
2000007d:	8b 00                	mov    (%eax),%eax
2000007f:	ba 00 00 00 00       	mov    $0x0,%edx
20000084:	39 d3                	cmp    %edx,%ebx
20000086:	72 26                	jb     200000ae <dRead+0x60>
20000088:	39 d3                	cmp    %edx,%ebx
2000008a:	77 04                	ja     20000090 <dRead+0x42>
2000008c:	39 c1                	cmp    %eax,%ecx
2000008e:	72 1e                	jb     200000ae <dRead+0x60>
		drvData->result = E_ERROR;
20000090:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000093:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
		drvData->bytesDone = 0;
2000009a:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000009d:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
		return 0;
200000a4:	b8 00 00 00 00       	mov    $0x0,%eax
200000a9:	e9 9d 00 00 00       	jmp    2000014b <dRead+0xfd>
	}

	drvData->bytesDone = (drvData->pos + drvData->length <= files[resourceID]->size) ? drvData->length : (files[resourceID]->size - drvData->pos);
200000ae:	8b 45 f4             	mov    -0xc(%ebp),%eax
200000b1:	8b 08                	mov    (%eax),%ecx
200000b3:	8b 58 04             	mov    0x4(%eax),%ebx
200000b6:	8b 45 f4             	mov    -0xc(%ebp),%eax
200000b9:	8b 40 08             	mov    0x8(%eax),%eax
200000bc:	ba 00 00 00 00       	mov    $0x0,%edx
200000c1:	01 c1                	add    %eax,%ecx
200000c3:	11 d3                	adc    %edx,%ebx
200000c5:	8b 45 08             	mov    0x8(%ebp),%eax
200000c8:	8b 04 85 20 40 00 20 	mov    0x20004020(,%eax,4),%eax
200000cf:	8b 00                	mov    (%eax),%eax
200000d1:	ba 00 00 00 00       	mov    $0x0,%edx
200000d6:	39 d3                	cmp    %edx,%ebx
200000d8:	77 10                	ja     200000ea <dRead+0x9c>
200000da:	39 d3                	cmp    %edx,%ebx
200000dc:	72 04                	jb     200000e2 <dRead+0x94>
200000de:	39 c1                	cmp    %eax,%ecx
200000e0:	77 08                	ja     200000ea <dRead+0x9c>
200000e2:	8b 45 f4             	mov    -0xc(%ebp),%eax
200000e5:	8b 40 08             	mov    0x8(%eax),%eax
200000e8:	eb 1a                	jmp    20000104 <dRead+0xb6>
200000ea:	8b 45 08             	mov    0x8(%ebp),%eax
200000ed:	8b 04 85 20 40 00 20 	mov    0x20004020(,%eax,4),%eax
200000f4:	8b 08                	mov    (%eax),%ecx
200000f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
200000f9:	8b 50 04             	mov    0x4(%eax),%edx
200000fc:	8b 00                	mov    (%eax),%eax
200000fe:	89 ca                	mov    %ecx,%edx
20000100:	29 c2                	sub    %eax,%edx
20000102:	89 d0                	mov    %edx,%eax
20000104:	8b 55 f4             	mov    -0xc(%ebp),%edx
20000107:	89 42 0c             	mov    %eax,0xc(%edx)

	memcpy(drvData->data, &(files[resourceID]->content) + drvData->pos, drvData->bytesDone);
2000010a:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000010d:	8b 48 0c             	mov    0xc(%eax),%ecx
20000110:	8b 45 08             	mov    0x8(%ebp),%eax
20000113:	8b 04 85 20 40 00 20 	mov    0x20004020(,%eax,4),%eax
2000011a:	8d 58 04             	lea    0x4(%eax),%ebx
2000011d:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000120:	8b 50 04             	mov    0x4(%eax),%edx
20000123:	8b 00                	mov    (%eax),%eax
20000125:	8d 14 03             	lea    (%ebx,%eax,1),%edx
20000128:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000012b:	83 c0 14             	add    $0x14,%eax
2000012e:	83 ec 04             	sub    $0x4,%esp
20000131:	51                   	push   %ecx
20000132:	52                   	push   %edx
20000133:	50                   	push   %eax
20000134:	e8 c7 0b 00 00       	call   20000d00 <memcpy>
20000139:	83 c4 10             	add    $0x10,%esp
	drvData->result = S_OK;
2000013c:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000013f:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	return 0;
20000146:	b8 00 00 00 00       	mov    $0x0,%eax
}
2000014b:	8b 5d fc             	mov    -0x4(%ebp),%ebx
2000014e:	c9                   	leave  
2000014f:	c3                   	ret    

20000150 <createDriver>:

void createDriver(void* initrfsPtr) {
20000150:	55                   	push   %ebp
20000151:	89 e5                	mov    %esp,%ebp
20000153:	83 ec 28             	sub    $0x28,%esp
	int dModifyID = rpc_register_handler(&dModify);
20000156:	83 ec 0c             	sub    $0xc,%esp
20000159:	68 00 00 00 20       	push   $0x20000000
2000015e:	e8 f1 06 00 00       	call   20000854 <rpc_register_handler>
20000163:	83 c4 10             	add    $0x10,%esp
20000166:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int dCallID = rpc_register_handler(&dCall);
20000169:	83 ec 0c             	sub    $0xc,%esp
2000016c:	68 1d 00 00 20       	push   $0x2000001d
20000171:	e8 de 06 00 00       	call   20000854 <rpc_register_handler>
20000176:	83 c4 10             	add    $0x10,%esp
20000179:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int dReadID = rpc_register_handler(&dRead);
2000017c:	83 ec 0c             	sub    $0xc,%esp
2000017f:	68 4e 00 00 20       	push   $0x2000004e
20000184:	e8 cb 06 00 00       	call   20000854 <rpc_register_handler>
20000189:	83 c4 10             	add    $0x10,%esp
2000018c:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int dWriteID = rpc_register_handler(&dWrite);
2000018f:	83 ec 0c             	sub    $0xc,%esp
20000192:	68 44 00 00 20       	push   $0x20000044
20000197:	e8 b8 06 00 00       	call   20000854 <rpc_register_handler>
2000019c:	83 c4 10             	add    $0x10,%esp
2000019f:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int driverID = register_driver(dModifyID, dCallID, dReadID, dWriteID, "initrfs");
200001a2:	83 ec 0c             	sub    $0xc,%esp
200001a5:	68 2a 30 00 20       	push   $0x2000302a
200001aa:	ff 75 f0             	pushl  -0x10(%ebp)
200001ad:	ff 75 ec             	pushl  -0x14(%ebp)
200001b0:	ff 75 e8             	pushl  -0x18(%ebp)
200001b3:	ff 75 e4             	pushl  -0x1c(%ebp)
200001b6:	e8 ee 0a 00 00       	call   20000ca9 <register_driver>
200001bb:	83 c4 20             	add    $0x20,%esp
200001be:	89 45 f4             	mov    %eax,-0xc(%ebp)

	tar_extract(initrfsPtr, (uint32_t**)files, driverID);
200001c1:	b8 20 40 00 20       	mov    $0x20004020,%eax
200001c6:	83 ec 04             	sub    $0x4,%esp
200001c9:	ff 75 f4             	pushl  -0xc(%ebp)
200001cc:	50                   	push   %eax
200001cd:	ff 75 08             	pushl  0x8(%ebp)
200001d0:	e8 ac 01 00 00       	call   20000381 <tar_extract>
200001d5:	83 c4 10             	add    $0x10,%esp
}
200001d8:	c9                   	leave  
200001d9:	c3                   	ret    

200001da <main>:

int main(void* initrfsPtr) {
200001da:	8d 4c 24 04          	lea    0x4(%esp),%ecx
200001de:	83 e4 f0             	and    $0xfffffff0,%esp
200001e1:	ff 71 fc             	pushl  -0x4(%ecx)
200001e4:	55                   	push   %ebp
200001e5:	89 e5                	mov    %esp,%ebp
200001e7:	51                   	push   %ecx
200001e8:	83 ec 14             	sub    $0x14,%esp
200001eb:	89 c8                	mov    %ecx,%eax
	if(!initrfsPtr) {
200001ed:	83 38 00             	cmpl   $0x0,(%eax)
200001f0:	75 1d                	jne    2000020f <main+0x35>
		kprintf("Init called without initrfsptr!\nTerminating...\n");
200001f2:	83 ec 0c             	sub    $0xc,%esp
200001f5:	68 34 30 00 20       	push   $0x20003034
200001fa:	e8 86 05 00 00       	call   20000785 <kprintf>
200001ff:	83 c4 10             	add    $0x10,%esp
		return 0;
20000202:	b8 00 00 00 00       	mov    $0x0,%eax
		while(rpc_check_future(fut));
		kprintf("Read: %s\n", dd->data);
	}

	return 0;
}
20000207:	8b 4d fc             	mov    -0x4(%ebp),%ecx
2000020a:	c9                   	leave  
2000020b:	8d 61 fc             	lea    -0x4(%ecx),%esp
2000020e:	c3                   	ret    
	if(!initrfsPtr) {
		kprintf("Init called without initrfsptr!\nTerminating...\n");
		return 0;
	}

	createDriver(initrfsPtr);
2000020f:	83 ec 0c             	sub    $0xc,%esp
20000212:	ff 30                	pushl  (%eax)
20000214:	e8 37 ff ff ff       	call   20000150 <createDriver>
20000219:	83 c4 10             	add    $0x10,%esp

	state = 5;
2000021c:	c7 05 00 40 00 20 05 	movl   $0x5,0x20004000
20000223:	00 00 00 
	execpn("drivers/fifo");
20000226:	83 ec 0c             	sub    $0xc,%esp
20000229:	68 64 30 00 20       	push   $0x20003064
2000022e:	e8 19 04 00 00       	call   2000064c <execpn>
20000233:	83 c4 10             	add    $0x10,%esp
	while(state); //wait for backcall
20000236:	a1 00 40 00 20       	mov    0x20004000,%eax
2000023b:	85 c0                	test   %eax,%eax
2000023d:	75 f7                	jne    20000236 <main+0x5c>

	struct driver_data* dd = palloc();
2000023f:	e8 bd 0b 00 00       	call   20000e01 <palloc>
20000244:	89 45 ec             	mov    %eax,-0x14(%ebp)

	strcpy(dd->data, "testfile");
20000247:	8b 45 ec             	mov    -0x14(%ebp),%eax
2000024a:	83 c0 14             	add    $0x14,%eax
2000024d:	83 ec 08             	sub    $0x8,%esp
20000250:	68 71 30 00 20       	push   $0x20003071
20000255:	50                   	push   %eax
20000256:	e8 65 0f 00 00       	call   200011c0 <strcpy>
2000025b:	83 c4 10             	add    $0x10,%esp

	FUTURE fut = fCall("fifo", CALL_CREATE, dd);
2000025e:	83 ec 04             	sub    $0x4,%esp
20000261:	ff 75 ec             	pushl  -0x14(%ebp)
20000264:	68 00 01 00 00       	push   $0x100
20000269:	68 7a 30 00 20       	push   $0x2000307a
2000026e:	e8 d5 07 00 00       	call   20000a48 <fCall>
20000273:	83 c4 10             	add    $0x10,%esp
20000276:	89 45 f0             	mov    %eax,-0x10(%ebp)
	while(rpc_check_future(fut));
20000279:	83 ec 0c             	sub    $0xc,%esp
2000027c:	ff 75 f0             	pushl  -0x10(%ebp)
2000027f:	e8 f8 05 00 00       	call   2000087c <rpc_check_future>
20000284:	83 c4 10             	add    $0x10,%esp
20000287:	85 c0                	test   %eax,%eax
20000289:	75 ee                	jne    20000279 <main+0x9f>

	for(int i = 0; i < 100; i++) {
2000028b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
20000292:	eb 45                	jmp    200002d9 <main+0xff>
		strcpy(dd->data, "INPUT");
20000294:	8b 45 ec             	mov    -0x14(%ebp),%eax
20000297:	83 c0 14             	add    $0x14,%eax
2000029a:	83 ec 08             	sub    $0x8,%esp
2000029d:	68 7f 30 00 20       	push   $0x2000307f
200002a2:	50                   	push   %eax
200002a3:	e8 18 0f 00 00       	call   200011c0 <strcpy>
200002a8:	83 c4 10             	add    $0x10,%esp
		dd->length = strlen(dd->data);
200002ab:	8b 45 ec             	mov    -0x14(%ebp),%eax
200002ae:	83 c0 14             	add    $0x14,%eax
200002b1:	83 ec 0c             	sub    $0xc,%esp
200002b4:	50                   	push   %eax
200002b5:	e8 46 0e 00 00       	call   20001100 <strlen>
200002ba:	83 c4 10             	add    $0x10,%esp
200002bd:	8b 55 ec             	mov    -0x14(%ebp),%edx
200002c0:	89 42 08             	mov    %eax,0x8(%edx)
		fWrite("testfile", dd);
200002c3:	83 ec 08             	sub    $0x8,%esp
200002c6:	ff 75 ec             	pushl  -0x14(%ebp)
200002c9:	68 71 30 00 20       	push   $0x20003071
200002ce:	e8 39 07 00 00       	call   20000a0c <fWrite>
200002d3:	83 c4 10             	add    $0x10,%esp
	strcpy(dd->data, "testfile");

	FUTURE fut = fCall("fifo", CALL_CREATE, dd);
	while(rpc_check_future(fut));

	for(int i = 0; i < 100; i++) {
200002d6:	ff 45 f4             	incl   -0xc(%ebp)
200002d9:	83 7d f4 63          	cmpl   $0x63,-0xc(%ebp)
200002dd:	7e b5                	jle    20000294 <main+0xba>
		strcpy(dd->data, "INPUT");
		dd->length = strlen(dd->data);
		fWrite("testfile", dd);
	}

	while(rpc_check_future(0));
200002df:	83 ec 0c             	sub    $0xc,%esp
200002e2:	6a 00                	push   $0x0
200002e4:	e8 93 05 00 00       	call   2000087c <rpc_check_future>
200002e9:	83 c4 10             	add    $0x10,%esp
200002ec:	85 c0                	test   %eax,%eax
200002ee:	75 ef                	jne    200002df <main+0x105>

	while(1) {
		dd->length = 25;
200002f0:	8b 45 ec             	mov    -0x14(%ebp),%eax
200002f3:	c7 40 08 19 00 00 00 	movl   $0x19,0x8(%eax)
		fut = fRead("testfile", dd);
200002fa:	83 ec 08             	sub    $0x8,%esp
200002fd:	ff 75 ec             	pushl  -0x14(%ebp)
20000300:	68 71 30 00 20       	push   $0x20003071
20000305:	e8 c6 06 00 00       	call   200009d0 <fRead>
2000030a:	83 c4 10             	add    $0x10,%esp
2000030d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		while(rpc_check_future(fut));
20000310:	83 ec 0c             	sub    $0xc,%esp
20000313:	ff 75 f0             	pushl  -0x10(%ebp)
20000316:	e8 61 05 00 00       	call   2000087c <rpc_check_future>
2000031b:	83 c4 10             	add    $0x10,%esp
2000031e:	85 c0                	test   %eax,%eax
20000320:	75 ee                	jne    20000310 <main+0x136>
		kprintf("Read: %s\n", dd->data);
20000322:	8b 45 ec             	mov    -0x14(%ebp),%eax
20000325:	83 c0 14             	add    $0x14,%eax
20000328:	83 ec 08             	sub    $0x8,%esp
2000032b:	50                   	push   %eax
2000032c:	68 85 30 00 20       	push   $0x20003085
20000331:	e8 4f 04 00 00       	call   20000785 <kprintf>
20000336:	83 c4 10             	add    $0x10,%esp
	}
20000339:	eb b5                	jmp    200002f0 <main+0x116>
	...

2000033c <tar_parse_number>:
#include "stdlib.h"
#include "stdint.h"
#include "string.h"

static uint32_t tar_parse_number(const char *in)
{
2000033c:	55                   	push   %ebp
2000033d:	89 e5                	mov    %esp,%ebp
2000033f:	83 ec 10             	sub    $0x10,%esp
    unsigned int size = 0;
20000342:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    unsigned int j;
    unsigned int count = 1;
20000349:	c7 45 fc 01 00 00 00 	movl   $0x1,-0x4(%ebp)

    for (j = 11; j > 0; j--, count *= 8)
20000350:	c7 45 f8 0b 00 00 00 	movl   $0xb,-0x8(%ebp)
20000357:	eb 1d                	jmp    20000376 <tar_parse_number+0x3a>
        size += ((in[j - 1] - '0') * count);
20000359:	8b 45 f8             	mov    -0x8(%ebp),%eax
2000035c:	48                   	dec    %eax
2000035d:	03 45 08             	add    0x8(%ebp),%eax
20000360:	8a 00                	mov    (%eax),%al
20000362:	0f be c0             	movsbl %al,%eax
20000365:	83 e8 30             	sub    $0x30,%eax
20000368:	0f af 45 fc          	imul   -0x4(%ebp),%eax
2000036c:	01 45 f4             	add    %eax,-0xc(%ebp)
{
    unsigned int size = 0;
    unsigned int j;
    unsigned int count = 1;

    for (j = 11; j > 0; j--, count *= 8)
2000036f:	ff 4d f8             	decl   -0x8(%ebp)
20000372:	c1 65 fc 03          	shll   $0x3,-0x4(%ebp)
20000376:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
2000037a:	75 dd                	jne    20000359 <tar_parse_number+0x1d>
        size += ((in[j - 1] - '0') * count);

    return size;
2000037c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
2000037f:	c9                   	leave  
20000380:	c3                   	ret    

20000381 <tar_extract>:

void tar_extract(void* tarball, uint32_t** files, int driverID) {
20000381:	55                   	push   %ebp
20000382:	89 e5                	mov    %esp,%ebp
20000384:	53                   	push   %ebx
20000385:	83 ec 14             	sub    $0x14,%esp
    void* address = tarball;
20000388:	8b 45 08             	mov    0x8(%ebp),%eax
2000038b:	89 45 e8             	mov    %eax,-0x18(%ebp)

    uint32_t i;

    for (i = 0; ; i++)
2000038e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    {
        struct tar_header *header = (struct tar_header*)address;
20000395:	8b 45 e8             	mov    -0x18(%ebp),%eax
20000398:	89 45 f0             	mov    %eax,-0x10(%ebp)

        if (header->name[0] == '\0')
2000039b:	8b 45 f0             	mov    -0x10(%ebp),%eax
2000039e:	8a 00                	mov    (%eax),%al
200003a0:	84 c0                	test   %al,%al
200003a2:	0f 84 ab 00 00 00    	je     20000453 <tar_extract+0xd2>
            break;

        uint32_t size = tar_parse_number(header->size);
200003a8:	8b 45 f0             	mov    -0x10(%ebp),%eax
200003ab:	83 c0 7c             	add    $0x7c,%eax
200003ae:	50                   	push   %eax
200003af:	e8 88 ff ff ff       	call   2000033c <tar_parse_number>
200003b4:	83 c4 04             	add    $0x4,%esp
200003b7:	89 45 f4             	mov    %eax,-0xc(%ebp)
        address += 512;
200003ba:	81 45 e8 00 02 00 00 	addl   $0x200,-0x18(%ebp)

        if(size != 0) {
200003c1:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
200003c5:	74 65                	je     2000042c <tar_extract+0xab>
            files[i] = malloc(size + 4);
200003c7:	8b 45 ec             	mov    -0x14(%ebp),%eax
200003ca:	c1 e0 02             	shl    $0x2,%eax
200003cd:	89 c3                	mov    %eax,%ebx
200003cf:	03 5d 0c             	add    0xc(%ebp),%ebx
200003d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
200003d5:	83 c0 04             	add    $0x4,%eax
200003d8:	83 ec 0c             	sub    $0xc,%esp
200003db:	50                   	push   %eax
200003dc:	e8 80 0b 00 00       	call   20000f61 <malloc>
200003e1:	83 c4 10             	add    $0x10,%esp
200003e4:	89 03                	mov    %eax,(%ebx)
            files[i][0] = size;
200003e6:	8b 45 ec             	mov    -0x14(%ebp),%eax
200003e9:	c1 e0 02             	shl    $0x2,%eax
200003ec:	03 45 0c             	add    0xc(%ebp),%eax
200003ef:	8b 00                	mov    (%eax),%eax
200003f1:	8b 55 f4             	mov    -0xc(%ebp),%edx
200003f4:	89 10                	mov    %edx,(%eax)
            memcpy(&files[i][1], address, size);
200003f6:	8b 45 ec             	mov    -0x14(%ebp),%eax
200003f9:	c1 e0 02             	shl    $0x2,%eax
200003fc:	03 45 0c             	add    0xc(%ebp),%eax
200003ff:	8b 00                	mov    (%eax),%eax
20000401:	83 c0 04             	add    $0x4,%eax
20000404:	83 ec 04             	sub    $0x4,%esp
20000407:	ff 75 f4             	pushl  -0xc(%ebp)
2000040a:	ff 75 e8             	pushl  -0x18(%ebp)
2000040d:	50                   	push   %eax
2000040e:	e8 ed 08 00 00       	call   20000d00 <memcpy>
20000413:	83 c4 10             	add    $0x10,%esp

            register_path(header->name, driverID, i);
20000416:	8b 55 ec             	mov    -0x14(%ebp),%edx
20000419:	8b 45 f0             	mov    -0x10(%ebp),%eax
2000041c:	83 ec 04             	sub    $0x4,%esp
2000041f:	52                   	push   %edx
20000420:	ff 75 10             	pushl  0x10(%ebp)
20000423:	50                   	push   %eax
20000424:	e8 45 08 00 00       	call   20000c6e <register_path>
20000429:	83 c4 10             	add    $0x10,%esp
        }

        address += (size / 512) * 512;
2000042c:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000042f:	c1 e8 09             	shr    $0x9,%eax
20000432:	c1 e0 09             	shl    $0x9,%eax
20000435:	01 45 e8             	add    %eax,-0x18(%ebp)

        if (size % 512)
20000438:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000043b:	25 ff 01 00 00       	and    $0x1ff,%eax
20000440:	85 c0                	test   %eax,%eax
20000442:	74 07                	je     2000044b <tar_extract+0xca>
            address += 512;
20000444:	81 45 e8 00 02 00 00 	addl   $0x200,-0x18(%ebp)
void tar_extract(void* tarball, uint32_t** files, int driverID) {
    void* address = tarball;

    uint32_t i;

    for (i = 0; ; i++)
2000044b:	ff 45 ec             	incl   -0x14(%ebp)

        address += (size / 512) * 512;

        if (size % 512)
            address += 512;
    }
2000044e:	e9 42 ff ff ff       	jmp    20000395 <tar_extract+0x14>

    return;
}
20000453:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000456:	c9                   	leave  
20000457:	c3                   	ret    

20000458 <exec>:

THREAD execn(void* elf, uint32_t elfSize) {
	return exec(elf, elfSize, 0, 0);
}

THREAD exec(void* elf, uint32_t elfSize, void* data, uint32_t dataSize) {
20000458:	55                   	push   %ebp
20000459:	89 e5                	mov    %esp,%ebp
2000045b:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x501,
			.ebx = (uint32_t)data,
			.ecx = (uint32_t)dataSize,
			.edx = (uint32_t)elf,
			.esi = (uint32_t)elfSize,
			.edi = 0 };
2000045e:	8b 45 10             	mov    0x10(%ebp),%eax
20000461:	c7 45 e0 01 05 00 00 	movl   $0x501,-0x20(%ebp)
20000468:	89 45 e4             	mov    %eax,-0x1c(%ebp)
2000046b:	8b 45 14             	mov    0x14(%ebp),%eax
2000046e:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000471:	8b 45 08             	mov    0x8(%ebp),%eax
20000474:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000477:	8b 45 0c             	mov    0xc(%ebp),%eax
2000047a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	syscall(&state);
2000047d:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000480:	50                   	push   %eax
			.eax = 0x501,
			.ebx = (uint32_t)data,
			.ecx = (uint32_t)dataSize,
			.edx = (uint32_t)elf,
			.esi = (uint32_t)elfSize,
			.edi = 0 };
20000481:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000488:	e8 fb 01 00 00       	call   20000688 <syscall>

	return state.eax;
}
2000048d:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000490:	c9                   	leave  
20000491:	c3                   	ret    

20000492 <execn>:

THREAD execpn(char* path) {
	return execp(path, 0, 0);
}

THREAD execn(void* elf, uint32_t elfSize) {
20000492:	55                   	push   %ebp
20000493:	89 e5                	mov    %esp,%ebp
20000495:	83 ec 08             	sub    $0x8,%esp
	return exec(elf, elfSize, 0, 0);
20000498:	6a 00                	push   $0x0
2000049a:	6a 00                	push   $0x0
2000049c:	ff 75 0c             	pushl  0xc(%ebp)
2000049f:	ff 75 08             	pushl  0x8(%ebp)
200004a2:	e8 b1 ff ff ff       	call   20000458 <exec>
}
200004a7:	c9                   	leave  
200004a8:	c3                   	ret    

200004a9 <thread>:

	return (void*) state.eax;
}


THREAD thread(void* function, void* args) {
200004a9:	55                   	push   %ebp
200004aa:	89 e5                	mov    %esp,%ebp
200004ac:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x500,
			.ebx = (uint32_t)function,
			.ecx = (uint32_t)args,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200004af:	8b 45 08             	mov    0x8(%ebp),%eax
200004b2:	c7 45 e0 00 05 00 00 	movl   $0x500,-0x20(%ebp)
200004b9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
200004bc:	8b 45 0c             	mov    0xc(%ebp),%eax
200004bf:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
200004c2:	8d 45 e0             	lea    -0x20(%ebp),%eax
200004c5:	50                   	push   %eax
			.eax = 0x500,
			.ebx = (uint32_t)function,
			.ecx = (uint32_t)args,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200004c6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200004cd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200004d4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200004db:	e8 a8 01 00 00       	call   20000688 <syscall>

	return state.eax;
}
200004e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
200004e3:	c9                   	leave  
200004e4:	c3                   	ret    

200004e5 <getargsptr>:

	while (1) {
	}
}

void* getargsptr() {
200004e5:	55                   	push   %ebp
200004e6:	89 e5                	mov    %esp,%ebp
200004e8:	83 ec 34             	sub    $0x34,%esp
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
200004eb:	8d 45 e0             	lea    -0x20(%ebp),%eax
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200004ee:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)

	syscall(&state);
200004f5:	50                   	push   %eax
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200004f6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
200004fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000504:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000050b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000512:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000519:	e8 6a 01 00 00       	call   20000688 <syscall>

	return (void*) state.eax;
}
2000051e:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000521:	c9                   	leave  
20000522:	c3                   	ret    

20000523 <exit>:
	int result = main(getargsptr());

	exit(result);
}

void exit(int returncode) {
20000523:	55                   	push   %ebp
20000524:	89 e5                	mov    %esp,%ebp
20000526:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000529:	8b 45 08             	mov    0x8(%ebp),%eax
2000052c:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
20000533:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000536:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000539:	50                   	push   %eax
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000053a:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000541:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000548:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000054f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000556:	e8 2d 01 00 00       	call   20000688 <syscall>
2000055b:	83 c4 10             	add    $0x10,%esp
2000055e:	eb fe                	jmp    2000055e <exit+0x3b>

20000560 <execp>:
	syscall(&state);

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
20000560:	55                   	push   %ebp
20000561:	89 e5                	mov    %esp,%ebp
20000563:	57                   	push   %edi
20000564:	56                   	push   %esi
20000565:	53                   	push   %ebx
20000566:	83 ec 1c             	sub    $0x1c,%esp
		if(driverData->pos + driverData->bytesDone >= elfsize) {
			elfsize *= 2;
			elf = realloc(elf, elfsize);
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
20000569:	bf d8 0e 00 00       	mov    $0xed8,%edi

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();
2000056e:	e8 8e 08 00 00       	call   20000e01 <palloc>

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
20000573:	83 ec 0c             	sub    $0xc,%esp

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();
20000576:	89 c3                	mov    %eax,%ebx

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
20000578:	68 d8 0e 00 00       	push   $0xed8
2000057d:	e8 df 09 00 00       	call   20000f61 <malloc>

	driverData->length = MAX_IO_BUFFER;
20000582:	c7 43 08 d8 0e 00 00 	movl   $0xed8,0x8(%ebx)

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
20000589:	89 c6                	mov    %eax,%esi

	driverData->length = MAX_IO_BUFFER;

	kprintf("Reading init...\n");
2000058b:	c7 04 24 a8 30 00 20 	movl   $0x200030a8,(%esp)
20000592:	e8 ee 01 00 00       	call   20000785 <kprintf>
		if(driverData->pos + driverData->bytesDone >= elfsize) {
			elfsize *= 2;
			elf = realloc(elf, elfsize);
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
20000597:	8d 43 14             	lea    0x14(%ebx),%eax
2000059a:	83 c4 10             	add    $0x10,%esp
2000059d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	driverData->length = MAX_IO_BUFFER;

	kprintf("Reading init...\n");

	do {
		FUTURE f = fRead(path, driverData);
200005a0:	50                   	push   %eax
200005a1:	50                   	push   %eax
200005a2:	53                   	push   %ebx
200005a3:	ff 75 08             	pushl  0x8(%ebp)
200005a6:	e8 25 04 00 00       	call   200009d0 <fRead>
200005ab:	83 c4 10             	add    $0x10,%esp
200005ae:	89 c2                	mov    %eax,%edx
		while(rpc_check_future(f));
200005b0:	83 ec 0c             	sub    $0xc,%esp
200005b3:	89 55 e0             	mov    %edx,-0x20(%ebp)
200005b6:	52                   	push   %edx
200005b7:	e8 c0 02 00 00       	call   2000087c <rpc_check_future>
200005bc:	83 c4 10             	add    $0x10,%esp
200005bf:	8b 55 e0             	mov    -0x20(%ebp),%edx
200005c2:	85 c0                	test   %eax,%eax
200005c4:	75 ea                	jne    200005b0 <execp+0x50>

		if(driverData->pos + driverData->bytesDone >= elfsize) {
200005c6:	8b 43 0c             	mov    0xc(%ebx),%eax
200005c9:	31 d2                	xor    %edx,%edx
200005cb:	03 03                	add    (%ebx),%eax
200005cd:	13 53 04             	adc    0x4(%ebx),%edx
200005d0:	83 fa 00             	cmp    $0x0,%edx
200005d3:	77 04                	ja     200005d9 <execp+0x79>
200005d5:	39 f8                	cmp    %edi,%eax
200005d7:	72 10                	jb     200005e9 <execp+0x89>
			elfsize *= 2;
200005d9:	01 ff                	add    %edi,%edi
			elf = realloc(elf, elfsize);
200005db:	51                   	push   %ecx
200005dc:	51                   	push   %ecx
200005dd:	57                   	push   %edi
200005de:	56                   	push   %esi
200005df:	e8 85 0a 00 00       	call   20001069 <realloc>
200005e4:	83 c4 10             	add    $0x10,%esp
200005e7:	89 c6                	mov    %eax,%esi
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
200005e9:	8b 43 0c             	mov    0xc(%ebx),%eax
200005ec:	85 c0                	test   %eax,%eax
200005ee:	74 12                	je     20000602 <execp+0xa2>
200005f0:	52                   	push   %edx
200005f1:	50                   	push   %eax
200005f2:	ff 75 e4             	pushl  -0x1c(%ebp)
200005f5:	8b 03                	mov    (%ebx),%eax
200005f7:	01 f0                	add    %esi,%eax
200005f9:	50                   	push   %eax
200005fa:	e8 01 07 00 00       	call   20000d00 <memcpy>
200005ff:	83 c4 10             	add    $0x10,%esp

		driverData->pos += driverData->bytesDone;
20000602:	8b 43 0c             	mov    0xc(%ebx),%eax
20000605:	31 d2                	xor    %edx,%edx
20000607:	01 03                	add    %eax,(%ebx)
20000609:	11 53 04             	adc    %edx,0x4(%ebx)
	} while(driverData->bytesDone != 0);
2000060c:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
20000610:	75 8e                	jne    200005a0 <execp+0x40>

	kprintf("Executing init from init...\n");
20000612:	83 ec 0c             	sub    $0xc,%esp
20000615:	68 b9 30 00 20       	push   $0x200030b9
2000061a:	e8 66 01 00 00       	call   20000785 <kprintf>
	THREAD ret = exec(elf, driverData->pos, data, datasize);
2000061f:	ff 75 10             	pushl  0x10(%ebp)
20000622:	ff 75 0c             	pushl  0xc(%ebp)
20000625:	ff 33                	pushl  (%ebx)
20000627:	56                   	push   %esi
20000628:	e8 2b fe ff ff       	call   20000458 <exec>

	pfree(driverData);
2000062d:	83 c4 14             	add    $0x14,%esp
20000630:	89 45 e0             	mov    %eax,-0x20(%ebp)
20000633:	53                   	push   %ebx
20000634:	e8 34 07 00 00       	call   20000d6d <pfree>
	free(elf);
20000639:	89 34 24             	mov    %esi,(%esp)
2000063c:	e8 cf 07 00 00       	call   20000e10 <free>

	return ret;
}
20000641:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000644:	8d 65 f4             	lea    -0xc(%ebp),%esp
20000647:	5b                   	pop    %ebx
20000648:	5e                   	pop    %esi
20000649:	5f                   	pop    %edi
2000064a:	5d                   	pop    %ebp
2000064b:	c3                   	ret    

2000064c <execpn>:

THREAD execpn(char* path) {
2000064c:	55                   	push   %ebp
2000064d:	89 e5                	mov    %esp,%ebp
2000064f:	83 ec 0c             	sub    $0xc,%esp
	return execp(path, 0, 0);
20000652:	6a 00                	push   $0x0
20000654:	6a 00                	push   $0x0
20000656:	ff 75 08             	pushl  0x8(%ebp)
20000659:	e8 02 ff ff ff       	call   20000560 <execp>
}
2000065e:	c9                   	leave  
2000065f:	c3                   	ret    

20000660 <_start>:
	syscall(&state);

	return state.eax;
}

void _start() {
20000660:	55                   	push   %ebp
20000661:	89 e5                	mov    %esp,%ebp
20000663:	83 ec 08             	sub    $0x8,%esp
	rpc_init();
20000666:	e8 9c 02 00 00       	call   20000907 <rpc_init>

	int result = main(getargsptr());
2000066b:	e8 75 fe ff ff       	call   200004e5 <getargsptr>
20000670:	83 ec 0c             	sub    $0xc,%esp
20000673:	50                   	push   %eax
20000674:	e8 61 fb ff ff       	call   200001da <main>

	exit(result);
20000679:	89 04 24             	mov    %eax,(%esp)
2000067c:	e8 a2 fe ff ff       	call   20000523 <exit>
20000681:	83 c4 10             	add    $0x10,%esp
}
20000684:	c9                   	leave  
20000685:	c3                   	ret    
	...

20000688 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
20000688:	55                   	push   %ebp
20000689:	89 e5                	mov    %esp,%ebp
2000068b:	57                   	push   %edi
2000068c:	56                   	push   %esi
2000068d:	53                   	push   %ebx
2000068e:	83 ec 10             	sub    $0x10,%esp
	asm("int $0x30"
20000691:	8b 55 08             	mov    0x8(%ebp),%edx
20000694:	8b 45 08             	mov    0x8(%ebp),%eax
20000697:	8b 72 0c             	mov    0xc(%edx),%esi
2000069a:	8b 00                	mov    (%eax),%eax
2000069c:	89 75 e4             	mov    %esi,-0x1c(%ebp)
2000069f:	8b 5a 04             	mov    0x4(%edx),%ebx
200006a2:	8b 4a 08             	mov    0x8(%edx),%ecx
200006a5:	8b 72 10             	mov    0x10(%edx),%esi
200006a8:	8b 7a 14             	mov    0x14(%edx),%edi
200006ab:	89 45 ec             	mov    %eax,-0x14(%ebp)
200006ae:	8b 55 e4             	mov    -0x1c(%ebp),%edx
200006b1:	cd 30                	int    $0x30
200006b3:	89 55 e8             	mov    %edx,-0x18(%ebp)
200006b6:	8b 55 08             	mov    0x8(%ebp),%edx
200006b9:	89 45 f0             	mov    %eax,-0x10(%ebp)
200006bc:	89 02                	mov    %eax,(%edx)
200006be:	8b 45 e8             	mov    -0x18(%ebp),%eax
200006c1:	89 5a 04             	mov    %ebx,0x4(%edx)
200006c4:	89 4a 08             	mov    %ecx,0x8(%edx)
200006c7:	89 42 0c             	mov    %eax,0xc(%edx)
200006ca:	89 72 10             	mov    %esi,0x10(%edx)
200006cd:	89 7a 14             	mov    %edi,0x14(%edx)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
200006d0:	83 c4 10             	add    $0x10,%esp
200006d3:	5b                   	pop    %ebx
200006d4:	5e                   	pop    %esi
200006d5:	5f                   	pop    %edi
200006d6:	5d                   	pop    %ebp
200006d7:	c3                   	ret    

200006d8 <setclr>:
        x /= base;
    } while (x);
    kputs(p);
}

void setclr(char clr) {
200006d8:	55                   	push   %ebp
200006d9:	89 e5                	mov    %esp,%ebp
    color = clr;
200006db:	8b 45 08             	mov    0x8(%ebp),%eax
}
200006de:	5d                   	pop    %ebp
    } while (x);
    kputs(p);
}

void setclr(char clr) {
    color = clr;
200006df:	a2 00 20 00 20       	mov    %al,0x20002000
}
200006e4:	c3                   	ret    

200006e5 <kputc>:
static int x = 0;
static int y = 0;
static int kprintf_res = 0;
static char color = 0x07;

void kputc(char c) {
200006e5:	55                   	push   %ebp
200006e6:	89 e5                	mov    %esp,%ebp
200006e8:	83 ec 34             	sub    $0x34,%esp
200006eb:	0f be 45 08          	movsbl 0x8(%ebp),%eax
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200006ef:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200006f2:	8d 45 e0             	lea    -0x20(%ebp),%eax
200006f5:	50                   	push   %eax
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200006f6:	c7 45 e0 00 01 00 00 	movl   $0x100,-0x20(%ebp)
200006fd:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000704:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000070b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000712:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000719:	e8 6a ff ff ff       	call   20000688 <syscall>
2000071e:	83 c4 10             	add    $0x10,%esp
}
20000721:	c9                   	leave  
20000722:	c3                   	ret    

20000723 <kputs>:

void kputs(const char* s) {
20000723:	55                   	push   %ebp
20000724:	89 e5                	mov    %esp,%ebp
20000726:	53                   	push   %ebx
20000727:	83 ec 04             	sub    $0x4,%esp
2000072a:	8b 5d 08             	mov    0x8(%ebp),%ebx
    while (*s) {
2000072d:	eb 10                	jmp    2000073f <kputs+0x1c>
        kputc(*s++);
2000072f:	83 ec 0c             	sub    $0xc,%esp
20000732:	43                   	inc    %ebx
20000733:	0f be c0             	movsbl %al,%eax
20000736:	50                   	push   %eax
20000737:	e8 a9 ff ff ff       	call   200006e5 <kputc>
2000073c:	83 c4 10             	add    $0x10,%esp

	syscall(&state);
}

void kputs(const char* s) {
    while (*s) {
2000073f:	8a 03                	mov    (%ebx),%al
20000741:	84 c0                	test   %al,%al
20000743:	75 ea                	jne    2000072f <kputs+0xc>
        kputc(*s++);
    }
}
20000745:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000748:	c9                   	leave  
20000749:	c3                   	ret    

2000074a <kputn>:

void kputn(unsigned long x, int base) {
2000074a:	55                   	push   %ebp
2000074b:	89 e5                	mov    %esp,%ebp
2000074d:	53                   	push   %ebx
2000074e:	83 ec 54             	sub    $0x54,%esp
20000751:	8b 5d 0c             	mov    0xc(%ebp),%ebx
20000754:	8b 45 08             	mov    0x8(%ebp),%eax
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    char* p;

    if (base > 36) {
20000757:	83 fb 24             	cmp    $0x24,%ebx
2000075a:	7f 24                	jg     20000780 <kputn+0x36>
        return;
    }

    p = buf + 64;
    *p = '\0';
2000075c:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
20000760:	8d 4d f7             	lea    -0x9(%ebp),%ecx
    do {
        *--p = digits[x % base];
20000763:	31 d2                	xor    %edx,%edx
20000765:	49                   	dec    %ecx
20000766:	f7 f3                	div    %ebx
        x /= base;
    } while (x);
20000768:	85 c0                	test   %eax,%eax
    }

    p = buf + 64;
    *p = '\0';
    do {
        *--p = digits[x % base];
2000076a:	8a 92 d6 30 00 20    	mov    0x200030d6(%edx),%dl
20000770:	88 11                	mov    %dl,(%ecx)
        x /= base;
    } while (x);
20000772:	75 ef                	jne    20000763 <kputn+0x19>
    kputs(p);
20000774:	83 ec 0c             	sub    $0xc,%esp
20000777:	51                   	push   %ecx
20000778:	e8 a6 ff ff ff       	call   20000723 <kputs>
2000077d:	83 c4 10             	add    $0x10,%esp
}
20000780:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000783:	c9                   	leave  
20000784:	c3                   	ret    

20000785 <kprintf>:

void setclr(char clr) {
    color = clr;
}

int kprintf(const char* fmt, ...) {
20000785:	55                   	push   %ebp
20000786:	89 e5                	mov    %esp,%ebp
20000788:	57                   	push   %edi
20000789:	56                   	push   %esi
2000078a:	53                   	push   %ebx
2000078b:	83 ec 0c             	sub    $0xc,%esp
2000078e:	8d 5d 0c             	lea    0xc(%ebp),%ebx
20000791:	8b 75 08             	mov    0x8(%ebp),%esi
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
20000794:	c7 05 20 40 04 20 00 	movl   $0x0,0x20044020
2000079b:	00 00 00 
    while (*fmt) {
2000079e:	e9 99 00 00 00       	jmp    2000083c <kprintf+0xb7>
        if (*fmt == '%') {
200007a3:	3c 25                	cmp    $0x25,%al
200007a5:	0f 85 81 00 00 00    	jne    2000082c <kprintf+0xa7>
            fmt++;
200007ab:	46                   	inc    %esi
            switch (*fmt) {
200007ac:	8a 06                	mov    (%esi),%al
200007ae:	3c 70                	cmp    $0x70,%al
200007b0:	74 40                	je     200007f2 <kprintf+0x6d>
200007b2:	7f 1a                	jg     200007ce <kprintf+0x49>
200007b4:	3c 63                	cmp    $0x63,%al
200007b6:	74 4c                	je     20000804 <kprintf+0x7f>
200007b8:	7f 0e                	jg     200007c8 <kprintf+0x43>
200007ba:	84 c0                	test   %al,%al
200007bc:	0f 84 84 00 00 00    	je     20000846 <kprintf+0xc1>
200007c2:	3c 25                	cmp    $0x25,%al
200007c4:	75 56                	jne    2000081c <kprintf+0x97>
200007c6:	eb 4d                	jmp    20000815 <kprintf+0x90>
200007c8:	3c 64                	cmp    $0x64,%al
200007ca:	75 50                	jne    2000081c <kprintf+0x97>
200007cc:	eb 1b                	jmp    200007e9 <kprintf+0x64>
200007ce:	3c 75                	cmp    $0x75,%al
200007d0:	74 17                	je     200007e9 <kprintf+0x64>
200007d2:	3c 78                	cmp    $0x78,%al
200007d4:	74 1c                	je     200007f2 <kprintf+0x6d>
200007d6:	3c 73                	cmp    $0x73,%al
200007d8:	75 42                	jne    2000081c <kprintf+0x97>
            case 's':
                s = va_arg(ap, char*);
                kputs(s);
200007da:	83 ec 0c             	sub    $0xc,%esp
    while (*fmt) {
        if (*fmt == '%') {
            fmt++;
            switch (*fmt) {
            case 's':
                s = va_arg(ap, char*);
200007dd:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputs(s);
200007e0:	ff 33                	pushl  (%ebx)
200007e2:	e8 3c ff ff ff       	call   20000723 <kputs>
200007e7:	eb 17                	jmp    20000800 <kprintf+0x7b>
                break;
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
200007e9:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 10);
200007ec:	51                   	push   %ecx
200007ed:	51                   	push   %ecx
200007ee:	6a 0a                	push   $0xa
200007f0:	eb 07                	jmp    200007f9 <kprintf+0x74>
                break;
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
200007f2:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 16);
200007f5:	52                   	push   %edx
200007f6:	52                   	push   %edx
200007f7:	6a 10                	push   $0x10
200007f9:	ff 33                	pushl  (%ebx)
200007fb:	e8 4a ff ff ff       	call   2000074a <kputn>
20000800:	89 fb                	mov    %edi,%ebx
20000802:	eb 34                	jmp    20000838 <kprintf+0xb3>
                break;
            case 'c':
                c = va_arg(ap, int);
                kputc(c);
20000804:	83 ec 0c             	sub    $0xc,%esp
            case 'p':
                n = va_arg(ap, unsigned long int);
                kputn(n, 16);
                break;
            case 'c':
                c = va_arg(ap, int);
20000807:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputc(c);
2000080a:	0f be 03             	movsbl (%ebx),%eax
2000080d:	50                   	push   %eax
2000080e:	e8 d2 fe ff ff       	call   200006e5 <kputc>
20000813:	eb eb                	jmp    20000800 <kprintf+0x7b>
                break;
            case '%':
                kputc('%');
20000815:	83 ec 0c             	sub    $0xc,%esp
20000818:	6a 25                	push   $0x25
2000081a:	eb 17                	jmp    20000833 <kprintf+0xae>
                break;
            case '\0':
                goto out;
            default:
                kputc('%');
2000081c:	83 ec 0c             	sub    $0xc,%esp
2000081f:	6a 25                	push   $0x25
20000821:	e8 bf fe ff ff       	call   200006e5 <kputc>
                kputc(*fmt);
20000826:	58                   	pop    %eax
20000827:	0f be 06             	movsbl (%esi),%eax
2000082a:	eb 06                	jmp    20000832 <kprintf+0xad>
                break;
            }
        } else {
            kputc(*fmt);
2000082c:	83 ec 0c             	sub    $0xc,%esp
2000082f:	0f be c0             	movsbl %al,%eax
20000832:	50                   	push   %eax
20000833:	e8 ad fe ff ff       	call   200006e5 <kputc>
20000838:	83 c4 10             	add    $0x10,%esp
        }

        fmt++;
2000083b:	46                   	inc    %esi
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
    while (*fmt) {
2000083c:	8a 06                	mov    (%esi),%al
2000083e:	84 c0                	test   %al,%al
20000840:	0f 85 5d ff ff ff    	jne    200007a3 <kprintf+0x1e>

    out:
    va_end(ap);

    return kprintf_res;
}
20000846:	a1 20 40 04 20       	mov    0x20044020,%eax
2000084b:	8d 65 f4             	lea    -0xc(%ebp),%esp
2000084e:	5b                   	pop    %ebx
2000084f:	5e                   	pop    %esi
20000850:	5f                   	pop    %edi
20000851:	5d                   	pop    %ebp
20000852:	c3                   	ret    
	...

20000854 <rpc_register_handler>:
	syscall(&state);

	return state.eax;
}

int rpc_register_handler(int(*fptr)(int, void*)) {
20000854:	55                   	push   %ebp
20000855:	31 c0                	xor    %eax,%eax
20000857:	89 e5                	mov    %esp,%ebp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		if(rpcHandlers[i] == (int(*)(int, void*))0) {
20000859:	83 3c 85 24 40 04 20 	cmpl   $0x0,0x20044024(,%eax,4)
20000860:	00 
20000861:	75 0c                	jne    2000086f <rpc_register_handler+0x1b>
			rpcHandlers[i] = fptr;
20000863:	8b 55 08             	mov    0x8(%ebp),%edx
20000866:	89 14 85 24 40 04 20 	mov    %edx,0x20044024(,%eax,4)
			return i;
2000086d:	eb 0b                	jmp    2000087a <rpc_register_handler+0x26>

	return state.eax;
}

int rpc_register_handler(int(*fptr)(int, void*)) {
	for(int i = 0; i < RPC_HANDLERS; i++) {
2000086f:	40                   	inc    %eax
20000870:	3d 00 04 00 00       	cmp    $0x400,%eax
20000875:	75 e2                	jne    20000859 <rpc_register_handler+0x5>
20000877:	83 c8 ff             	or     $0xffffffff,%eax
			rpcHandlers[i] = fptr;
			return i;
		}
	}
	return -1;
}
2000087a:	5d                   	pop    %ebp
2000087b:	c3                   	ret    

2000087c <rpc_check_future>:
	*rpcARG0 = state.ecx;
	return (void*) state.eax;
}


int rpc_check_future(FUTURE fut) {
2000087c:	55                   	push   %ebp
2000087d:	89 e5                	mov    %esp,%ebp
2000087f:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000882:	8b 45 08             	mov    0x8(%ebp),%eax
20000885:	c7 45 e0 03 02 00 00 	movl   $0x203,-0x20(%ebp)
2000088c:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000088f:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000892:	50                   	push   %eax
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000893:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
2000089a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200008a1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200008a8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200008af:	e8 d4 fd ff ff       	call   20000688 <syscall>

	return state.eax;
}
200008b4:	8b 45 e0             	mov    -0x20(%ebp),%eax
200008b7:	c9                   	leave  
200008b8:	c3                   	ret    

200008b9 <rpc_map>:
			.edi = 0 };

	syscall(&state);
}

void* rpc_map(uint32_t* rpcID, uint32_t* rpcARG0) {
200008b9:	55                   	push   %ebp
200008ba:	89 e5                	mov    %esp,%ebp
200008bc:	83 ec 34             	sub    $0x34,%esp
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
200008bf:	8d 45 e0             	lea    -0x20(%ebp),%eax
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200008c2:	c7 45 e0 00 02 00 00 	movl   $0x200,-0x20(%ebp)

	syscall(&state);
200008c9:	50                   	push   %eax
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200008ca:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
200008d1:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200008d8:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200008df:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200008e6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200008ed:	e8 96 fd ff ff       	call   20000688 <syscall>

	*rpcID = state.ebx;
200008f2:	8b 45 08             	mov    0x8(%ebp),%eax
200008f5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
200008f8:	89 10                	mov    %edx,(%eax)
	*rpcARG0 = state.ecx;
200008fa:	8b 45 0c             	mov    0xc(%ebp),%eax
200008fd:	8b 55 e8             	mov    -0x18(%ebp),%edx
20000900:	89 10                	mov    %edx,(%eax)
	return (void*) state.eax;
}
20000902:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000905:	c9                   	leave  
20000906:	c3                   	ret    

20000907 <rpc_init>:
	syscall(&state);

	while(1);
}

void rpc_init() {
20000907:	55                   	push   %ebp
20000908:	31 c0                	xor    %eax,%eax
2000090a:	89 e5                	mov    %esp,%ebp
2000090c:	57                   	push   %edi
2000090d:	56                   	push   %esi
2000090e:	83 ec 20             	sub    $0x20,%esp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		rpcHandlers[i] = (int(*)(int, void*))0;
20000911:	c7 04 85 24 40 04 20 	movl   $0x0,0x20044024(,%eax,4)
20000918:	00 00 00 00 

	while(1);
}

void rpc_init() {
	for(int i = 0; i < RPC_HANDLERS; i++) {
2000091c:	40                   	inc    %eax
2000091d:	3d 00 04 00 00       	cmp    $0x400,%eax
20000922:	75 ed                	jne    20000911 <rpc_init+0xa>
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000924:	8d 7d e0             	lea    -0x20(%ebp),%edi
20000927:	be 90 30 00 20       	mov    $0x20003090,%esi
2000092c:	b9 06 00 00 00       	mov    $0x6,%ecx

	syscall(&state);
20000931:	83 ec 0c             	sub    $0xc,%esp
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000934:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

	syscall(&state);
20000936:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000939:	50                   	push   %eax
2000093a:	e8 49 fd ff ff       	call   20000688 <syscall>
2000093f:	83 c4 10             	add    $0x10,%esp
}
20000942:	8d 65 f8             	lea    -0x8(%ebp),%esp
20000945:	5e                   	pop    %esi
20000946:	5f                   	pop    %edi
20000947:	5d                   	pop    %ebp
20000948:	c3                   	ret    

20000949 <rpc_return>:

#define RPC_HANDLERS 1024

static int(*rpcHandlers[RPC_HANDLERS])(int, void*);

void rpc_return(int returnCode) {
20000949:	55                   	push   %ebp
2000094a:	89 e5                	mov    %esp,%ebp
2000094c:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000094f:	8b 45 08             	mov    0x8(%ebp),%eax
20000952:	c7 45 e0 01 02 00 00 	movl   $0x201,-0x20(%ebp)
20000959:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000095c:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000095f:	50                   	push   %eax
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000960:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000967:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000096e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000975:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000097c:	e8 07 fd ff ff       	call   20000688 <syscall>
20000981:	83 c4 10             	add    $0x10,%esp
20000984:	eb fe                	jmp    20000984 <rpc_return+0x3b>

20000986 <rpc_handler>:
		}
	}
	return -1;
}

void rpc_handler() {
20000986:	55                   	push   %ebp
20000987:	89 e5                	mov    %esp,%ebp
20000989:	83 ec 20             	sub    $0x20,%esp
	uint32_t rpcID;
	uint32_t rpcARG0;
	void* rpcData = rpc_map(&rpcID, &rpcARG0);
2000098c:	8d 45 f0             	lea    -0x10(%ebp),%eax
2000098f:	50                   	push   %eax
20000990:	8d 45 f4             	lea    -0xc(%ebp),%eax
20000993:	50                   	push   %eax
20000994:	e8 20 ff ff ff       	call   200008b9 <rpc_map>

	int returnValue = -1;

	if(rpcID < RPC_HANDLERS && rpcHandlers[rpcID] != 0) {
20000999:	8b 55 f4             	mov    -0xc(%ebp),%edx
2000099c:	83 c4 10             	add    $0x10,%esp
2000099f:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
200009a5:	77 18                	ja     200009bf <rpc_handler+0x39>
200009a7:	8b 14 95 24 40 04 20 	mov    0x20044024(,%edx,4),%edx
200009ae:	85 d2                	test   %edx,%edx
200009b0:	74 0d                	je     200009bf <rpc_handler+0x39>
		returnValue = rpcHandlers[rpcID](rpcARG0, rpcData);
200009b2:	51                   	push   %ecx
200009b3:	51                   	push   %ecx
200009b4:	50                   	push   %eax
200009b5:	ff 75 f0             	pushl  -0x10(%ebp)
200009b8:	ff d2                	call   *%edx
200009ba:	83 c4 10             	add    $0x10,%esp
200009bd:	eb 03                	jmp    200009c2 <rpc_handler+0x3c>
200009bf:	83 c8 ff             	or     $0xffffffff,%eax
	}

	rpc_return(returnValue);
200009c2:	83 ec 0c             	sub    $0xc,%esp
200009c5:	50                   	push   %eax
200009c6:	e8 7e ff ff ff       	call   20000949 <rpc_return>
200009cb:	83 c4 10             	add    $0x10,%esp
}
200009ce:	c9                   	leave  
200009cf:	c3                   	ret    

200009d0 <fRead>:
	syscall(&state);

	return state.eax;
}

FUTURE fRead(char* path, struct driver_data* drvData) {
200009d0:	55                   	push   %ebp
200009d1:	89 e5                	mov    %esp,%ebp
200009d3:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x305,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200009d6:	8b 45 08             	mov    0x8(%ebp),%eax
200009d9:	c7 45 e0 05 03 00 00 	movl   $0x305,-0x20(%ebp)
200009e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
200009e3:	8b 45 0c             	mov    0xc(%ebp),%eax
200009e6:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
200009e9:	8d 45 e0             	lea    -0x20(%ebp),%eax
200009ec:	50                   	push   %eax
			.eax = 0x305,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200009ed:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200009f4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200009fb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000a02:	e8 81 fc ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000a07:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000a0a:	c9                   	leave  
20000a0b:	c3                   	ret    

20000a0c <fWrite>:
	syscall(&state);

	return state.eax;
}

FUTURE fWrite(char* path, struct driver_data* drvData) {
20000a0c:	55                   	push   %ebp
20000a0d:	89 e5                	mov    %esp,%ebp
20000a0f:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x304,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a12:	8b 45 08             	mov    0x8(%ebp),%eax
20000a15:	c7 45 e0 04 03 00 00 	movl   $0x304,-0x20(%ebp)
20000a1c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000a1f:	8b 45 0c             	mov    0xc(%ebp),%eax
20000a22:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000a25:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000a28:	50                   	push   %eax
			.eax = 0x304,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a29:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000a30:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000a37:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000a3e:	e8 45 fc ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000a43:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000a46:	c9                   	leave  
20000a47:	c3                   	ret    

20000a48 <fCall>:
	syscall(&state);

	return state.eax;
}

FUTURE fCall(char* driverName, int callID, struct driver_data* drvData) {
20000a48:	55                   	push   %ebp
20000a49:	89 e5                	mov    %esp,%ebp
20000a4b:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x303,
			.ebx = (uint32_t)driverName,
			.ecx = (uint32_t)drvData,
			.edx = callID,
			.esi = 0,
			.edi = 0 };
20000a4e:	8b 45 08             	mov    0x8(%ebp),%eax
20000a51:	c7 45 e0 03 03 00 00 	movl   $0x303,-0x20(%ebp)
20000a58:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000a5b:	8b 45 10             	mov    0x10(%ebp),%eax
20000a5e:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000a61:	8b 45 0c             	mov    0xc(%ebp),%eax
20000a64:	89 45 ec             	mov    %eax,-0x14(%ebp)

	syscall(&state);
20000a67:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000a6a:	50                   	push   %eax
			.eax = 0x303,
			.ebx = (uint32_t)driverName,
			.ecx = (uint32_t)drvData,
			.edx = callID,
			.esi = 0,
			.edi = 0 };
20000a6b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000a72:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000a79:	e8 0a fc ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000a7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000a81:	c9                   	leave  
20000a82:	c3                   	ret    

20000a83 <fModify>:
	syscall(&state);

	return state.eax;
}

FUTURE fModify(char* path, struct driver_data* drvData) {
20000a83:	55                   	push   %ebp
20000a84:	89 e5                	mov    %esp,%ebp
20000a86:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x302,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a89:	8b 45 08             	mov    0x8(%ebp),%eax
20000a8c:	c7 45 e0 02 03 00 00 	movl   $0x302,-0x20(%ebp)
20000a93:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000a96:	8b 45 0c             	mov    0xc(%ebp),%eax
20000a99:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000a9c:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000a9f:	50                   	push   %eax
			.eax = 0x302,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000aa0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000aa7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000aae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000ab5:	e8 ce fb ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000aba:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000abd:	c9                   	leave  
20000abe:	c3                   	ret    

20000abf <inl>:
	syscall(&state);

	return state.eax;
}

uint32_t inl(uint16_t port) {
20000abf:	55                   	push   %ebp
20000ac0:	89 e5                	mov    %esp,%ebp
20000ac2:	83 ec 34             	sub    $0x34,%esp
20000ac5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x606,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000ac9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000acc:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000acf:	50                   	push   %eax
			.eax = 0x606,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000ad0:	c7 45 e0 06 06 00 00 	movl   $0x606,-0x20(%ebp)
20000ad7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000ade:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000ae5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000aec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000af3:	e8 90 fb ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000af8:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000afb:	c9                   	leave  
20000afc:	c3                   	ret    

20000afd <inw>:
	syscall(&state);

	return state.eax;
}

uint16_t inw(uint16_t port) {
20000afd:	55                   	push   %ebp
20000afe:	89 e5                	mov    %esp,%ebp
20000b00:	83 ec 34             	sub    $0x34,%esp
20000b03:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x605,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b07:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000b0a:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b0d:	50                   	push   %eax
			.eax = 0x605,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b0e:	c7 45 e0 05 06 00 00 	movl   $0x605,-0x20(%ebp)
20000b15:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000b1c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000b23:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000b2a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000b31:	e8 52 fb ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000b36:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000b39:	c9                   	leave  
20000b3a:	c3                   	ret    

20000b3b <inb>:
			.edi = 0 };

	syscall(&state);
}

uint8_t inb(uint16_t port) {
20000b3b:	55                   	push   %ebp
20000b3c:	89 e5                	mov    %esp,%ebp
20000b3e:	83 ec 34             	sub    $0x34,%esp
20000b41:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x604,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b45:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000b48:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b4b:	50                   	push   %eax
			.eax = 0x604,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b4c:	c7 45 e0 04 06 00 00 	movl   $0x604,-0x20(%ebp)
20000b53:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000b5a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000b61:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000b68:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000b6f:	e8 14 fb ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000b74:	8a 45 e0             	mov    -0x20(%ebp),%al
20000b77:	c9                   	leave  
20000b78:	c3                   	ret    

20000b79 <outl>:
			.edi = 0 };

	syscall(&state);
}

void outl(uint16_t port, uint32_t value) {
20000b79:	55                   	push   %ebp
20000b7a:	89 e5                	mov    %esp,%ebp
20000b7c:	83 ec 34             	sub    $0x34,%esp
20000b7f:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x603,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b83:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000b86:	8b 45 0c             	mov    0xc(%ebp),%eax
20000b89:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000b8c:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b8f:	50                   	push   %eax
			.eax = 0x603,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b90:	c7 45 e0 03 06 00 00 	movl   $0x603,-0x20(%ebp)
20000b97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000b9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000ba5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000bac:	e8 d7 fa ff ff       	call   20000688 <syscall>
20000bb1:	83 c4 10             	add    $0x10,%esp
}
20000bb4:	c9                   	leave  
20000bb5:	c3                   	ret    

20000bb6 <outw>:
			.edi = 0 };

	syscall(&state);
}

void outw(uint16_t port, uint16_t value) {
20000bb6:	55                   	push   %ebp
20000bb7:	89 e5                	mov    %esp,%ebp
20000bb9:	83 ec 34             	sub    $0x34,%esp
20000bbc:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
20000bc0:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
			.eax = 0x602,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000bc4:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000bc7:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000bca:	50                   	push   %eax
			.eax = 0x602,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000bcb:	c7 45 e0 02 06 00 00 	movl   $0x602,-0x20(%ebp)
20000bd2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
20000bd5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000bdc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000be3:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000bea:	e8 99 fa ff ff       	call   20000688 <syscall>
20000bef:	83 c4 10             	add    $0x10,%esp
}
20000bf2:	c9                   	leave  
20000bf3:	c3                   	ret    

20000bf4 <outb>:
	syscall(&state);

	return state.eax;
}

void outb(uint16_t port, uint8_t value) {
20000bf4:	55                   	push   %ebp
20000bf5:	89 e5                	mov    %esp,%ebp
20000bf7:	83 ec 34             	sub    $0x34,%esp
20000bfa:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x601,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000bfe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000c01:	c7 45 e0 01 06 00 00 	movl   $0x601,-0x20(%ebp)
20000c08:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
20000c0c:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000c0f:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c12:	50                   	push   %eax
			.eax = 0x601,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c13:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000c1a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000c21:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000c28:	e8 5b fa ff ff       	call   20000688 <syscall>
20000c2d:	83 c4 10             	add    $0x10,%esp
}
20000c30:	c9                   	leave  
20000c31:	c3                   	ret    

20000c32 <register_irq_rpc>:
	syscall(&state);

	return state.eax;
}

int register_irq_rpc(uint32_t irqID, int rpcID) {
20000c32:	55                   	push   %ebp
20000c33:	89 e5                	mov    %esp,%ebp
20000c35:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x600,
			.ebx = irqID,
			.ecx = rpcID,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c38:	8b 45 08             	mov    0x8(%ebp),%eax
20000c3b:	c7 45 e0 00 06 00 00 	movl   $0x600,-0x20(%ebp)
20000c42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000c45:	8b 45 0c             	mov    0xc(%ebp),%eax
20000c48:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000c4b:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c4e:	50                   	push   %eax
			.eax = 0x600,
			.ebx = irqID,
			.ecx = rpcID,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c4f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000c56:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000c5d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000c64:	e8 1f fa ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000c69:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000c6c:	c9                   	leave  
20000c6d:	c3                   	ret    

20000c6e <register_path>:
	syscall(&state);

	return state.eax;
}

int register_path(char* path, int driverID, int resourceID) {
20000c6e:	55                   	push   %ebp
20000c6f:	89 e5                	mov    %esp,%ebp
20000c71:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x301,
			.ebx = (uint32_t)path,
			.ecx = driverID,
			.edx = resourceID,
			.esi = 0,
			.edi = 0 };
20000c74:	8b 45 08             	mov    0x8(%ebp),%eax
20000c77:	c7 45 e0 01 03 00 00 	movl   $0x301,-0x20(%ebp)
20000c7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000c81:	8b 45 0c             	mov    0xc(%ebp),%eax
20000c84:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000c87:	8b 45 10             	mov    0x10(%ebp),%eax
20000c8a:	89 45 ec             	mov    %eax,-0x14(%ebp)

	syscall(&state);
20000c8d:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c90:	50                   	push   %eax
			.eax = 0x301,
			.ebx = (uint32_t)path,
			.ecx = driverID,
			.edx = resourceID,
			.esi = 0,
			.edi = 0 };
20000c91:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000c98:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000c9f:	e8 e4 f9 ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000ca4:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000ca7:	c9                   	leave  
20000ca8:	c3                   	ret    

20000ca9 <register_driver>:
#include "driver.h"
#include "syscall.h"
#include "memory.h"

int register_driver(int dModifyID, int dInfoID, int dReadID, int dWriteID, char* drvName) {
20000ca9:	55                   	push   %ebp
20000caa:	89 e5                	mov    %esp,%ebp
20000cac:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x300,
			.ebx = dModifyID,
			.ecx = dInfoID,
			.edx = dReadID,
			.esi = dWriteID,
			.edi = (uint32_t)drvName };
20000caf:	8b 45 08             	mov    0x8(%ebp),%eax
20000cb2:	c7 45 e0 00 03 00 00 	movl   $0x300,-0x20(%ebp)
20000cb9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000cbc:	8b 45 0c             	mov    0xc(%ebp),%eax
20000cbf:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000cc2:	8b 45 10             	mov    0x10(%ebp),%eax
20000cc5:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000cc8:	8b 45 14             	mov    0x14(%ebp),%eax
20000ccb:	89 45 f0             	mov    %eax,-0x10(%ebp)
20000cce:	8b 45 18             	mov    0x18(%ebp),%eax
20000cd1:	89 45 f4             	mov    %eax,-0xc(%ebp)

	syscall(&state);
20000cd4:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000cd7:	50                   	push   %eax
20000cd8:	e8 ab f9 ff ff       	call   20000688 <syscall>

	return state.eax;
}
20000cdd:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000ce0:	c9                   	leave  
20000ce1:	c3                   	ret    
	...

20000ce4 <memset>:
			.edi = 0 };

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
20000ce4:	55                   	push   %ebp
20000ce5:	89 e5                	mov    %esp,%ebp
20000ce7:	53                   	push   %ebx
20000ce8:	8b 45 08             	mov    0x8(%ebp),%eax
20000ceb:	8b 5d 0c             	mov    0xc(%ebp),%ebx
20000cee:	8b 4d 10             	mov    0x10(%ebp),%ecx
	unsigned char* p = buf;
20000cf1:	89 c2                	mov    %eax,%edx

	while (n--) {
20000cf3:	eb 04                	jmp    20000cf9 <memset+0x15>
		*p++ = c;
20000cf5:	88 1a                	mov    %bl,(%edx)
20000cf7:	49                   	dec    %ecx
20000cf8:	42                   	inc    %edx
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;

	while (n--) {
20000cf9:	85 c9                	test   %ecx,%ecx
20000cfb:	75 f8                	jne    20000cf5 <memset+0x11>
		*p++ = c;
	}

	return buf;
}
20000cfd:	5b                   	pop    %ebx
20000cfe:	5d                   	pop    %ebp
20000cff:	c3                   	ret    

20000d00 <memcpy>:

void* memcpy(void* dest, const void* src, uint32_t n) {
20000d00:	55                   	push   %ebp
	unsigned char* d = dest;
	const unsigned char* s = src;

	if (n == 0)
20000d01:	31 c9                	xor    %ecx,%ecx
	}

	return buf;
}

void* memcpy(void* dest, const void* src, uint32_t n) {
20000d03:	89 e5                	mov    %esp,%ebp
20000d05:	56                   	push   %esi
20000d06:	53                   	push   %ebx
20000d07:	8b 75 10             	mov    0x10(%ebp),%esi
20000d0a:	8b 45 08             	mov    0x8(%ebp),%eax
20000d0d:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	unsigned char* d = dest;
	const unsigned char* s = src;

	if (n == 0)
20000d10:	85 f6                	test   %esi,%esi
20000d12:	75 04                	jne    20000d18 <memcpy+0x18>
20000d14:	31 c0                	xor    %eax,%eax
20000d16:	eb 0a                	jmp    20000d22 <memcpy+0x22>
		return 0;

	while (n--) {
		*(d++) = *(s++);
20000d18:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
20000d1b:	88 14 08             	mov    %dl,(%eax,%ecx,1)
20000d1e:	41                   	inc    %ecx
	const unsigned char* s = src;

	if (n == 0)
		return 0;

	while (n--) {
20000d1f:	4e                   	dec    %esi
20000d20:	75 f6                	jne    20000d18 <memcpy+0x18>
		*(d++) = *(s++);
	}

	return dest;
}
20000d22:	5b                   	pop    %ebx
20000d23:	5e                   	pop    %esi
20000d24:	5d                   	pop    %ebp
20000d25:	c3                   	ret    

20000d26 <memcmp>:

int memcmp(const void* ptr1, const void* ptr2, uint32_t num) {
20000d26:	55                   	push   %ebp
	if (ptr1 == 0)
20000d27:	83 c8 ff             	or     $0xffffffff,%eax
	}

	return dest;
}

int memcmp(const void* ptr1, const void* ptr2, uint32_t num) {
20000d2a:	89 e5                	mov    %esp,%ebp
20000d2c:	57                   	push   %edi
20000d2d:	56                   	push   %esi
20000d2e:	53                   	push   %ebx
20000d2f:	8b 75 08             	mov    0x8(%ebp),%esi
20000d32:	8b 7d 0c             	mov    0xc(%ebp),%edi
20000d35:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (ptr1 == 0)
20000d38:	85 f6                	test   %esi,%esi
20000d3a:	74 2c                	je     20000d68 <memcmp+0x42>
		return -1;
	if (ptr2 == 0)
20000d3c:	b8 01 00 00 00       	mov    $0x1,%eax
20000d41:	85 ff                	test   %edi,%edi
20000d43:	74 23                	je     20000d68 <memcmp+0x42>
		return 1;
	if (num == 0)
20000d45:	31 d2                	xor    %edx,%edx
20000d47:	85 db                	test   %ebx,%ebx
20000d49:	75 17                	jne    20000d62 <memcmp+0x3c>
20000d4b:	eb 19                	jmp    20000d66 <memcmp+0x40>

	const uint8_t* pa = ptr1;
	const uint8_t* pb = ptr2;

	for (uint32_t i = 0; i < num; i++) {
		if (pa[i] != pb[i]) {
20000d4d:	8a 04 16             	mov    (%esi,%edx,1),%al
20000d50:	8a 0c 17             	mov    (%edi,%edx,1),%cl
20000d53:	38 c8                	cmp    %cl,%al
20000d55:	74 0a                	je     20000d61 <memcmp+0x3b>
			return pa[i] - pb[i];
20000d57:	0f b6 c0             	movzbl %al,%eax
20000d5a:	0f b6 c9             	movzbl %cl,%ecx
20000d5d:	29 c8                	sub    %ecx,%eax
20000d5f:	eb 07                	jmp    20000d68 <memcmp+0x42>
		return 0;

	const uint8_t* pa = ptr1;
	const uint8_t* pb = ptr2;

	for (uint32_t i = 0; i < num; i++) {
20000d61:	42                   	inc    %edx
20000d62:	39 da                	cmp    %ebx,%edx
20000d64:	72 e7                	jb     20000d4d <memcmp+0x27>
20000d66:	31 c0                	xor    %eax,%eax
		if (pa[i] != pb[i]) {
			return pa[i] - pb[i];
		}
	}
	return 0;
}
20000d68:	5b                   	pop    %ebx
20000d69:	5e                   	pop    %esi
20000d6a:	5f                   	pop    %edi
20000d6b:	5d                   	pop    %ebp
20000d6c:	c3                   	ret    

20000d6d <pfree>:
	memset((void*)state.eax, 0, pages * 0x1000);

	return (void*)state.eax;
}

void pfree(void* page) {
20000d6d:	55                   	push   %ebp
20000d6e:	89 e5                	mov    %esp,%ebp
20000d70:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x401,
			.ebx = (uint32_t)page,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000d73:	8b 45 08             	mov    0x8(%ebp),%eax
20000d76:	c7 45 e0 01 04 00 00 	movl   $0x401,-0x20(%ebp)
20000d7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000d80:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000d83:	50                   	push   %eax
			.eax = 0x401,
			.ebx = (uint32_t)page,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000d84:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000d8b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000d92:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000d99:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000da0:	e8 e3 f8 ff ff       	call   20000688 <syscall>
20000da5:	83 c4 10             	add    $0x10,%esp
}
20000da8:	c9                   	leave  
20000da9:	c3                   	ret    

20000daa <pcalloc>:

void* palloc() {
	return pcalloc(1);
}

void* pcalloc(uint32_t pages) {
20000daa:	55                   	push   %ebp
20000dab:	89 e5                	mov    %esp,%ebp
20000dad:	53                   	push   %ebx
20000dae:	83 ec 30             	sub    $0x30,%esp
20000db1:	8b 5d 08             	mov    0x8(%ebp),%ebx
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
20000db4:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000db7:	50                   	push   %eax
			.eax = 0x400,
			.ebx = pages,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000db8:	c7 45 e0 00 04 00 00 	movl   $0x400,-0x20(%ebp)
20000dbf:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
20000dc2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000dc9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000dd0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000dd7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000dde:	e8 a5 f8 ff ff       	call   20000688 <syscall>

	memset((void*)state.eax, 0, pages * 0x1000);
20000de3:	89 da                	mov    %ebx,%edx

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;
20000de5:	8b 45 e0             	mov    -0x20(%ebp),%eax
			.esi = 0,
			.edi = 0 };

	syscall(&state);

	memset((void*)state.eax, 0, pages * 0x1000);
20000de8:	c1 e2 0c             	shl    $0xc,%edx

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;
20000deb:	83 c4 10             	add    $0x10,%esp
20000dee:	eb 05                	jmp    20000df5 <pcalloc+0x4b>

	while (n--) {
		*p++ = c;
20000df0:	c6 00 00             	movb   $0x0,(%eax)
20000df3:	4a                   	dec    %edx
20000df4:	40                   	inc    %eax
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;

	while (n--) {
20000df5:	85 d2                	test   %edx,%edx
20000df7:	75 f7                	jne    20000df0 <pcalloc+0x46>
	syscall(&state);

	memset((void*)state.eax, 0, pages * 0x1000);

	return (void*)state.eax;
}
20000df9:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000dfc:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000dff:	c9                   	leave  
20000e00:	c3                   	ret    

20000e01 <palloc>:
#include "memory.h"
#include "syscall.h"

void* palloc() {
20000e01:	55                   	push   %ebp
20000e02:	89 e5                	mov    %esp,%ebp
20000e04:	83 ec 14             	sub    $0x14,%esp
	return pcalloc(1);
20000e07:	6a 01                	push   $0x1
20000e09:	e8 9c ff ff ff       	call   20000daa <pcalloc>
}
20000e0e:	c9                   	leave  
20000e0f:	c3                   	ret    

20000e10 <free>:
		cur = cur->next;
	}
	return NULL;
}

void free(void* ptr) {
20000e10:	55                   	push   %ebp
20000e11:	89 e5                	mov    %esp,%ebp
20000e13:	57                   	push   %edi
20000e14:	56                   	push   %esi
20000e15:	53                   	push   %ebx
20000e16:	83 ec 08             	sub    $0x8,%esp
	struct memory_node* cur = first_used;
20000e19:	8b 15 28 50 04 20    	mov    0x20045028,%edx
		cur = cur->next;
	}
	return NULL;
}

void free(void* ptr) {
20000e1f:	8b 4d 08             	mov    0x8(%ebp),%ecx
	struct memory_node* cur = first_used;
20000e22:	89 d0                	mov    %edx,%eax

	while (cur != NULL) {
20000e24:	e9 c0 00 00 00       	jmp    20000ee9 <free+0xd9>
		if (cur->address == (uint32_t) ptr) {
20000e29:	3b 48 04             	cmp    0x4(%eax),%ecx
20000e2c:	0f 85 b4 00 00 00    	jne    20000ee6 <free+0xd6>
			malloced -= cur->size;
20000e32:	8b 08                	mov    (%eax),%ecx
20000e34:	29 0d 30 50 04 20    	sub    %ecx,0x20045030
20000e3a:	31 c9                	xor    %ecx,%ecx
20000e3c:	eb 23                	jmp    20000e61 <free+0x51>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000e3e:	39 c2                	cmp    %eax,%edx
20000e40:	75 1a                	jne    20000e5c <free+0x4c>
			if (last == NULL) {
20000e42:	85 c9                	test   %ecx,%ecx
20000e44:	8b 50 08             	mov    0x8(%eax),%edx
20000e47:	75 0e                	jne    20000e57 <free+0x47>
				*root = cur->next;
20000e49:	89 15 28 50 04 20    	mov    %edx,0x20045028
20000e4f:	8b 0d 2c 50 04 20    	mov    0x2004502c,%ecx
20000e55:	eb 10                	jmp    20000e67 <free+0x57>
				return;
			} else {
				last->next = cur->next;
20000e57:	89 51 08             	mov    %edx,0x8(%ecx)
20000e5a:	eb f3                	jmp    20000e4f <free+0x3f>
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000e5c:	89 d1                	mov    %edx,%ecx
20000e5e:	8b 52 08             	mov    0x8(%edx),%edx

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000e61:	85 d2                	test   %edx,%edx
20000e63:	75 d9                	jne    20000e3e <free+0x2e>
20000e65:	eb e8                	jmp    20000e4f <free+0x3f>
20000e67:	89 ca                	mov    %ecx,%edx
20000e69:	eb 6d                	jmp    20000ed8 <free+0xc8>
	struct memory_node* cur;

	editedList: cur = first_free;

	while (cur != NULL) {
		if (cur->address + cur->size == tf->address) {
20000e6b:	8b 5a 04             	mov    0x4(%edx),%ebx
20000e6e:	8b 32                	mov    (%edx),%esi
20000e70:	8b 78 04             	mov    0x4(%eax),%edi
20000e73:	89 7d ec             	mov    %edi,-0x14(%ebp)
20000e76:	8d 3c 1e             	lea    (%esi,%ebx,1),%edi
20000e79:	89 7d f0             	mov    %edi,-0x10(%ebp)
20000e7c:	8b 7d ec             	mov    -0x14(%ebp),%edi
20000e7f:	39 7d f0             	cmp    %edi,-0x10(%ebp)
20000e82:	75 18                	jne    20000e9c <free+0x8c>
			tf->address = cur->address;
20000e84:	89 58 04             	mov    %ebx,0x4(%eax)
20000e87:	31 f6                	xor    %esi,%esi
20000e89:	89 cb                	mov    %ecx,%ebx
20000e8b:	eb 09                	jmp    20000e96 <free+0x86>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000e8d:	39 d3                	cmp    %edx,%ebx
20000e8f:	74 29                	je     20000eba <free+0xaa>
				last->next = cur->next;
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000e91:	89 de                	mov    %ebx,%esi
20000e93:	8b 5b 08             	mov    0x8(%ebx),%ebx

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000e96:	85 db                	test   %ebx,%ebx
20000e98:	75 f3                	jne    20000e8d <free+0x7d>
20000e9a:	eb cb                	jmp    20000e67 <free+0x57>
			tf->address = cur->address;
			remove_from_list(&first_free, cur);
			goto editedList;
		}

		if (cur->address == tf->address + tf->size) {
20000e9c:	8b 38                	mov    (%eax),%edi
20000e9e:	89 7d f0             	mov    %edi,-0x10(%ebp)
20000ea1:	8b 7d ec             	mov    -0x14(%ebp),%edi
20000ea4:	03 7d f0             	add    -0x10(%ebp),%edi
20000ea7:	39 fb                	cmp    %edi,%ebx
20000ea9:	75 2a                	jne    20000ed5 <free+0xc5>
			tf->size += cur->size;
20000eab:	03 75 f0             	add    -0x10(%ebp),%esi
20000eae:	89 cb                	mov    %ecx,%ebx
20000eb0:	89 30                	mov    %esi,(%eax)
20000eb2:	31 f6                	xor    %esi,%esi
20000eb4:	eb 19                	jmp    20000ecf <free+0xbf>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000eb6:	39 d3                	cmp    %edx,%ebx
20000eb8:	75 10                	jne    20000eca <free+0xba>
			if (last == NULL) {
20000eba:	85 f6                	test   %esi,%esi
20000ebc:	8b 53 08             	mov    0x8(%ebx),%edx
20000ebf:	75 04                	jne    20000ec5 <free+0xb5>
				*root = cur->next;
20000ec1:	89 d1                	mov    %edx,%ecx
20000ec3:	eb a2                	jmp    20000e67 <free+0x57>
				return;
			} else {
				last->next = cur->next;
20000ec5:	89 56 08             	mov    %edx,0x8(%esi)
20000ec8:	eb 9d                	jmp    20000e67 <free+0x57>
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000eca:	89 de                	mov    %ebx,%esi
20000ecc:	8b 5b 08             	mov    0x8(%ebx),%ebx

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000ecf:	85 db                	test   %ebx,%ebx
20000ed1:	75 e3                	jne    20000eb6 <free+0xa6>
20000ed3:	eb 92                	jmp    20000e67 <free+0x57>
			tf->size += cur->size;
			remove_from_list(&first_free, cur);
			goto editedList;
		}

		cur = cur->next;
20000ed5:	8b 52 08             	mov    0x8(%edx),%edx

	struct memory_node* cur;

	editedList: cur = first_free;

	while (cur != NULL) {
20000ed8:	85 d2                	test   %edx,%edx
20000eda:	75 8f                	jne    20000e6b <free+0x5b>
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000edc:	89 48 08             	mov    %ecx,0x8(%eax)
	*root = element;
20000edf:	a3 2c 50 04 20       	mov    %eax,0x2004502c
	while (cur != NULL) {
		if (cur->address == (uint32_t) ptr) {
			malloced -= cur->size;

			merge_into_frees(cur);
			break;
20000ee4:	eb 0b                	jmp    20000ef1 <free+0xe1>
		}
		cur = cur->next;
20000ee6:	8b 40 08             	mov    0x8(%eax),%eax
}

void free(void* ptr) {
	struct memory_node* cur = first_used;

	while (cur != NULL) {
20000ee9:	85 c0                	test   %eax,%eax
20000eeb:	0f 85 38 ff ff ff    	jne    20000e29 <free+0x19>
			merge_into_frees(cur);
			break;
		}
		cur = cur->next;
	}
}
20000ef1:	58                   	pop    %eax
20000ef2:	5a                   	pop    %edx
20000ef3:	5b                   	pop    %ebx
20000ef4:	5e                   	pop    %esi
20000ef5:	5f                   	pop    %edi
20000ef6:	5d                   	pop    %ebp
20000ef7:	c3                   	ret    

20000ef8 <pop_unused_node>:
	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
		append_to_list(&first_unused, &(new_nodes[i]));
	}
}

static struct memory_node* pop_unused_node() {
20000ef8:	55                   	push   %ebp
20000ef9:	89 e5                	mov    %esp,%ebp
20000efb:	53                   	push   %ebx
20000efc:	83 ec 04             	sub    $0x4,%esp
	element->next = *root;
	*root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
	if (*root == NULL) return NULL;
20000eff:	a1 24 50 04 20       	mov    0x20045024,%eax
20000f04:	eb 45                	jmp    20000f4b <pop_unused_node+0x53>
	remove_from_list(root, pop);
	return pop;
}

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
20000f06:	83 ec 0c             	sub    $0xc,%esp
20000f09:	6a 01                	push   $0x1
20000f0b:	e8 9a fe ff ff       	call   20000daa <pcalloc>
	memset(new_nodes, 0, PAGESIZE);
20000f10:	83 c4 0c             	add    $0xc,%esp
	remove_from_list(root, pop);
	return pop;
}

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
20000f13:	89 c3                	mov    %eax,%ebx
	memset(new_nodes, 0, PAGESIZE);
20000f15:	68 00 10 00 00       	push   $0x1000
20000f1a:	6a 00                	push   $0x0
20000f1c:	50                   	push   %eax
20000f1d:	e8 c2 fd ff ff       	call   20000ce4 <memset>
20000f22:	8b 15 24 50 04 20    	mov    0x20045024,%edx
20000f28:	8d 43 0c             	lea    0xc(%ebx),%eax
	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
		append_to_list(&first_unused, &(new_nodes[i]));
	}
}

static struct memory_node* pop_unused_node() {
20000f2b:	8d 8b fc 0f 00 00    	lea    0xffc(%ebx),%ecx
20000f31:	83 c4 10             	add    $0x10,%esp
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000f34:	89 50 08             	mov    %edx,0x8(%eax)
20000f37:	89 c2                	mov    %eax,%edx
20000f39:	83 c0 0c             	add    $0xc,%eax

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
	memset(new_nodes, 0, PAGESIZE);

	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
20000f3c:	39 c8                	cmp    %ecx,%eax
20000f3e:	75 f4                	jne    20000f34 <pop_unused_node+0x3c>
20000f40:	8d 83 f0 0f 00 00    	lea    0xff0(%ebx),%eax
20000f46:	a3 24 50 04 20       	mov    %eax,0x20045024
	element->next = *root;
	*root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
	if (*root == NULL) return NULL;
20000f4b:	85 c0                	test   %eax,%eax
20000f4d:	74 b7                	je     20000f06 <pop_unused_node+0xe>
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
			if (last == NULL) {
				*root = cur->next;
20000f4f:	8b 50 08             	mov    0x8(%eax),%edx
}

static struct memory_node* pop_unused_node() {
	struct memory_node* ret = pop_from_list(&first_unused);

	while (ret == NULL) {
20000f52:	85 c0                	test   %eax,%eax
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
			if (last == NULL) {
				*root = cur->next;
20000f54:	89 15 24 50 04 20    	mov    %edx,0x20045024
}

static struct memory_node* pop_unused_node() {
	struct memory_node* ret = pop_from_list(&first_unused);

	while (ret == NULL) {
20000f5a:	74 aa                	je     20000f06 <pop_unused_node+0xe>
		allocate_unused_nodes();
		ret = pop_from_list(&first_unused);
	}

	return ret;
}
20000f5c:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000f5f:	c9                   	leave  
20000f60:	c3                   	ret    

20000f61 <malloc>:
	append_to_list(&first_free, tf);
}

uint32_t malloced = 0;

void* malloc(size_t size) {
20000f61:	55                   	push   %ebp
	if (size == 0)
20000f62:	31 c0                	xor    %eax,%eax
	append_to_list(&first_free, tf);
}

uint32_t malloced = 0;

void* malloc(size_t size) {
20000f64:	89 e5                	mov    %esp,%ebp
20000f66:	57                   	push   %edi
20000f67:	56                   	push   %esi
20000f68:	53                   	push   %ebx
20000f69:	83 ec 1c             	sub    $0x1c,%esp
20000f6c:	8b 75 08             	mov    0x8(%ebp),%esi
	if (size == 0)
20000f6f:	85 f6                	test   %esi,%esi
20000f71:	0f 84 aa 00 00 00    	je     20001021 <malloc+0xc0>
		return NULL;

	malloced += size;

	struct memory_node* cur = first_free;
20000f77:	a1 2c 50 04 20       	mov    0x2004502c,%eax

void* malloc(size_t size) {
	if (size == 0)
		return NULL;

	malloced += size;
20000f7c:	01 35 30 50 04 20    	add    %esi,0x20045030

	struct memory_node* cur = first_free;
20000f82:	89 c3                	mov    %eax,%ebx

	while (cur != NULL) {
20000f84:	eb 07                	jmp    20000f8d <malloc+0x2c>
		if (cur->size >= size) {
20000f86:	39 33                	cmp    %esi,(%ebx)
20000f88:	73 0c                	jae    20000f96 <malloc+0x35>
			break;
		}
		cur = cur->next;
20000f8a:	8b 5b 08             	mov    0x8(%ebx),%ebx

	malloced += size;

	struct memory_node* cur = first_free;

	while (cur != NULL) {
20000f8d:	85 db                	test   %ebx,%ebx
20000f8f:	75 f5                	jne    20000f86 <malloc+0x25>
20000f91:	e9 93 00 00 00       	jmp    20001029 <malloc+0xc8>

		append_to_list(&first_used, fill);

		return (void*) fill->address;
	} else {
		uint32_t freesize = cur->size - size;
20000f96:	8b 3b                	mov    (%ebx),%edi

		cur->size = size;
20000f98:	31 d2                	xor    %edx,%edx

		append_to_list(&first_used, fill);

		return (void*) fill->address;
	} else {
		uint32_t freesize = cur->size - size;
20000f9a:	29 f7                	sub    %esi,%edi

		cur->size = size;
20000f9c:	89 33                	mov    %esi,(%ebx)
20000f9e:	eb 4b                	jmp    20000feb <malloc+0x8a>

		fill->address = (uint32_t) addr;
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();
20000fa0:	e8 53 ff ff ff       	call   20000ef8 <pop_unused_node>

			free->address = fill->address + fill->size;
20000fa5:	8b 13                	mov    (%ebx),%edx
20000fa7:	03 53 04             	add    0x4(%ebx),%edx
			free->size = pgs * PAGESIZE - size;
20000faa:	29 f7                	sub    %esi,%edi
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();

			free->address = fill->address + fill->size;
20000fac:	89 50 04             	mov    %edx,0x4(%eax)
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000faf:	8b 15 2c 50 04 20    	mov    0x2004502c,%edx
20000fb5:	89 50 08             	mov    %edx,0x8(%eax)

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();

			free->address = fill->address + fill->size;
			free->size = pgs * PAGESIZE - size;
20000fb8:	89 38                	mov    %edi,(%eax)
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
	*root = element;
20000fba:	a3 2c 50 04 20       	mov    %eax,0x2004502c
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000fbf:	a1 28 50 04 20       	mov    0x20045028,%eax
20000fc4:	89 43 08             	mov    %eax,0x8(%ebx)
	*root = element;
20000fc7:	89 1d 28 50 04 20    	mov    %ebx,0x20045028
20000fcd:	eb 4f                	jmp    2000101e <malloc+0xbd>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000fcf:	39 d8                	cmp    %ebx,%eax
20000fd1:	75 13                	jne    20000fe6 <malloc+0x85>
			if (last == NULL) {
20000fd3:	85 d2                	test   %edx,%edx
20000fd5:	8b 43 08             	mov    0x8(%ebx),%eax
20000fd8:	75 07                	jne    20000fe1 <malloc+0x80>
				*root = cur->next;
20000fda:	a3 2c 50 04 20       	mov    %eax,0x2004502c
20000fdf:	eb 0e                	jmp    20000fef <malloc+0x8e>
				return;
			} else {
				last->next = cur->next;
20000fe1:	89 42 08             	mov    %eax,0x8(%edx)
20000fe4:	eb 09                	jmp    20000fef <malloc+0x8e>
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000fe6:	89 c2                	mov    %eax,%edx
20000fe8:	8b 40 08             	mov    0x8(%eax),%eax

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000feb:	85 c0                	test   %eax,%eax
20000fed:	75 e0                	jne    20000fcf <malloc+0x6e>
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000fef:	a1 28 50 04 20       	mov    0x20045028,%eax
		cur->size = size;

		remove_from_list(&first_free, cur);
		append_to_list(&first_used, cur);

		if (freesize > 0) {
20000ff4:	85 ff                	test   %edi,%edi
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000ff6:	89 43 08             	mov    %eax,0x8(%ebx)
	*root = element;
20000ff9:	89 1d 28 50 04 20    	mov    %ebx,0x20045028
		cur->size = size;

		remove_from_list(&first_free, cur);
		append_to_list(&first_used, cur);

		if (freesize > 0) {
20000fff:	74 1d                	je     2000101e <malloc+0xbd>
			struct memory_node* free = pop_unused_node();
20001001:	e8 f2 fe ff ff       	call   20000ef8 <pop_unused_node>

			free->address = cur->address + cur->size;
20001006:	8b 13                	mov    (%ebx),%edx
20001008:	03 53 04             	add    0x4(%ebx),%edx
2000100b:	89 50 04             	mov    %edx,0x4(%eax)
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
2000100e:	8b 15 2c 50 04 20    	mov    0x2004502c,%edx
20001014:	89 50 08             	mov    %edx,0x8(%eax)

		if (freesize > 0) {
			struct memory_node* free = pop_unused_node();

			free->address = cur->address + cur->size;
			free->size = freesize;
20001017:	89 38                	mov    %edi,(%eax)
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
	*root = element;
20001019:	a3 2c 50 04 20       	mov    %eax,0x2004502c
			free->size = freesize;

			append_to_list(&first_free, free);
		}

		return (void*) cur->address;
2000101e:	8b 43 04             	mov    0x4(%ebx),%eax
	}
}
20001021:	8d 65 f4             	lea    -0xc(%ebp),%esp
20001024:	5b                   	pop    %ebx
20001025:	5e                   	pop    %esi
20001026:	5f                   	pop    %edi
20001027:	5d                   	pop    %ebp
20001028:	c3                   	ret    
	}

	if (cur == NULL) {
		uint32_t pgs = size / PAGESIZE;

		if ((size % PAGESIZE) != 0)
20001029:	89 f0                	mov    %esi,%eax
		}
		cur = cur->next;
	}

	if (cur == NULL) {
		uint32_t pgs = size / PAGESIZE;
2000102b:	89 f7                	mov    %esi,%edi
2000102d:	c1 ef 0c             	shr    $0xc,%edi

		if ((size % PAGESIZE) != 0)
20001030:	25 ff 0f 00 00       	and    $0xfff,%eax
			pgs++;
20001035:	83 f8 01             	cmp    $0x1,%eax
20001038:	83 df ff             	sbb    $0xffffffff,%edi

		void* addr = pcalloc(pgs);
2000103b:	83 ec 0c             	sub    $0xc,%esp
2000103e:	57                   	push   %edi
2000103f:	e8 66 fd ff ff       	call   20000daa <pcalloc>
		struct memory_node* fill = pop_unused_node();

		fill->address = (uint32_t) addr;
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
20001044:	c1 e7 0c             	shl    $0xc,%edi
		if ((size % PAGESIZE) != 0)
			pgs++;

		void* addr = pcalloc(pgs);

		struct memory_node* fill = pop_unused_node();
20001047:	89 45 e4             	mov    %eax,-0x1c(%ebp)
2000104a:	e8 a9 fe ff ff       	call   20000ef8 <pop_unused_node>

		fill->address = (uint32_t) addr;
2000104f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
20001052:	83 c4 10             	add    $0x10,%esp
		if ((size % PAGESIZE) != 0)
			pgs++;

		void* addr = pcalloc(pgs);

		struct memory_node* fill = pop_unused_node();
20001055:	89 c3                	mov    %eax,%ebx

		fill->address = (uint32_t) addr;
20001057:	89 50 04             	mov    %edx,0x4(%eax)
		fill->size = (uint32_t) size;
2000105a:	89 30                	mov    %esi,(%eax)

		if (pgs * PAGESIZE > size) {
2000105c:	39 f7                	cmp    %esi,%edi
2000105e:	0f 86 5b ff ff ff    	jbe    20000fbf <malloc+0x5e>
20001064:	e9 37 ff ff ff       	jmp    20000fa0 <malloc+0x3f>

20001069 <realloc>:
	}

	return p;
}

void* realloc(void* ptr, size_t size) {
20001069:	55                   	push   %ebp
2000106a:	89 e5                	mov    %esp,%ebp
2000106c:	56                   	push   %esi
2000106d:	53                   	push   %ebx
	struct memory_node* cur = first_used;
2000106e:	8b 1d 28 50 04 20    	mov    0x20045028,%ebx
	}

	return p;
}

void* realloc(void* ptr, size_t size) {
20001074:	8b 55 08             	mov    0x8(%ebp),%edx
20001077:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct memory_node* cur = first_used;

	while (cur != NULL) {
2000107a:	eb 3e                	jmp    200010ba <realloc+0x51>
		if (cur->address == (uint32_t) ptr) {
2000107c:	3b 53 04             	cmp    0x4(%ebx),%edx
2000107f:	75 36                	jne    200010b7 <realloc+0x4e>
			if (size == 0) {
20001081:	85 c0                	test   %eax,%eax
20001083:	75 0b                	jne    20001090 <realloc+0x27>
				free(ptr);
20001085:	52                   	push   %edx
20001086:	31 f6                	xor    %esi,%esi
20001088:	e8 83 fd ff ff       	call   20000e10 <free>
				return NULL;
2000108d:	5b                   	pop    %ebx
2000108e:	eb 30                	jmp    200010c0 <realloc+0x57>
			} else {
				void* new = malloc(size);
20001090:	83 ec 0c             	sub    $0xc,%esp
20001093:	50                   	push   %eax
20001094:	e8 c8 fe ff ff       	call   20000f61 <malloc>
				memcpy(new, (void*) cur->address, cur->size);
20001099:	83 c4 0c             	add    $0xc,%esp
		if (cur->address == (uint32_t) ptr) {
			if (size == 0) {
				free(ptr);
				return NULL;
			} else {
				void* new = malloc(size);
2000109c:	89 c6                	mov    %eax,%esi
				memcpy(new, (void*) cur->address, cur->size);
2000109e:	ff 33                	pushl  (%ebx)
200010a0:	ff 73 04             	pushl  0x4(%ebx)
200010a3:	50                   	push   %eax
200010a4:	e8 57 fc ff ff       	call   20000d00 <memcpy>
				free((void*) cur->address);
200010a9:	59                   	pop    %ecx
200010aa:	ff 73 04             	pushl  0x4(%ebx)
200010ad:	e8 5e fd ff ff       	call   20000e10 <free>

				return new;
200010b2:	83 c4 10             	add    $0x10,%esp
200010b5:	eb 09                	jmp    200010c0 <realloc+0x57>
			}
		}
		cur = cur->next;
200010b7:	8b 5b 08             	mov    0x8(%ebx),%ebx
}

void* realloc(void* ptr, size_t size) {
	struct memory_node* cur = first_used;

	while (cur != NULL) {
200010ba:	85 db                	test   %ebx,%ebx
200010bc:	75 be                	jne    2000107c <realloc+0x13>
200010be:	31 f6                	xor    %esi,%esi
			}
		}
		cur = cur->next;
	}
	return NULL;
}
200010c0:	8d 65 f8             	lea    -0x8(%ebp),%esp
200010c3:	89 f0                	mov    %esi,%eax
200010c5:	5b                   	pop    %ebx
200010c6:	5e                   	pop    %esi
200010c7:	5d                   	pop    %ebp
200010c8:	c3                   	ret    

200010c9 <calloc>:

		return (void*) cur->address;
	}
}

void* calloc(size_t num, size_t size) {
200010c9:	55                   	push   %ebp
200010ca:	89 e5                	mov    %esp,%ebp
200010cc:	56                   	push   %esi
200010cd:	53                   	push   %ebx
200010ce:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size_t gsize = num * size;
	void* p = malloc(gsize);
200010d1:	83 ec 0c             	sub    $0xc,%esp
		return (void*) cur->address;
	}
}

void* calloc(size_t num, size_t size) {
	size_t gsize = num * size;
200010d4:	0f af 5d 08          	imul   0x8(%ebp),%ebx
	void* p = malloc(gsize);
200010d8:	53                   	push   %ebx
200010d9:	e8 83 fe ff ff       	call   20000f61 <malloc>

	if (p != NULL) {
200010de:	83 c4 10             	add    $0x10,%esp
	}
}

void* calloc(size_t num, size_t size) {
	size_t gsize = num * size;
	void* p = malloc(gsize);
200010e1:	89 c6                	mov    %eax,%esi

	if (p != NULL) {
200010e3:	85 c0                	test   %eax,%eax
200010e5:	74 0d                	je     200010f4 <calloc+0x2b>
		memset(p, 0, gsize);
200010e7:	50                   	push   %eax
200010e8:	53                   	push   %ebx
200010e9:	6a 00                	push   $0x0
200010eb:	56                   	push   %esi
200010ec:	e8 f3 fb ff ff       	call   20000ce4 <memset>
200010f1:	83 c4 10             	add    $0x10,%esp
	}

	return p;
}
200010f4:	8d 65 f8             	lea    -0x8(%ebp),%esp
200010f7:	89 f0                	mov    %esi,%eax
200010f9:	5b                   	pop    %ebx
200010fa:	5e                   	pop    %esi
200010fb:	5d                   	pop    %ebp
200010fc:	c3                   	ret    
200010fd:	00 00                	add    %al,(%eax)
	...

20001100 <strlen>:
    l1 = l1 < l2 ? l1 : l2;

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
20001100:	55                   	push   %ebp
    if (str == 0)
20001101:	31 d2                	xor    %edx,%edx
    l1 = l1 < l2 ? l1 : l2;

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
20001103:	89 e5                	mov    %esp,%ebp
    if (str == 0)
20001105:	31 c0                	xor    %eax,%eax
    l1 = l1 < l2 ? l1 : l2;

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
20001107:	8b 4d 08             	mov    0x8(%ebp),%ecx
    if (str == 0)
2000110a:	85 c9                	test   %ecx,%ecx
2000110c:	75 03                	jne    20001111 <strlen+0x11>
2000110e:	eb 09                	jmp    20001119 <strlen+0x19>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
20001110:	42                   	inc    %edx
20001111:	89 d0                	mov    %edx,%eax
20001113:	80 3c 11 00          	cmpb   $0x0,(%ecx,%edx,1)
20001117:	75 f7                	jne    20001110 <strlen+0x10>
        ;
    return i;
}
20001119:	5d                   	pop    %ebp
2000111a:	c3                   	ret    

2000111b <strtoknc>:
        return strtoknc(fr, delimiters);
    }
    return strtoknc(0, delimiters);
}

char* strtoknc(char* str, const char* delimiters) {
2000111b:	55                   	push   %ebp

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
2000111c:	31 c0                	xor    %eax,%eax
        return strtoknc(fr, delimiters);
    }
    return strtoknc(0, delimiters);
}

char* strtoknc(char* str, const char* delimiters) {
2000111e:	89 e5                	mov    %esp,%ebp
20001120:	57                   	push   %edi
20001121:	56                   	push   %esi
20001122:	53                   	push   %ebx
20001123:	83 ec 04             	sub    $0x4,%esp
20001126:	8b 5d 0c             	mov    0xc(%ebp),%ebx
20001129:	8b 4d 08             	mov    0x8(%ebp),%ecx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
2000112c:	85 db                	test   %ebx,%ebx
2000112e:	75 06                	jne    20001136 <strtoknc+0x1b>
20001130:	e9 83 00 00 00       	jmp    200011b8 <strtoknc+0x9d>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
20001135:	40                   	inc    %eax
20001136:	89 c7                	mov    %eax,%edi
20001138:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
2000113c:	75 f7                	jne    20001135 <strtoknc+0x1a>
char* strtoknc(char* str, const char* delimiters) {
    int i = 0;
    int len = strlen(delimiters);

    /* check in the delimiters */
    if (len == 0)
2000113e:	85 c0                	test   %eax,%eax
20001140:	74 76                	je     200011b8 <strtoknc+0x9d>
        return 0;

    /* if the original string has nothing left */
    if (!str && !sp)
20001142:	85 c9                	test   %ecx,%ecx
20001144:	75 0b                	jne    20001151 <strtoknc+0x36>
20001146:	83 3d 34 50 04 20 00 	cmpl   $0x0,0x20045034
2000114d:	75 08                	jne    20001157 <strtoknc+0x3c>
2000114f:	eb 67                	jmp    200011b8 <strtoknc+0x9d>
        return 0;

    /* initialize the sp during the first call */
    if (str) {
        sp = str;
20001151:	89 0d 34 50 04 20    	mov    %ecx,0x20045034
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
20001157:	a1 34 50 04 20       	mov    0x20045034,%eax
2000115c:	31 c9                	xor    %ecx,%ecx
    while (1) {
        for (i = 0; i < len; i++) {
2000115e:	eb 0b                	jmp    2000116b <strtoknc+0x50>
            if (*p_start == delimiters[i]) {
20001160:	8a 10                	mov    (%eax),%dl
20001162:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
20001165:	75 03                	jne    2000116a <strtoknc+0x4f>
                p_start++;
20001167:	40                   	inc    %eax
                break;
20001168:	eb 05                	jmp    2000116f <strtoknc+0x54>
    }

    /* find the start of the substring, skip delimiters */
    char* p_start = sp;
    while (1) {
        for (i = 0; i < len; i++) {
2000116a:	41                   	inc    %ecx
2000116b:	39 f9                	cmp    %edi,%ecx
2000116d:	7c f1                	jl     20001160 <strtoknc+0x45>
                p_start++;
                break;
            }
        }

        if (i == len) {
2000116f:	39 f9                	cmp    %edi,%ecx
20001171:	75 e9                	jne    2000115c <strtoknc+0x41>
            sp = p_start;
20001173:	a3 34 50 04 20       	mov    %eax,0x20045034
            break;
        }
    }

    /* return NULL if nothing left */
    if (*sp == '\0') {
20001178:	80 38 00             	cmpb   $0x0,(%eax)
2000117b:	75 28                	jne    200011a5 <strtoknc+0x8a>
        sp = NULL;
2000117d:	c7 05 34 50 04 20 00 	movl   $0x0,0x20045034
20001184:	00 00 00 
20001187:	eb 2f                	jmp    200011b8 <strtoknc+0x9d>
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
            if (*sp == delimiters[i]) {
20001189:	8a 55 f3             	mov    -0xd(%ebp),%dl
2000118c:	3a 14 0b             	cmp    (%ebx,%ecx,1),%dl
2000118f:	75 05                	jne    20001196 <strtoknc+0x7b>
                *sp = '\0';
20001191:	c6 06 00             	movb   $0x0,(%esi)
                break;
20001194:	eb 05                	jmp    2000119b <strtoknc+0x80>
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
        for (i = 0; i < len; i++) {
20001196:	41                   	inc    %ecx
20001197:	39 f9                	cmp    %edi,%ecx
20001199:	7c ee                	jl     20001189 <strtoknc+0x6e>
                *sp = '\0';
                break;
            }
        }

        sp++;
2000119b:	ff 05 34 50 04 20    	incl   0x20045034
        if (i < len)
200011a1:	39 f9                	cmp    %edi,%ecx
200011a3:	7c 15                	jl     200011ba <strtoknc+0x9f>
        sp = NULL;
        return sp;
    }

    /* find the end of the substring, and replace the delimiter with null*/
    while (*sp != '\0') {
200011a5:	8b 35 34 50 04 20    	mov    0x20045034,%esi
200011ab:	8a 16                	mov    (%esi),%dl
200011ad:	88 55 f3             	mov    %dl,-0xd(%ebp)
200011b0:	84 d2                	test   %dl,%dl
200011b2:	74 06                	je     200011ba <strtoknc+0x9f>
200011b4:	31 c9                	xor    %ecx,%ecx
200011b6:	eb df                	jmp    20001197 <strtoknc+0x7c>
200011b8:	31 c0                	xor    %eax,%eax
        if (i < len)
            break;
    }

    return p_start;
}
200011ba:	5a                   	pop    %edx
200011bb:	5b                   	pop    %ebx
200011bc:	5e                   	pop    %esi
200011bd:	5f                   	pop    %edi
200011be:	5d                   	pop    %ebp
200011bf:	c3                   	ret    

200011c0 <strcpy>:
    for (i = 0; str[i] != '\0'; i++)
        ;
    return i;
}

char* strcpy(char* dest, const char* src) {
200011c0:	55                   	push   %ebp

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011c1:	31 c0                	xor    %eax,%eax
    for (i = 0; str[i] != '\0'; i++)
        ;
    return i;
}

char* strcpy(char* dest, const char* src) {
200011c3:	89 e5                	mov    %esp,%ebp
200011c5:	53                   	push   %ebx
200011c6:	83 ec 04             	sub    $0x4,%esp

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011c9:	31 c9                	xor    %ecx,%ecx
    for (i = 0; str[i] != '\0'; i++)
        ;
    return i;
}

char* strcpy(char* dest, const char* src) {
200011cb:	8b 55 0c             	mov    0xc(%ebp),%edx
200011ce:	8b 5d 08             	mov    0x8(%ebp),%ebx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011d1:	85 d2                	test   %edx,%edx
200011d3:	75 03                	jne    200011d8 <strcpy+0x18>
200011d5:	eb 09                	jmp    200011e0 <strcpy+0x20>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
200011d7:	40                   	inc    %eax
200011d8:	89 c1                	mov    %eax,%ecx
200011da:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
200011de:	75 f7                	jne    200011d7 <strcpy+0x17>
        ;
    return i;
}

char* strcpy(char* dest, const char* src) {
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
200011e0:	41                   	inc    %ecx
200011e1:	50                   	push   %eax
200011e2:	51                   	push   %ecx
200011e3:	52                   	push   %edx
200011e4:	53                   	push   %ebx
200011e5:	e8 16 fb ff ff       	call   20000d00 <memcpy>
    return dest;
}
200011ea:	89 d8                	mov    %ebx,%eax
200011ec:	8b 5d fc             	mov    -0x4(%ebp),%ebx
200011ef:	c9                   	leave  
200011f0:	c3                   	ret    

200011f1 <strclone>:

char* strclone(const char* str) {
200011f1:	55                   	push   %ebp

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011f2:	31 c0                	xor    %eax,%eax
char* strcpy(char* dest, const char* src) {
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
    return dest;
}

char* strclone(const char* str) {
200011f4:	89 e5                	mov    %esp,%ebp
200011f6:	56                   	push   %esi
200011f7:	53                   	push   %ebx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011f8:	31 d2                	xor    %edx,%edx
char* strcpy(char* dest, const char* src) {
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
    return dest;
}

char* strclone(const char* str) {
200011fa:	8b 5d 08             	mov    0x8(%ebp),%ebx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
200011fd:	85 db                	test   %ebx,%ebx
200011ff:	75 03                	jne    20001204 <strclone+0x13>
20001201:	eb 09                	jmp    2000120c <strclone+0x1b>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
20001203:	40                   	inc    %eax
20001204:	89 c2                	mov    %eax,%edx
20001206:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
2000120a:	75 f7                	jne    20001203 <strclone+0x12>
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
    return dest;
}

char* strclone(const char* str) {
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
2000120c:	83 ec 0c             	sub    $0xc,%esp
2000120f:	42                   	inc    %edx
20001210:	52                   	push   %edx
20001211:	e8 4b fd ff ff       	call   20000f61 <malloc>
    strcpy(ret, str);
20001216:	5a                   	pop    %edx
20001217:	59                   	pop    %ecx
20001218:	53                   	push   %ebx
    memcpy(dest, src, strlen(src) * sizeof(char) + 1);
    return dest;
}

char* strclone(const char* str) {
    char* ret = malloc(sizeof(char) * strlen(str) + 1);
20001219:	89 c6                	mov    %eax,%esi
    strcpy(ret, str);
2000121b:	50                   	push   %eax
2000121c:	e8 9f ff ff ff       	call   200011c0 <strcpy>

    return ret;
}
20001221:	8d 65 f8             	lea    -0x8(%ebp),%esp
20001224:	89 f0                	mov    %esi,%eax
20001226:	5b                   	pop    %ebx
20001227:	5e                   	pop    %esi
20001228:	5d                   	pop    %ebp
20001229:	c3                   	ret    

2000122a <strtok>:

char* sp = NULL; /* the start position of the string */
void* fr = NULL;

char* strtok(char* str, const char* delimiters) {
2000122a:	55                   	push   %ebp
2000122b:	89 e5                	mov    %esp,%ebp
2000122d:	56                   	push   %esi
2000122e:	53                   	push   %ebx
2000122f:	8b 75 08             	mov    0x8(%ebp),%esi
20001232:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    if(str != 0) { //TODO better but if you call strtok and after that strtoknc will still be a memory leak. -> Don't use strtoknc
20001235:	85 f6                	test   %esi,%esi
20001237:	74 2e                	je     20001267 <strtok+0x3d>
        if(fr != 0) {
20001239:	a1 38 50 04 20       	mov    0x20045038,%eax
2000123e:	85 c0                	test   %eax,%eax
20001240:	74 0c                	je     2000124e <strtok+0x24>
            free(fr);
20001242:	83 ec 0c             	sub    $0xc,%esp
20001245:	50                   	push   %eax
20001246:	e8 c5 fb ff ff       	call   20000e10 <free>
2000124b:	83 c4 10             	add    $0x10,%esp
        }
        fr = strclone(str);
2000124e:	83 ec 0c             	sub    $0xc,%esp
20001251:	56                   	push   %esi
20001252:	e8 9a ff ff ff       	call   200011f1 <strclone>
        return strtoknc(fr, delimiters);
20001257:	83 c4 10             	add    $0x10,%esp
char* strtok(char* str, const char* delimiters) {
    if(str != 0) { //TODO better but if you call strtok and after that strtoknc will still be a memory leak. -> Don't use strtoknc
        if(fr != 0) {
            free(fr);
        }
        fr = strclone(str);
2000125a:	a3 38 50 04 20       	mov    %eax,0x20045038
        return strtoknc(fr, delimiters);
2000125f:	89 5d 0c             	mov    %ebx,0xc(%ebp)
20001262:	89 45 08             	mov    %eax,0x8(%ebp)
20001265:	eb 0a                	jmp    20001271 <strtok+0x47>
    }
    return strtoknc(0, delimiters);
20001267:	89 5d 0c             	mov    %ebx,0xc(%ebp)
2000126a:	c7 45 08 00 00 00 00 	movl   $0x0,0x8(%ebp)
}
20001271:	8d 65 f8             	lea    -0x8(%ebp),%esp
20001274:	5b                   	pop    %ebx
20001275:	5e                   	pop    %esi
20001276:	5d                   	pop    %ebp
            free(fr);
        }
        fr = strclone(str);
        return strtoknc(fr, delimiters);
    }
    return strtoknc(0, delimiters);
20001277:	e9 9f fe ff ff       	jmp    2000111b <strtoknc>

2000127c <strcmp>:
#include "string.h"
#include "stdlib.h"

int strcmp(const char* str1, const char* str2) {
2000127c:	55                   	push   %ebp

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
2000127d:	31 c0                	xor    %eax,%eax
#include "string.h"
#include "stdlib.h"

int strcmp(const char* str1, const char* str2) {
2000127f:	89 e5                	mov    %esp,%ebp
20001281:	56                   	push   %esi
20001282:	53                   	push   %ebx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
20001283:	31 db                	xor    %ebx,%ebx
#include "string.h"
#include "stdlib.h"

int strcmp(const char* str1, const char* str2) {
20001285:	8b 55 08             	mov    0x8(%ebp),%edx
20001288:	8b 4d 0c             	mov    0xc(%ebp),%ecx

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
2000128b:	85 d2                	test   %edx,%edx
2000128d:	75 03                	jne    20001292 <strcmp+0x16>
2000128f:	eb 09                	jmp    2000129a <strcmp+0x1e>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
20001291:	40                   	inc    %eax
20001292:	89 c3                	mov    %eax,%ebx
20001294:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
20001298:	75 f7                	jne    20001291 <strcmp+0x15>

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
}

unsigned int strlen(const char* str) {
    if (str == 0)
2000129a:	31 c0                	xor    %eax,%eax
2000129c:	31 f6                	xor    %esi,%esi
2000129e:	85 c9                	test   %ecx,%ecx
200012a0:	75 03                	jne    200012a5 <strcmp+0x29>
200012a2:	eb 09                	jmp    200012ad <strcmp+0x31>
        return 0;
    int i;
    for (i = 0; str[i] != '\0'; i++)
200012a4:	40                   	inc    %eax
200012a5:	89 c6                	mov    %eax,%esi
200012a7:	80 3c 01 00          	cmpb   $0x0,(%ecx,%eax,1)
200012ab:	75 f7                	jne    200012a4 <strcmp+0x28>
int strcmp(const char* str1, const char* str2) {
    int l1 = strlen(str1);
    int l2 = strlen(str2);
    l1 = l1 < l2 ? l1 : l2;

    return memcmp(str1, str2, (l1 + 1) * sizeof(char));
200012ad:	39 de                	cmp    %ebx,%esi
200012af:	50                   	push   %eax
200012b0:	89 f0                	mov    %esi,%eax
200012b2:	7e 02                	jle    200012b6 <strcmp+0x3a>
200012b4:	89 d8                	mov    %ebx,%eax
200012b6:	40                   	inc    %eax
200012b7:	50                   	push   %eax
200012b8:	51                   	push   %ecx
200012b9:	52                   	push   %edx
200012ba:	e8 67 fa ff ff       	call   20000d26 <memcmp>
}
200012bf:	8d 65 f8             	lea    -0x8(%ebp),%esp
200012c2:	5b                   	pop    %ebx
200012c3:	5e                   	pop    %esi
200012c4:	5d                   	pop    %ebp
200012c5:	c3                   	ret    
