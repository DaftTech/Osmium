
../../initrfs/init:     file format elf32-i386
../../initrfs/init
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x20000147

Program Header:
    LOAD off    0x00001000 vaddr 0x20000000 paddr 0x20000000 align 2**12
         filesz 0x000004a9 memsz 0x000004a9 flags r-x
    LOAD off    0x00002000 vaddr 0x20001000 paddr 0x20001000 align 2**12
         filesz 0x00001069 memsz 0x00003004 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000004a9  20000000  20000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000001  20001000  20001000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000044  20002000  20002000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 00000025  20002044  20002044  00003044  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00001004  20003000  20003000  00003069  2**2
                  ALLOC
  5 .stab         000018a8  00000000  00000000  0000306c  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      0000006c  00000000  00000000  00004914  2**0
                  CONTENTS, READONLY
  7 .stabstr      00000cfb  00000000  00000000  00004980  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
20000000 l    d  .text	00000000 .text
20001000 l    d  .data	00000000 .data
20002000 l    d  .rodata	00000000 .rodata
20002044 l    d  .rodata.str1.1	00000000 .rodata.str1.1
20003000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 process.c
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    df *ABS*	00000000 console.c
20001000 l     O .data	00000001 color
20003000 l     O .bss	00000004 kprintf_res
00000000 l    df *ABS*	00000000 rpc.c
20003004 l     O .bss	00001000 rpcHandlers
2000202c l     O .rodata	00000018 C.2.863
00000000 l    df *ABS*	00000000 driver.c
20000470 g     F .text	00000039 register_driver
200001cd g     F .text	0000003e kputc
20000170 g     F .text	00000050 syscall
200003aa g     F .text	00000042 rpc_init
200001c0 g     F .text	0000000d setclr
2000000f g     F .text	00000005 dRead
20000364 g     F .text	00000046 rpc_map
2000033c g     F .text	00000028 rpc_register_handler
200000cc g     F .text	0000003e getargsptr
20000005 g     F .text	00000005 dClose
20000147 g     F .text	00000026 _start
20000019 g     F .text	000000b1 main
20000429 g     F .text	00000044 rpc_handler
20000232 g     F .text	0000003b kputn
2000020b g     F .text	00000027 kputs
2000000a g     F .text	00000005 dRemove
200003ec g     F .text	0000003d rpc_return
2000026d g     F .text	000000ce kprintf
20000000 g     F .text	00000005 dOpen
2000010a g     F .text	0000003d exit
20000014 g     F .text	00000005 dWrite



Disassembly of section .text:

20000000 <dOpen>:
#include "process.h"
#include "console.h"

int dOpen(void* data) {
20000000:	55                   	push   %ebp
20000001:	89 e5                	mov    %esp,%ebp

}
20000003:	5d                   	pop    %ebp
20000004:	c3                   	ret    

20000005 <dClose>:

int dClose(void* data) {
20000005:	55                   	push   %ebp
20000006:	89 e5                	mov    %esp,%ebp

}
20000008:	5d                   	pop    %ebp
20000009:	c3                   	ret    

2000000a <dRemove>:

int dRemove(void* data) {
2000000a:	55                   	push   %ebp
2000000b:	89 e5                	mov    %esp,%ebp

}
2000000d:	5d                   	pop    %ebp
2000000e:	c3                   	ret    

2000000f <dRead>:

int dRead(void* data) {
2000000f:	55                   	push   %ebp
20000010:	89 e5                	mov    %esp,%ebp

}
20000012:	5d                   	pop    %ebp
20000013:	c3                   	ret    

20000014 <dWrite>:

int dWrite(void* data) {
20000014:	55                   	push   %ebp
20000015:	89 e5                	mov    %esp,%ebp

}
20000017:	5d                   	pop    %ebp
20000018:	c3                   	ret    

20000019 <main>:

int main(void* initrfsPtr) {
20000019:	8d 4c 24 04          	lea    0x4(%esp),%ecx
2000001d:	83 e4 f0             	and    $0xfffffff0,%esp
20000020:	ff 71 fc             	pushl  -0x4(%ecx)
20000023:	55                   	push   %ebp
20000024:	89 e5                	mov    %esp,%ebp
20000026:	51                   	push   %ecx
20000027:	83 ec 24             	sub    $0x24,%esp
	int dOpenID = rpc_register_handler(&dOpen);
2000002a:	83 ec 0c             	sub    $0xc,%esp
2000002d:	68 00 00 00 20       	push   $0x20000000
20000032:	e8 05 03 00 00       	call   2000033c <rpc_register_handler>
20000037:	83 c4 10             	add    $0x10,%esp
2000003a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int dCloseID = rpc_register_handler(&dClose);
2000003d:	83 ec 0c             	sub    $0xc,%esp
20000040:	68 05 00 00 20       	push   $0x20000005
20000045:	e8 f2 02 00 00       	call   2000033c <rpc_register_handler>
2000004a:	83 c4 10             	add    $0x10,%esp
2000004d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int dRemoveID = rpc_register_handler(&dRemove);
20000050:	83 ec 0c             	sub    $0xc,%esp
20000053:	68 0a 00 00 20       	push   $0x2000000a
20000058:	e8 df 02 00 00       	call   2000033c <rpc_register_handler>
2000005d:	83 c4 10             	add    $0x10,%esp
20000060:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int dReadID = rpc_register_handler(&dRead);
20000063:	83 ec 0c             	sub    $0xc,%esp
20000066:	68 0f 00 00 20       	push   $0x2000000f
2000006b:	e8 cc 02 00 00       	call   2000033c <rpc_register_handler>
20000070:	83 c4 10             	add    $0x10,%esp
20000073:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int dWriteID = rpc_register_handler(&dWrite);
20000076:	83 ec 0c             	sub    $0xc,%esp
20000079:	68 14 00 00 20       	push   $0x20000014
2000007e:	e8 b9 02 00 00       	call   2000033c <rpc_register_handler>
20000083:	83 c4 10             	add    $0x10,%esp
20000086:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int driverID = register_driver(dOpenID, dCloseID, dRemoveID, dReadID, dWriteID);
20000089:	83 ec 0c             	sub    $0xc,%esp
2000008c:	ff 75 f0             	pushl  -0x10(%ebp)
2000008f:	ff 75 ec             	pushl  -0x14(%ebp)
20000092:	ff 75 e8             	pushl  -0x18(%ebp)
20000095:	ff 75 e4             	pushl  -0x1c(%ebp)
20000098:	ff 75 e0             	pushl  -0x20(%ebp)
2000009b:	e8 d0 03 00 00       	call   20000470 <register_driver>
200000a0:	83 c4 20             	add    $0x20,%esp
200000a3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	kprintf("Registered driver %d (%d, %d, %d, %d, %d)\n", driverID, dOpenID, dCloseID, dRemoveID, dReadID, dWriteID);
200000a6:	83 ec 04             	sub    $0x4,%esp
200000a9:	ff 75 f0             	pushl  -0x10(%ebp)
200000ac:	ff 75 ec             	pushl  -0x14(%ebp)
200000af:	ff 75 e8             	pushl  -0x18(%ebp)
200000b2:	ff 75 e4             	pushl  -0x1c(%ebp)
200000b5:	ff 75 e0             	pushl  -0x20(%ebp)
200000b8:	ff 75 f4             	pushl  -0xc(%ebp)
200000bb:	68 00 20 00 20       	push   $0x20002000
200000c0:	e8 a8 01 00 00       	call   2000026d <kprintf>
200000c5:	83 c4 20             	add    $0x20,%esp


	while(1);
200000c8:	eb fe                	jmp    200000c8 <main+0xaf>
	...

200000cc <getargsptr>:

	while (1) {
	}
}

void* getargsptr() {
200000cc:	55                   	push   %ebp
200000cd:	89 e5                	mov    %esp,%ebp
200000cf:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };

	syscall(&state);
200000d2:	8d 45 e0             	lea    -0x20(%ebp),%eax
void* getargsptr() {
	struct regstate state = {
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200000d5:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)

	syscall(&state);
200000dc:	50                   	push   %eax
void* getargsptr() {
	struct regstate state = {
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200000dd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
200000e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200000eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200000f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200000f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000100:	e8 6b 00 00 00       	call   20000170 <syscall>

	return (void*) state.eax;
}
20000105:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000108:	c9                   	leave  
20000109:	c3                   	ret    

2000010a <exit>:
	int result = main(getargsptr());

	exit(result);
}

void exit(int returncode) {
2000010a:	55                   	push   %ebp
2000010b:	89 e5                	mov    %esp,%ebp
2000010d:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000110:	8b 45 08             	mov    0x8(%ebp),%eax
20000113:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
2000011a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000011d:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000120:	50                   	push   %eax
void exit(int returncode) {
	struct regstate state = {
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000121:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000128:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000012f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000136:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000013d:	e8 2e 00 00 00       	call   20000170 <syscall>
20000142:	83 c4 10             	add    $0x10,%esp
20000145:	eb fe                	jmp    20000145 <exit+0x3b>

20000147 <_start>:
			.esi = 0, .edi = 0 };

	syscall(&state);
}

void _start() {
20000147:	55                   	push   %ebp
20000148:	89 e5                	mov    %esp,%ebp
2000014a:	83 ec 08             	sub    $0x8,%esp
	rpc_init();
2000014d:	e8 58 02 00 00       	call   200003aa <rpc_init>

	int result = main(getargsptr());
20000152:	e8 75 ff ff ff       	call   200000cc <getargsptr>
20000157:	83 ec 0c             	sub    $0xc,%esp
2000015a:	50                   	push   %eax
2000015b:	e8 b9 fe ff ff       	call   20000019 <main>

	exit(result);
20000160:	89 04 24             	mov    %eax,(%esp)
20000163:	e8 a2 ff ff ff       	call   2000010a <exit>
20000168:	83 c4 10             	add    $0x10,%esp
}
2000016b:	c9                   	leave  
2000016c:	c3                   	ret    
2000016d:	00 00                	add    %al,(%eax)
	...

20000170 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
20000170:	55                   	push   %ebp
20000171:	89 e5                	mov    %esp,%ebp
20000173:	57                   	push   %edi
20000174:	56                   	push   %esi
20000175:	53                   	push   %ebx
20000176:	83 ec 10             	sub    $0x10,%esp
	asm("int $0x30"
20000179:	8b 55 08             	mov    0x8(%ebp),%edx
2000017c:	8b 45 08             	mov    0x8(%ebp),%eax
2000017f:	8b 72 0c             	mov    0xc(%edx),%esi
20000182:	8b 00                	mov    (%eax),%eax
20000184:	89 75 e4             	mov    %esi,-0x1c(%ebp)
20000187:	8b 5a 04             	mov    0x4(%edx),%ebx
2000018a:	8b 4a 08             	mov    0x8(%edx),%ecx
2000018d:	8b 72 10             	mov    0x10(%edx),%esi
20000190:	8b 7a 14             	mov    0x14(%edx),%edi
20000193:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000196:	8b 55 e4             	mov    -0x1c(%ebp),%edx
20000199:	cd 30                	int    $0x30
2000019b:	89 55 e8             	mov    %edx,-0x18(%ebp)
2000019e:	8b 55 08             	mov    0x8(%ebp),%edx
200001a1:	89 45 f0             	mov    %eax,-0x10(%ebp)
200001a4:	89 02                	mov    %eax,(%edx)
200001a6:	8b 45 e8             	mov    -0x18(%ebp),%eax
200001a9:	89 5a 04             	mov    %ebx,0x4(%edx)
200001ac:	89 4a 08             	mov    %ecx,0x8(%edx)
200001af:	89 42 0c             	mov    %eax,0xc(%edx)
200001b2:	89 72 10             	mov    %esi,0x10(%edx)
200001b5:	89 7a 14             	mov    %edi,0x14(%edx)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
200001b8:	83 c4 10             	add    $0x10,%esp
200001bb:	5b                   	pop    %ebx
200001bc:	5e                   	pop    %esi
200001bd:	5f                   	pop    %edi
200001be:	5d                   	pop    %ebp
200001bf:	c3                   	ret    

200001c0 <setclr>:
        x /= base;
    } while (x);
    kputs(p);
}

void setclr(char clr) {
200001c0:	55                   	push   %ebp
200001c1:	89 e5                	mov    %esp,%ebp
    color = clr;
200001c3:	8b 45 08             	mov    0x8(%ebp),%eax
}
200001c6:	5d                   	pop    %ebp
    } while (x);
    kputs(p);
}

void setclr(char clr) {
    color = clr;
200001c7:	a2 00 10 00 20       	mov    %al,0x20001000
}
200001cc:	c3                   	ret    

200001cd <kputc>:
static int x = 0;
static int y = 0;
static int kprintf_res = 0;
static char color = 0x07;

void kputc(char c) {
200001cd:	55                   	push   %ebp
200001ce:	89 e5                	mov    %esp,%ebp
200001d0:	83 ec 34             	sub    $0x34,%esp
200001d3:	0f be 45 08          	movsbl 0x8(%ebp),%eax
	struct regstate state = {
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200001d7:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200001da:	8d 45 e0             	lea    -0x20(%ebp),%eax
200001dd:	50                   	push   %eax
void kputc(char c) {
	struct regstate state = {
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200001de:	c7 45 e0 00 01 00 00 	movl   $0x100,-0x20(%ebp)
200001e5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200001ec:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200001f3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200001fa:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000201:	e8 6a ff ff ff       	call   20000170 <syscall>
20000206:	83 c4 10             	add    $0x10,%esp
}
20000209:	c9                   	leave  
2000020a:	c3                   	ret    

2000020b <kputs>:

void kputs(const char* s) {
2000020b:	55                   	push   %ebp
2000020c:	89 e5                	mov    %esp,%ebp
2000020e:	53                   	push   %ebx
2000020f:	83 ec 04             	sub    $0x4,%esp
20000212:	8b 5d 08             	mov    0x8(%ebp),%ebx
    while (*s) {
20000215:	eb 10                	jmp    20000227 <kputs+0x1c>
        kputc(*s++);
20000217:	83 ec 0c             	sub    $0xc,%esp
2000021a:	43                   	inc    %ebx
2000021b:	0f be c0             	movsbl %al,%eax
2000021e:	50                   	push   %eax
2000021f:	e8 a9 ff ff ff       	call   200001cd <kputc>
20000224:	83 c4 10             	add    $0x10,%esp

	syscall(&state);
}

void kputs(const char* s) {
    while (*s) {
20000227:	8a 03                	mov    (%ebx),%al
20000229:	84 c0                	test   %al,%al
2000022b:	75 ea                	jne    20000217 <kputs+0xc>
        kputc(*s++);
    }
}
2000022d:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000230:	c9                   	leave  
20000231:	c3                   	ret    

20000232 <kputn>:

void kputn(unsigned long x, int base) {
20000232:	55                   	push   %ebp
20000233:	89 e5                	mov    %esp,%ebp
20000235:	53                   	push   %ebx
20000236:	83 ec 54             	sub    $0x54,%esp
20000239:	8b 5d 0c             	mov    0xc(%ebp),%ebx
2000023c:	8b 45 08             	mov    0x8(%ebp),%eax
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    char* p;

    if (base > 36) {
2000023f:	83 fb 24             	cmp    $0x24,%ebx
20000242:	7f 24                	jg     20000268 <kputn+0x36>
        return;
    }

    p = buf + 64;
    *p = '\0';
20000244:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
20000248:	8d 4d f7             	lea    -0x9(%ebp),%ecx
    do {
        *--p = digits[x % base];
2000024b:	31 d2                	xor    %edx,%edx
2000024d:	49                   	dec    %ecx
2000024e:	f7 f3                	div    %ebx
        x /= base;
    } while (x);
20000250:	85 c0                	test   %eax,%eax
    }

    p = buf + 64;
    *p = '\0';
    do {
        *--p = digits[x % base];
20000252:	8a 92 44 20 00 20    	mov    0x20002044(%edx),%dl
20000258:	88 11                	mov    %dl,(%ecx)
        x /= base;
    } while (x);
2000025a:	75 ef                	jne    2000024b <kputn+0x19>
    kputs(p);
2000025c:	83 ec 0c             	sub    $0xc,%esp
2000025f:	51                   	push   %ecx
20000260:	e8 a6 ff ff ff       	call   2000020b <kputs>
20000265:	83 c4 10             	add    $0x10,%esp
}
20000268:	8b 5d fc             	mov    -0x4(%ebp),%ebx
2000026b:	c9                   	leave  
2000026c:	c3                   	ret    

2000026d <kprintf>:

void setclr(char clr) {
    color = clr;
}

int kprintf(const char* fmt, ...) {
2000026d:	55                   	push   %ebp
2000026e:	89 e5                	mov    %esp,%ebp
20000270:	57                   	push   %edi
20000271:	56                   	push   %esi
20000272:	53                   	push   %ebx
20000273:	83 ec 0c             	sub    $0xc,%esp
20000276:	8d 5d 0c             	lea    0xc(%ebp),%ebx
20000279:	8b 75 08             	mov    0x8(%ebp),%esi
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
2000027c:	c7 05 00 30 00 20 00 	movl   $0x0,0x20003000
20000283:	00 00 00 
    while (*fmt) {
20000286:	e9 99 00 00 00       	jmp    20000324 <kprintf+0xb7>
        if (*fmt == '%') {
2000028b:	3c 25                	cmp    $0x25,%al
2000028d:	0f 85 81 00 00 00    	jne    20000314 <kprintf+0xa7>
            fmt++;
20000293:	46                   	inc    %esi
            switch (*fmt) {
20000294:	8a 06                	mov    (%esi),%al
20000296:	3c 70                	cmp    $0x70,%al
20000298:	74 40                	je     200002da <kprintf+0x6d>
2000029a:	7f 1a                	jg     200002b6 <kprintf+0x49>
2000029c:	3c 63                	cmp    $0x63,%al
2000029e:	74 4c                	je     200002ec <kprintf+0x7f>
200002a0:	7f 0e                	jg     200002b0 <kprintf+0x43>
200002a2:	84 c0                	test   %al,%al
200002a4:	0f 84 84 00 00 00    	je     2000032e <kprintf+0xc1>
200002aa:	3c 25                	cmp    $0x25,%al
200002ac:	75 56                	jne    20000304 <kprintf+0x97>
200002ae:	eb 4d                	jmp    200002fd <kprintf+0x90>
200002b0:	3c 64                	cmp    $0x64,%al
200002b2:	75 50                	jne    20000304 <kprintf+0x97>
200002b4:	eb 1b                	jmp    200002d1 <kprintf+0x64>
200002b6:	3c 75                	cmp    $0x75,%al
200002b8:	74 17                	je     200002d1 <kprintf+0x64>
200002ba:	3c 78                	cmp    $0x78,%al
200002bc:	74 1c                	je     200002da <kprintf+0x6d>
200002be:	3c 73                	cmp    $0x73,%al
200002c0:	75 42                	jne    20000304 <kprintf+0x97>
            case 's':
                s = va_arg(ap, char*);
                kputs(s);
200002c2:	83 ec 0c             	sub    $0xc,%esp
    while (*fmt) {
        if (*fmt == '%') {
            fmt++;
            switch (*fmt) {
            case 's':
                s = va_arg(ap, char*);
200002c5:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputs(s);
200002c8:	ff 33                	pushl  (%ebx)
200002ca:	e8 3c ff ff ff       	call   2000020b <kputs>
200002cf:	eb 17                	jmp    200002e8 <kprintf+0x7b>
                break;
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
200002d1:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 10);
200002d4:	51                   	push   %ecx
200002d5:	51                   	push   %ecx
200002d6:	6a 0a                	push   $0xa
200002d8:	eb 07                	jmp    200002e1 <kprintf+0x74>
                break;
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
200002da:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 16);
200002dd:	52                   	push   %edx
200002de:	52                   	push   %edx
200002df:	6a 10                	push   $0x10
200002e1:	ff 33                	pushl  (%ebx)
200002e3:	e8 4a ff ff ff       	call   20000232 <kputn>
200002e8:	89 fb                	mov    %edi,%ebx
200002ea:	eb 34                	jmp    20000320 <kprintf+0xb3>
                break;
            case 'c':
                c = va_arg(ap, int);
                kputc(c);
200002ec:	83 ec 0c             	sub    $0xc,%esp
            case 'p':
                n = va_arg(ap, unsigned long int);
                kputn(n, 16);
                break;
            case 'c':
                c = va_arg(ap, int);
200002ef:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputc(c);
200002f2:	0f be 03             	movsbl (%ebx),%eax
200002f5:	50                   	push   %eax
200002f6:	e8 d2 fe ff ff       	call   200001cd <kputc>
200002fb:	eb eb                	jmp    200002e8 <kprintf+0x7b>
                break;
            case '%':
                kputc('%');
200002fd:	83 ec 0c             	sub    $0xc,%esp
20000300:	6a 25                	push   $0x25
20000302:	eb 17                	jmp    2000031b <kprintf+0xae>
                break;
            case '\0':
                goto out;
            default:
                kputc('%');
20000304:	83 ec 0c             	sub    $0xc,%esp
20000307:	6a 25                	push   $0x25
20000309:	e8 bf fe ff ff       	call   200001cd <kputc>
                kputc(*fmt);
2000030e:	58                   	pop    %eax
2000030f:	0f be 06             	movsbl (%esi),%eax
20000312:	eb 06                	jmp    2000031a <kprintf+0xad>
                break;
            }
        } else {
            kputc(*fmt);
20000314:	83 ec 0c             	sub    $0xc,%esp
20000317:	0f be c0             	movsbl %al,%eax
2000031a:	50                   	push   %eax
2000031b:	e8 ad fe ff ff       	call   200001cd <kputc>
20000320:	83 c4 10             	add    $0x10,%esp
        }

        fmt++;
20000323:	46                   	inc    %esi
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
    while (*fmt) {
20000324:	8a 06                	mov    (%esi),%al
20000326:	84 c0                	test   %al,%al
20000328:	0f 85 5d ff ff ff    	jne    2000028b <kprintf+0x1e>

    out:
    va_end(ap);

    return kprintf_res;
}
2000032e:	a1 00 30 00 20       	mov    0x20003000,%eax
20000333:	8d 65 f4             	lea    -0xc(%ebp),%esp
20000336:	5b                   	pop    %ebx
20000337:	5e                   	pop    %esi
20000338:	5f                   	pop    %edi
20000339:	5d                   	pop    %ebp
2000033a:	c3                   	ret    
	...

2000033c <rpc_register_handler>:

	*rpcID = state.ebx;
	return (void*) state.eax;
}

int rpc_register_handler(int(*fptr)(void*)) {
2000033c:	55                   	push   %ebp
2000033d:	31 c0                	xor    %eax,%eax
2000033f:	89 e5                	mov    %esp,%ebp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		if(rpcHandlers[i] == (int(*)(void*))0) {
20000341:	83 3c 85 04 30 00 20 	cmpl   $0x0,0x20003004(,%eax,4)
20000348:	00 
20000349:	75 0c                	jne    20000357 <rpc_register_handler+0x1b>
			rpcHandlers[i] = fptr;
2000034b:	8b 55 08             	mov    0x8(%ebp),%edx
2000034e:	89 14 85 04 30 00 20 	mov    %edx,0x20003004(,%eax,4)
			return i;
20000355:	eb 0b                	jmp    20000362 <rpc_register_handler+0x26>
	*rpcID = state.ebx;
	return (void*) state.eax;
}

int rpc_register_handler(int(*fptr)(void*)) {
	for(int i = 0; i < RPC_HANDLERS; i++) {
20000357:	40                   	inc    %eax
20000358:	3d 00 04 00 00       	cmp    $0x400,%eax
2000035d:	75 e2                	jne    20000341 <rpc_register_handler+0x5>
2000035f:	83 c8 ff             	or     $0xffffffff,%eax
			rpcHandlers[i] = fptr;
			return i;
		}
	}
	return -1;
}
20000362:	5d                   	pop    %ebp
20000363:	c3                   	ret    

20000364 <rpc_map>:
			.esi = 0, .edi = 0 };

	syscall(&state);
}

void* rpc_map(uint32_t* rpcID) {
20000364:	55                   	push   %ebp
20000365:	89 e5                	mov    %esp,%ebp
20000367:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };

	syscall(&state);
2000036a:	8d 45 e0             	lea    -0x20(%ebp),%eax
void* rpc_map(uint32_t* rpcID) {
	struct regstate state = {
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
2000036d:	c7 45 e0 00 02 00 00 	movl   $0x200,-0x20(%ebp)

	syscall(&state);
20000374:	50                   	push   %eax
void* rpc_map(uint32_t* rpcID) {
	struct regstate state = {
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000375:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
2000037c:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000383:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000038a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000391:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000398:	e8 d3 fd ff ff       	call   20000170 <syscall>

	*rpcID = state.ebx;
2000039d:	8b 45 08             	mov    0x8(%ebp),%eax
200003a0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
200003a3:	89 10                	mov    %edx,(%eax)
	return (void*) state.eax;
}
200003a5:	8b 45 e0             	mov    -0x20(%ebp),%eax
200003a8:	c9                   	leave  
200003a9:	c3                   	ret    

200003aa <rpc_init>:
	syscall(&state);

	while(1);
}

void rpc_init() {
200003aa:	55                   	push   %ebp
200003ab:	31 c0                	xor    %eax,%eax
200003ad:	89 e5                	mov    %esp,%ebp
200003af:	57                   	push   %edi
200003b0:	56                   	push   %esi
200003b1:	83 ec 20             	sub    $0x20,%esp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		rpcHandlers[i] = (int(*)(void*))0;
200003b4:	c7 04 85 04 30 00 20 	movl   $0x0,0x20003004(,%eax,4)
200003bb:	00 00 00 00 

	while(1);
}

void rpc_init() {
	for(int i = 0; i < RPC_HANDLERS; i++) {
200003bf:	40                   	inc    %eax
200003c0:	3d 00 04 00 00       	cmp    $0x400,%eax
200003c5:	75 ed                	jne    200003b4 <rpc_init+0xa>

	struct regstate state = {
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200003c7:	8d 7d e0             	lea    -0x20(%ebp),%edi
200003ca:	be 2c 20 00 20       	mov    $0x2000202c,%esi
200003cf:	b9 06 00 00 00       	mov    $0x6,%ecx

	syscall(&state);
200003d4:	83 ec 0c             	sub    $0xc,%esp

	struct regstate state = {
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200003d7:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

	syscall(&state);
200003d9:	8d 45 e0             	lea    -0x20(%ebp),%eax
200003dc:	50                   	push   %eax
200003dd:	e8 8e fd ff ff       	call   20000170 <syscall>
200003e2:	83 c4 10             	add    $0x10,%esp
}
200003e5:	8d 65 f8             	lea    -0x8(%ebp),%esp
200003e8:	5e                   	pop    %esi
200003e9:	5f                   	pop    %edi
200003ea:	5d                   	pop    %ebp
200003eb:	c3                   	ret    

200003ec <rpc_return>:

#define RPC_HANDLERS 1024

static int(*rpcHandlers[RPC_HANDLERS])(void*);

void rpc_return(int returnCode) {
200003ec:	55                   	push   %ebp
200003ed:	89 e5                	mov    %esp,%ebp
200003ef:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200003f2:	8b 45 08             	mov    0x8(%ebp),%eax
200003f5:	c7 45 e0 01 02 00 00 	movl   $0x201,-0x20(%ebp)
200003fc:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200003ff:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000402:	50                   	push   %eax
void rpc_return(int returnCode) {
	struct regstate state = {
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000403:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
2000040a:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000411:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000418:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000041f:	e8 4c fd ff ff       	call   20000170 <syscall>
20000424:	83 c4 10             	add    $0x10,%esp
20000427:	eb fe                	jmp    20000427 <rpc_return+0x3b>

20000429 <rpc_handler>:
		}
	}
	return -1;
}

void rpc_handler() {
20000429:	55                   	push   %ebp
2000042a:	89 e5                	mov    %esp,%ebp
2000042c:	83 ec 24             	sub    $0x24,%esp
	uint32_t rpcID;
	void* rpcData = rpc_map(&rpcID);
2000042f:	8d 45 f4             	lea    -0xc(%ebp),%eax
20000432:	50                   	push   %eax
20000433:	e8 2c ff ff ff       	call   20000364 <rpc_map>

	int returnValue = -1;

	if(rpcID < RPC_HANDLERS && rpcHandlers[rpcID] != 0) {
20000438:	8b 55 f4             	mov    -0xc(%ebp),%edx
2000043b:	83 c4 10             	add    $0x10,%esp
2000043e:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
20000444:	77 16                	ja     2000045c <rpc_handler+0x33>
20000446:	8b 14 95 04 30 00 20 	mov    0x20003004(,%edx,4),%edx
2000044d:	85 d2                	test   %edx,%edx
2000044f:	74 0b                	je     2000045c <rpc_handler+0x33>
		returnValue = rpcHandlers[rpcID](rpcData);
20000451:	83 ec 0c             	sub    $0xc,%esp
20000454:	50                   	push   %eax
20000455:	ff d2                	call   *%edx
20000457:	83 c4 10             	add    $0x10,%esp
2000045a:	eb 03                	jmp    2000045f <rpc_handler+0x36>
2000045c:	83 c8 ff             	or     $0xffffffff,%eax
	}

	rpc_return(returnValue);
2000045f:	83 ec 0c             	sub    $0xc,%esp
20000462:	50                   	push   %eax
20000463:	e8 84 ff ff ff       	call   200003ec <rpc_return>
20000468:	83 c4 10             	add    $0x10,%esp
}
2000046b:	c9                   	leave  
2000046c:	c3                   	ret    
2000046d:	00 00                	add    %al,(%eax)
	...

20000470 <register_driver>:
#include "driver.h"
#include "syscall.h"


int register_driver(int dOpenID, int dCloseID, int dRemoveID, int dReadID, int dWriteID) {
20000470:	55                   	push   %ebp
20000471:	89 e5                	mov    %esp,%ebp
20000473:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x300,
			.ebx = dOpenID,
			.ecx = dCloseID, .edx = dRemoveID,
			.esi = dReadID,  .edi = dWriteID };
20000476:	8b 45 08             	mov    0x8(%ebp),%eax
20000479:	c7 45 e0 00 03 00 00 	movl   $0x300,-0x20(%ebp)
20000480:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000483:	8b 45 0c             	mov    0xc(%ebp),%eax
20000486:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000489:	8b 45 10             	mov    0x10(%ebp),%eax
2000048c:	89 45 ec             	mov    %eax,-0x14(%ebp)
2000048f:	8b 45 14             	mov    0x14(%ebp),%eax
20000492:	89 45 f0             	mov    %eax,-0x10(%ebp)
20000495:	8b 45 18             	mov    0x18(%ebp),%eax
20000498:	89 45 f4             	mov    %eax,-0xc(%ebp)

	syscall(&state);
2000049b:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000049e:	50                   	push   %eax
2000049f:	e8 cc fc ff ff       	call   20000170 <syscall>

	return state.eax;
}
200004a4:	8b 45 e0             	mov    -0x20(%ebp),%eax
200004a7:	c9                   	leave  
200004a8:	c3                   	ret    
