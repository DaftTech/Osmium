
../../initrfs/init:     file format elf32-i386
../../initrfs/init
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x20000185

Program Header:
    LOAD off    0x00001000 vaddr 0x20000000 paddr 0x20000000 align 2**12
         filesz 0x000005b5 memsz 0x000005b5 flags r-x
    LOAD off    0x00002000 vaddr 0x20001000 paddr 0x20001000 align 2**12
         filesz 0x000010a6 memsz 0x00003004 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000005b5  20000000  20000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000001  20001000  20001000  00002000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000044  20002000  20002000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 00000062  20002044  20002044  00003044  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00001004  20003000  20003000  000030a6  2**2
                  ALLOC
  5 .stab         00001b30  00000000  00000000  000030a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      0000006c  00000000  00000000  00004bd8  2**0
                  CONTENTS, READONLY
  7 .stabstr      00000d57  00000000  00000000  00004c44  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
20000000 l    d  .text	00000000 .text
20001000 l    d  .data	00000000 .data
20002000 l    d  .rodata	00000000 .rodata
20002044 l    d  .rodata.str1.1	00000000 .rodata.str1.1
20003000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 init.c
00000000 l    df *ABS*	00000000 process.c
20000147 l     F .text	0000003e testRPC
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    df *ABS*	00000000 console.c
20001000 l     O .data	00000001 color
20003000 l     O .bss	00000004 kprintf_res
00000000 l    df *ABS*	00000000 rpc.c
20003004 l     O .bss	00001000 rpcHandlers
2000202c l     O .rodata	00000018 C.2.866
00000000 l    df *ABS*	00000000 driver.c
2000057c g     F .text	00000039 register_driver
2000028d g     F .text	0000003e kputc
20000230 g     F .text	00000050 syscall
200004a7 g     F .text	00000042 rpc_init
20000280 g     F .text	0000000d setclr
2000000f g     F .text	00000005 dRead
20000424 g     F .text	0000003d rpc_check_future
20000461 g     F .text	00000046 rpc_map
200003fc g     F .text	00000028 rpc_register_handler
200000cc g     F .text	0000003e getargsptr
20000005 g     F .text	00000005 dClose
20000185 g     F .text	000000a8 _start
20000019 g     F .text	000000b1 main
20000526 g     F .text	00000055 rpc_handler
200002f2 g     F .text	0000003b kputn
200002cb g     F .text	00000027 kputs
2000000a g     F .text	00000005 dRemove
200004e9 g     F .text	0000003d rpc_return
2000032d g     F .text	000000ce kprintf
20000000 g     F .text	00000005 dOpen
2000010a g     F .text	0000003d exit
20000014 g     F .text	00000005 dWrite



Disassembly of section .text:

20000000 <dOpen>:
#include "process.h"
#include "console.h"

int dOpen(void* data) {
20000000:	55                   	push   %ebp
20000001:	89 e5                	mov    %esp,%ebp

}
20000003:	5d                   	pop    %ebp
20000004:	c3                   	ret    

20000005 <dClose>:

int dClose(void* data) {
20000005:	55                   	push   %ebp
20000006:	89 e5                	mov    %esp,%ebp

}
20000008:	5d                   	pop    %ebp
20000009:	c3                   	ret    

2000000a <dRemove>:

int dRemove(void* data) {
2000000a:	55                   	push   %ebp
2000000b:	89 e5                	mov    %esp,%ebp

}
2000000d:	5d                   	pop    %ebp
2000000e:	c3                   	ret    

2000000f <dRead>:

int dRead(void* data) {
2000000f:	55                   	push   %ebp
20000010:	89 e5                	mov    %esp,%ebp

}
20000012:	5d                   	pop    %ebp
20000013:	c3                   	ret    

20000014 <dWrite>:

int dWrite(void* data) {
20000014:	55                   	push   %ebp
20000015:	89 e5                	mov    %esp,%ebp

}
20000017:	5d                   	pop    %ebp
20000018:	c3                   	ret    

20000019 <main>:

int main(void* initrfsPtr) {
20000019:	8d 4c 24 04          	lea    0x4(%esp),%ecx
2000001d:	83 e4 f0             	and    $0xfffffff0,%esp
20000020:	ff 71 fc             	pushl  -0x4(%ecx)
20000023:	55                   	push   %ebp
20000024:	89 e5                	mov    %esp,%ebp
20000026:	51                   	push   %ecx
20000027:	83 ec 24             	sub    $0x24,%esp
	int dOpenID = rpc_register_handler(&dOpen);
2000002a:	83 ec 0c             	sub    $0xc,%esp
2000002d:	68 00 00 00 20       	push   $0x20000000
20000032:	e8 c5 03 00 00       	call   200003fc <rpc_register_handler>
20000037:	83 c4 10             	add    $0x10,%esp
2000003a:	89 45 e0             	mov    %eax,-0x20(%ebp)
	int dCloseID = rpc_register_handler(&dClose);
2000003d:	83 ec 0c             	sub    $0xc,%esp
20000040:	68 05 00 00 20       	push   $0x20000005
20000045:	e8 b2 03 00 00       	call   200003fc <rpc_register_handler>
2000004a:	83 c4 10             	add    $0x10,%esp
2000004d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int dRemoveID = rpc_register_handler(&dRemove);
20000050:	83 ec 0c             	sub    $0xc,%esp
20000053:	68 0a 00 00 20       	push   $0x2000000a
20000058:	e8 9f 03 00 00       	call   200003fc <rpc_register_handler>
2000005d:	83 c4 10             	add    $0x10,%esp
20000060:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int dReadID = rpc_register_handler(&dRead);
20000063:	83 ec 0c             	sub    $0xc,%esp
20000066:	68 0f 00 00 20       	push   $0x2000000f
2000006b:	e8 8c 03 00 00       	call   200003fc <rpc_register_handler>
20000070:	83 c4 10             	add    $0x10,%esp
20000073:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int dWriteID = rpc_register_handler(&dWrite);
20000076:	83 ec 0c             	sub    $0xc,%esp
20000079:	68 14 00 00 20       	push   $0x20000014
2000007e:	e8 79 03 00 00       	call   200003fc <rpc_register_handler>
20000083:	83 c4 10             	add    $0x10,%esp
20000086:	89 45 f0             	mov    %eax,-0x10(%ebp)

	int driverID = register_driver(dOpenID, dCloseID, dRemoveID, dReadID, dWriteID);
20000089:	83 ec 0c             	sub    $0xc,%esp
2000008c:	ff 75 f0             	pushl  -0x10(%ebp)
2000008f:	ff 75 ec             	pushl  -0x14(%ebp)
20000092:	ff 75 e8             	pushl  -0x18(%ebp)
20000095:	ff 75 e4             	pushl  -0x1c(%ebp)
20000098:	ff 75 e0             	pushl  -0x20(%ebp)
2000009b:	e8 dc 04 00 00       	call   2000057c <register_driver>
200000a0:	83 c4 20             	add    $0x20,%esp
200000a3:	89 45 f4             	mov    %eax,-0xc(%ebp)

	kprintf("Registered driver %d (%d, %d, %d, %d, %d)\n", driverID, dOpenID, dCloseID, dRemoveID, dReadID, dWriteID);
200000a6:	83 ec 04             	sub    $0x4,%esp
200000a9:	ff 75 f0             	pushl  -0x10(%ebp)
200000ac:	ff 75 ec             	pushl  -0x14(%ebp)
200000af:	ff 75 e8             	pushl  -0x18(%ebp)
200000b2:	ff 75 e4             	pushl  -0x1c(%ebp)
200000b5:	ff 75 e0             	pushl  -0x20(%ebp)
200000b8:	ff 75 f4             	pushl  -0xc(%ebp)
200000bb:	68 00 20 00 20       	push   $0x20002000
200000c0:	e8 68 02 00 00       	call   2000032d <kprintf>
200000c5:	83 c4 20             	add    $0x20,%esp


	while(1);
200000c8:	eb fe                	jmp    200000c8 <main+0xaf>
	...

200000cc <getargsptr>:

	while (1) {
	}
}

void* getargsptr() {
200000cc:	55                   	push   %ebp
200000cd:	89 e5                	mov    %esp,%ebp
200000cf:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };

	syscall(&state);
200000d2:	8d 45 e0             	lea    -0x20(%ebp),%eax
void* getargsptr() {
	struct regstate state = {
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200000d5:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)

	syscall(&state);
200000dc:	50                   	push   %eax
void* getargsptr() {
	struct regstate state = {
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200000dd:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
200000e4:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200000eb:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200000f2:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200000f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000100:	e8 2b 01 00 00       	call   20000230 <syscall>

	return (void*) state.eax;
}
20000105:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000108:	c9                   	leave  
20000109:	c3                   	ret    

2000010a <exit>:
	int result = main(getargsptr());

	exit(result);
}

void exit(int returncode) {
2000010a:	55                   	push   %ebp
2000010b:	89 e5                	mov    %esp,%ebp
2000010d:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000110:	8b 45 08             	mov    0x8(%ebp),%eax
20000113:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
2000011a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000011d:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000120:	50                   	push   %eax
void exit(int returncode) {
	struct regstate state = {
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000121:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000128:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000012f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000136:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000013d:	e8 ee 00 00 00       	call   20000230 <syscall>
20000142:	83 c4 10             	add    $0x10,%esp
20000145:	eb fe                	jmp    20000145 <exit+0x3b>

20000147 <testRPC>:
#include "rpc.h"
#include "console.h"

extern int main(void* args);

static FUTURE testRPC() {
20000147:	55                   	push   %ebp
20000148:	89 e5                	mov    %esp,%ebp
2000014a:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x101,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };

	syscall(&state);
2000014d:	8d 45 e0             	lea    -0x20(%ebp),%eax
static FUTURE testRPC() {
	struct regstate state = {
			.eax = 0x101,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000150:	c7 45 e0 01 01 00 00 	movl   $0x101,-0x20(%ebp)

	syscall(&state);
20000157:	50                   	push   %eax
static FUTURE testRPC() {
	struct regstate state = {
			.eax = 0x101,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000158:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
2000015f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000166:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000016d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000174:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000017b:	e8 b0 00 00 00       	call   20000230 <syscall>

	return state.eax;
}
20000180:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000183:	c9                   	leave  
20000184:	c3                   	ret    

20000185 <_start>:

void _start() {
20000185:	55                   	push   %ebp
20000186:	89 e5                	mov    %esp,%ebp
20000188:	53                   	push   %ebx
20000189:	83 ec 04             	sub    $0x4,%esp
	rpc_init();
2000018c:	e8 16 03 00 00       	call   200004a7 <rpc_init>

	FUTURE fut = testRPC();
20000191:	e8 b1 ff ff ff       	call   20000147 <testRPC>
20000196:	89 c3                	mov    %eax,%ebx
	while(rpc_check_future(fut)) {
20000198:	eb 10                	jmp    200001aa <_start+0x25>
		kprintf("Awaiting future %x...\n", fut);
2000019a:	52                   	push   %edx
2000019b:	52                   	push   %edx
2000019c:	53                   	push   %ebx
2000019d:	68 44 20 00 20       	push   $0x20002044
200001a2:	e8 86 01 00 00       	call   2000032d <kprintf>
200001a7:	83 c4 10             	add    $0x10,%esp

void _start() {
	rpc_init();

	FUTURE fut = testRPC();
	while(rpc_check_future(fut)) {
200001aa:	83 ec 0c             	sub    $0xc,%esp
200001ad:	53                   	push   %ebx
200001ae:	e8 71 02 00 00       	call   20000424 <rpc_check_future>
200001b3:	83 c4 10             	add    $0x10,%esp
200001b6:	85 c0                	test   %eax,%eax
200001b8:	75 e0                	jne    2000019a <_start+0x15>
		kprintf("Awaiting future %x...\n", fut);
	}
	testRPC();
200001ba:	e8 88 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001bf:	e8 83 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001c4:	e8 7e ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001c9:	e8 79 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001ce:	e8 74 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001d3:	e8 6f ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001d8:	e8 6a ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001dd:	e8 65 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001e2:	e8 60 ff ff ff       	call   20000147 <testRPC>
	testRPC();
200001e7:	e8 5b ff ff ff       	call   20000147 <testRPC>


	while(rpc_check_future(0)) {
200001ec:	eb 10                	jmp    200001fe <_start+0x79>
		kprintf("Awaiting all futures..\n", fut);
200001ee:	50                   	push   %eax
200001ef:	50                   	push   %eax
200001f0:	53                   	push   %ebx
200001f1:	68 5b 20 00 20       	push   $0x2000205b
200001f6:	e8 32 01 00 00       	call   2000032d <kprintf>
200001fb:	83 c4 10             	add    $0x10,%esp
	testRPC();
	testRPC();
	testRPC();


	while(rpc_check_future(0)) {
200001fe:	83 ec 0c             	sub    $0xc,%esp
20000201:	6a 00                	push   $0x0
20000203:	e8 1c 02 00 00       	call   20000424 <rpc_check_future>
20000208:	83 c4 10             	add    $0x10,%esp
2000020b:	85 c0                	test   %eax,%eax
2000020d:	75 df                	jne    200001ee <_start+0x69>
		kprintf("Awaiting all futures..\n", fut);
	}

	int result = main(getargsptr());
2000020f:	e8 b8 fe ff ff       	call   200000cc <getargsptr>
20000214:	83 ec 0c             	sub    $0xc,%esp
20000217:	50                   	push   %eax
20000218:	e8 fc fd ff ff       	call   20000019 <main>

	exit(result);
2000021d:	89 04 24             	mov    %eax,(%esp)
20000220:	e8 e5 fe ff ff       	call   2000010a <exit>
20000225:	83 c4 10             	add    $0x10,%esp
}
20000228:	8b 5d fc             	mov    -0x4(%ebp),%ebx
2000022b:	c9                   	leave  
2000022c:	c3                   	ret    
2000022d:	00 00                	add    %al,(%eax)
	...

20000230 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
20000230:	55                   	push   %ebp
20000231:	89 e5                	mov    %esp,%ebp
20000233:	57                   	push   %edi
20000234:	56                   	push   %esi
20000235:	53                   	push   %ebx
20000236:	83 ec 10             	sub    $0x10,%esp
	asm("int $0x30"
20000239:	8b 55 08             	mov    0x8(%ebp),%edx
2000023c:	8b 45 08             	mov    0x8(%ebp),%eax
2000023f:	8b 72 0c             	mov    0xc(%edx),%esi
20000242:	8b 00                	mov    (%eax),%eax
20000244:	89 75 e4             	mov    %esi,-0x1c(%ebp)
20000247:	8b 5a 04             	mov    0x4(%edx),%ebx
2000024a:	8b 4a 08             	mov    0x8(%edx),%ecx
2000024d:	8b 72 10             	mov    0x10(%edx),%esi
20000250:	8b 7a 14             	mov    0x14(%edx),%edi
20000253:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000256:	8b 55 e4             	mov    -0x1c(%ebp),%edx
20000259:	cd 30                	int    $0x30
2000025b:	89 55 e8             	mov    %edx,-0x18(%ebp)
2000025e:	8b 55 08             	mov    0x8(%ebp),%edx
20000261:	89 45 f0             	mov    %eax,-0x10(%ebp)
20000264:	89 02                	mov    %eax,(%edx)
20000266:	8b 45 e8             	mov    -0x18(%ebp),%eax
20000269:	89 5a 04             	mov    %ebx,0x4(%edx)
2000026c:	89 4a 08             	mov    %ecx,0x8(%edx)
2000026f:	89 42 0c             	mov    %eax,0xc(%edx)
20000272:	89 72 10             	mov    %esi,0x10(%edx)
20000275:	89 7a 14             	mov    %edi,0x14(%edx)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
20000278:	83 c4 10             	add    $0x10,%esp
2000027b:	5b                   	pop    %ebx
2000027c:	5e                   	pop    %esi
2000027d:	5f                   	pop    %edi
2000027e:	5d                   	pop    %ebp
2000027f:	c3                   	ret    

20000280 <setclr>:
        x /= base;
    } while (x);
    kputs(p);
}

void setclr(char clr) {
20000280:	55                   	push   %ebp
20000281:	89 e5                	mov    %esp,%ebp
    color = clr;
20000283:	8b 45 08             	mov    0x8(%ebp),%eax
}
20000286:	5d                   	pop    %ebp
    } while (x);
    kputs(p);
}

void setclr(char clr) {
    color = clr;
20000287:	a2 00 10 00 20       	mov    %al,0x20001000
}
2000028c:	c3                   	ret    

2000028d <kputc>:
static int x = 0;
static int y = 0;
static int kprintf_res = 0;
static char color = 0x07;

void kputc(char c) {
2000028d:	55                   	push   %ebp
2000028e:	89 e5                	mov    %esp,%ebp
20000290:	83 ec 34             	sub    $0x34,%esp
20000293:	0f be 45 08          	movsbl 0x8(%ebp),%eax
	struct regstate state = {
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000297:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000029a:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000029d:	50                   	push   %eax
void kputc(char c) {
	struct regstate state = {
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
2000029e:	c7 45 e0 00 01 00 00 	movl   $0x100,-0x20(%ebp)
200002a5:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200002ac:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200002b3:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200002ba:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200002c1:	e8 6a ff ff ff       	call   20000230 <syscall>
200002c6:	83 c4 10             	add    $0x10,%esp
}
200002c9:	c9                   	leave  
200002ca:	c3                   	ret    

200002cb <kputs>:

void kputs(const char* s) {
200002cb:	55                   	push   %ebp
200002cc:	89 e5                	mov    %esp,%ebp
200002ce:	53                   	push   %ebx
200002cf:	83 ec 04             	sub    $0x4,%esp
200002d2:	8b 5d 08             	mov    0x8(%ebp),%ebx
    while (*s) {
200002d5:	eb 10                	jmp    200002e7 <kputs+0x1c>
        kputc(*s++);
200002d7:	83 ec 0c             	sub    $0xc,%esp
200002da:	43                   	inc    %ebx
200002db:	0f be c0             	movsbl %al,%eax
200002de:	50                   	push   %eax
200002df:	e8 a9 ff ff ff       	call   2000028d <kputc>
200002e4:	83 c4 10             	add    $0x10,%esp

	syscall(&state);
}

void kputs(const char* s) {
    while (*s) {
200002e7:	8a 03                	mov    (%ebx),%al
200002e9:	84 c0                	test   %al,%al
200002eb:	75 ea                	jne    200002d7 <kputs+0xc>
        kputc(*s++);
    }
}
200002ed:	8b 5d fc             	mov    -0x4(%ebp),%ebx
200002f0:	c9                   	leave  
200002f1:	c3                   	ret    

200002f2 <kputn>:

void kputn(unsigned long x, int base) {
200002f2:	55                   	push   %ebp
200002f3:	89 e5                	mov    %esp,%ebp
200002f5:	53                   	push   %ebx
200002f6:	83 ec 54             	sub    $0x54,%esp
200002f9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
200002fc:	8b 45 08             	mov    0x8(%ebp),%eax
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    char* p;

    if (base > 36) {
200002ff:	83 fb 24             	cmp    $0x24,%ebx
20000302:	7f 24                	jg     20000328 <kputn+0x36>
        return;
    }

    p = buf + 64;
    *p = '\0';
20000304:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
20000308:	8d 4d f7             	lea    -0x9(%ebp),%ecx
    do {
        *--p = digits[x % base];
2000030b:	31 d2                	xor    %edx,%edx
2000030d:	49                   	dec    %ecx
2000030e:	f7 f3                	div    %ebx
        x /= base;
    } while (x);
20000310:	85 c0                	test   %eax,%eax
    }

    p = buf + 64;
    *p = '\0';
    do {
        *--p = digits[x % base];
20000312:	8a 92 73 20 00 20    	mov    0x20002073(%edx),%dl
20000318:	88 11                	mov    %dl,(%ecx)
        x /= base;
    } while (x);
2000031a:	75 ef                	jne    2000030b <kputn+0x19>
    kputs(p);
2000031c:	83 ec 0c             	sub    $0xc,%esp
2000031f:	51                   	push   %ecx
20000320:	e8 a6 ff ff ff       	call   200002cb <kputs>
20000325:	83 c4 10             	add    $0x10,%esp
}
20000328:	8b 5d fc             	mov    -0x4(%ebp),%ebx
2000032b:	c9                   	leave  
2000032c:	c3                   	ret    

2000032d <kprintf>:

void setclr(char clr) {
    color = clr;
}

int kprintf(const char* fmt, ...) {
2000032d:	55                   	push   %ebp
2000032e:	89 e5                	mov    %esp,%ebp
20000330:	57                   	push   %edi
20000331:	56                   	push   %esi
20000332:	53                   	push   %ebx
20000333:	83 ec 0c             	sub    $0xc,%esp
20000336:	8d 5d 0c             	lea    0xc(%ebp),%ebx
20000339:	8b 75 08             	mov    0x8(%ebp),%esi
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
2000033c:	c7 05 00 30 00 20 00 	movl   $0x0,0x20003000
20000343:	00 00 00 
    while (*fmt) {
20000346:	e9 99 00 00 00       	jmp    200003e4 <kprintf+0xb7>
        if (*fmt == '%') {
2000034b:	3c 25                	cmp    $0x25,%al
2000034d:	0f 85 81 00 00 00    	jne    200003d4 <kprintf+0xa7>
            fmt++;
20000353:	46                   	inc    %esi
            switch (*fmt) {
20000354:	8a 06                	mov    (%esi),%al
20000356:	3c 70                	cmp    $0x70,%al
20000358:	74 40                	je     2000039a <kprintf+0x6d>
2000035a:	7f 1a                	jg     20000376 <kprintf+0x49>
2000035c:	3c 63                	cmp    $0x63,%al
2000035e:	74 4c                	je     200003ac <kprintf+0x7f>
20000360:	7f 0e                	jg     20000370 <kprintf+0x43>
20000362:	84 c0                	test   %al,%al
20000364:	0f 84 84 00 00 00    	je     200003ee <kprintf+0xc1>
2000036a:	3c 25                	cmp    $0x25,%al
2000036c:	75 56                	jne    200003c4 <kprintf+0x97>
2000036e:	eb 4d                	jmp    200003bd <kprintf+0x90>
20000370:	3c 64                	cmp    $0x64,%al
20000372:	75 50                	jne    200003c4 <kprintf+0x97>
20000374:	eb 1b                	jmp    20000391 <kprintf+0x64>
20000376:	3c 75                	cmp    $0x75,%al
20000378:	74 17                	je     20000391 <kprintf+0x64>
2000037a:	3c 78                	cmp    $0x78,%al
2000037c:	74 1c                	je     2000039a <kprintf+0x6d>
2000037e:	3c 73                	cmp    $0x73,%al
20000380:	75 42                	jne    200003c4 <kprintf+0x97>
            case 's':
                s = va_arg(ap, char*);
                kputs(s);
20000382:	83 ec 0c             	sub    $0xc,%esp
    while (*fmt) {
        if (*fmt == '%') {
            fmt++;
            switch (*fmt) {
            case 's':
                s = va_arg(ap, char*);
20000385:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputs(s);
20000388:	ff 33                	pushl  (%ebx)
2000038a:	e8 3c ff ff ff       	call   200002cb <kputs>
2000038f:	eb 17                	jmp    200003a8 <kprintf+0x7b>
                break;
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
20000391:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 10);
20000394:	51                   	push   %ecx
20000395:	51                   	push   %ecx
20000396:	6a 0a                	push   $0xa
20000398:	eb 07                	jmp    200003a1 <kprintf+0x74>
                break;
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
2000039a:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 16);
2000039d:	52                   	push   %edx
2000039e:	52                   	push   %edx
2000039f:	6a 10                	push   $0x10
200003a1:	ff 33                	pushl  (%ebx)
200003a3:	e8 4a ff ff ff       	call   200002f2 <kputn>
200003a8:	89 fb                	mov    %edi,%ebx
200003aa:	eb 34                	jmp    200003e0 <kprintf+0xb3>
                break;
            case 'c':
                c = va_arg(ap, int);
                kputc(c);
200003ac:	83 ec 0c             	sub    $0xc,%esp
            case 'p':
                n = va_arg(ap, unsigned long int);
                kputn(n, 16);
                break;
            case 'c':
                c = va_arg(ap, int);
200003af:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputc(c);
200003b2:	0f be 03             	movsbl (%ebx),%eax
200003b5:	50                   	push   %eax
200003b6:	e8 d2 fe ff ff       	call   2000028d <kputc>
200003bb:	eb eb                	jmp    200003a8 <kprintf+0x7b>
                break;
            case '%':
                kputc('%');
200003bd:	83 ec 0c             	sub    $0xc,%esp
200003c0:	6a 25                	push   $0x25
200003c2:	eb 17                	jmp    200003db <kprintf+0xae>
                break;
            case '\0':
                goto out;
            default:
                kputc('%');
200003c4:	83 ec 0c             	sub    $0xc,%esp
200003c7:	6a 25                	push   $0x25
200003c9:	e8 bf fe ff ff       	call   2000028d <kputc>
                kputc(*fmt);
200003ce:	58                   	pop    %eax
200003cf:	0f be 06             	movsbl (%esi),%eax
200003d2:	eb 06                	jmp    200003da <kprintf+0xad>
                break;
            }
        } else {
            kputc(*fmt);
200003d4:	83 ec 0c             	sub    $0xc,%esp
200003d7:	0f be c0             	movsbl %al,%eax
200003da:	50                   	push   %eax
200003db:	e8 ad fe ff ff       	call   2000028d <kputc>
200003e0:	83 c4 10             	add    $0x10,%esp
        }

        fmt++;
200003e3:	46                   	inc    %esi
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
    while (*fmt) {
200003e4:	8a 06                	mov    (%esi),%al
200003e6:	84 c0                	test   %al,%al
200003e8:	0f 85 5d ff ff ff    	jne    2000034b <kprintf+0x1e>

    out:
    va_end(ap);

    return kprintf_res;
}
200003ee:	a1 00 30 00 20       	mov    0x20003000,%eax
200003f3:	8d 65 f4             	lea    -0xc(%ebp),%esp
200003f6:	5b                   	pop    %ebx
200003f7:	5e                   	pop    %esi
200003f8:	5f                   	pop    %edi
200003f9:	5d                   	pop    %ebp
200003fa:	c3                   	ret    
	...

200003fc <rpc_register_handler>:
	syscall(&state);

	return state.eax;
}

int rpc_register_handler(int(*fptr)(void*)) {
200003fc:	55                   	push   %ebp
200003fd:	31 c0                	xor    %eax,%eax
200003ff:	89 e5                	mov    %esp,%ebp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		if(rpcHandlers[i] == (int(*)(void*))0) {
20000401:	83 3c 85 04 30 00 20 	cmpl   $0x0,0x20003004(,%eax,4)
20000408:	00 
20000409:	75 0c                	jne    20000417 <rpc_register_handler+0x1b>
			rpcHandlers[i] = fptr;
2000040b:	8b 55 08             	mov    0x8(%ebp),%edx
2000040e:	89 14 85 04 30 00 20 	mov    %edx,0x20003004(,%eax,4)
			return i;
20000415:	eb 0b                	jmp    20000422 <rpc_register_handler+0x26>

	return state.eax;
}

int rpc_register_handler(int(*fptr)(void*)) {
	for(int i = 0; i < RPC_HANDLERS; i++) {
20000417:	40                   	inc    %eax
20000418:	3d 00 04 00 00       	cmp    $0x400,%eax
2000041d:	75 e2                	jne    20000401 <rpc_register_handler+0x5>
2000041f:	83 c8 ff             	or     $0xffffffff,%eax
			rpcHandlers[i] = fptr;
			return i;
		}
	}
	return -1;
}
20000422:	5d                   	pop    %ebp
20000423:	c3                   	ret    

20000424 <rpc_check_future>:
	*rpcID = state.ebx;
	return (void*) state.eax;
}


int rpc_check_future(FUTURE fut) {
20000424:	55                   	push   %ebp
20000425:	89 e5                	mov    %esp,%ebp
20000427:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
2000042a:	8b 45 08             	mov    0x8(%ebp),%eax
2000042d:	c7 45 e0 03 02 00 00 	movl   $0x203,-0x20(%ebp)
20000434:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000437:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000043a:	50                   	push   %eax
int rpc_check_future(FUTURE fut) {
	struct regstate state = {
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
2000043b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000442:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000449:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000450:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000457:	e8 d4 fd ff ff       	call   20000230 <syscall>

	return state.eax;
}
2000045c:	8b 45 e0             	mov    -0x20(%ebp),%eax
2000045f:	c9                   	leave  
20000460:	c3                   	ret    

20000461 <rpc_map>:
			.esi = 0, .edi = 0 };

	syscall(&state);
}

void* rpc_map(uint32_t* rpcID) {
20000461:	55                   	push   %ebp
20000462:	89 e5                	mov    %esp,%ebp
20000464:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };

	syscall(&state);
20000467:	8d 45 e0             	lea    -0x20(%ebp),%eax
void* rpc_map(uint32_t* rpcID) {
	struct regstate state = {
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
2000046a:	c7 45 e0 00 02 00 00 	movl   $0x200,-0x20(%ebp)

	syscall(&state);
20000471:	50                   	push   %eax
void* rpc_map(uint32_t* rpcID) {
	struct regstate state = {
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000472:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
20000479:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000480:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000487:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000048e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000495:	e8 96 fd ff ff       	call   20000230 <syscall>

	*rpcID = state.ebx;
2000049a:	8b 45 08             	mov    0x8(%ebp),%eax
2000049d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
200004a0:	89 10                	mov    %edx,(%eax)
	return (void*) state.eax;
}
200004a2:	8b 45 e0             	mov    -0x20(%ebp),%eax
200004a5:	c9                   	leave  
200004a6:	c3                   	ret    

200004a7 <rpc_init>:
	syscall(&state);

	while(1);
}

void rpc_init() {
200004a7:	55                   	push   %ebp
200004a8:	31 c0                	xor    %eax,%eax
200004aa:	89 e5                	mov    %esp,%ebp
200004ac:	57                   	push   %edi
200004ad:	56                   	push   %esi
200004ae:	83 ec 20             	sub    $0x20,%esp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		rpcHandlers[i] = (int(*)(void*))0;
200004b1:	c7 04 85 04 30 00 20 	movl   $0x0,0x20003004(,%eax,4)
200004b8:	00 00 00 00 

	while(1);
}

void rpc_init() {
	for(int i = 0; i < RPC_HANDLERS; i++) {
200004bc:	40                   	inc    %eax
200004bd:	3d 00 04 00 00       	cmp    $0x400,%eax
200004c2:	75 ed                	jne    200004b1 <rpc_init+0xa>

	struct regstate state = {
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200004c4:	8d 7d e0             	lea    -0x20(%ebp),%edi
200004c7:	be 2c 20 00 20       	mov    $0x2000202c,%esi
200004cc:	b9 06 00 00 00       	mov    $0x6,%ecx

	syscall(&state);
200004d1:	83 ec 0c             	sub    $0xc,%esp

	struct regstate state = {
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200004d4:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

	syscall(&state);
200004d6:	8d 45 e0             	lea    -0x20(%ebp),%eax
200004d9:	50                   	push   %eax
200004da:	e8 51 fd ff ff       	call   20000230 <syscall>
200004df:	83 c4 10             	add    $0x10,%esp
}
200004e2:	8d 65 f8             	lea    -0x8(%ebp),%esp
200004e5:	5e                   	pop    %esi
200004e6:	5f                   	pop    %edi
200004e7:	5d                   	pop    %ebp
200004e8:	c3                   	ret    

200004e9 <rpc_return>:

#define RPC_HANDLERS 1024

static int(*rpcHandlers[RPC_HANDLERS])(void*);

void rpc_return(int returnCode) {
200004e9:	55                   	push   %ebp
200004ea:	89 e5                	mov    %esp,%ebp
200004ec:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
200004ef:	8b 45 08             	mov    0x8(%ebp),%eax
200004f2:	c7 45 e0 01 02 00 00 	movl   $0x201,-0x20(%ebp)
200004f9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200004fc:	8d 45 e0             	lea    -0x20(%ebp),%eax
200004ff:	50                   	push   %eax
void rpc_return(int returnCode) {
	struct regstate state = {
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0, .edx = 0,
			.esi = 0, .edi = 0 };
20000500:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000507:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
2000050e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000515:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
2000051c:	e8 0f fd ff ff       	call   20000230 <syscall>
20000521:	83 c4 10             	add    $0x10,%esp
20000524:	eb fe                	jmp    20000524 <rpc_return+0x3b>

20000526 <rpc_handler>:
		}
	}
	return -1;
}

void rpc_handler() {
20000526:	55                   	push   %ebp
20000527:	89 e5                	mov    %esp,%ebp
20000529:	53                   	push   %ebx
2000052a:	83 ec 20             	sub    $0x20,%esp
	uint32_t rpcID;
	void* rpcData = rpc_map(&rpcID);
2000052d:	8d 45 f4             	lea    -0xc(%ebp),%eax
20000530:	50                   	push   %eax
20000531:	e8 2b ff ff ff       	call   20000461 <rpc_map>

	kprintf("HANDLED RPC!\n");
20000536:	c7 04 24 98 20 00 20 	movl   $0x20002098,(%esp)
	return -1;
}

void rpc_handler() {
	uint32_t rpcID;
	void* rpcData = rpc_map(&rpcID);
2000053d:	89 c3                	mov    %eax,%ebx

	kprintf("HANDLED RPC!\n");
2000053f:	e8 e9 fd ff ff       	call   2000032d <kprintf>

	int returnValue = -1;

	if(rpcID < RPC_HANDLERS && rpcHandlers[rpcID] != 0) {
20000544:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000547:	83 c4 10             	add    $0x10,%esp
2000054a:	3d ff 03 00 00       	cmp    $0x3ff,%eax
2000054f:	77 16                	ja     20000567 <rpc_handler+0x41>
20000551:	8b 04 85 04 30 00 20 	mov    0x20003004(,%eax,4),%eax
20000558:	85 c0                	test   %eax,%eax
2000055a:	74 0b                	je     20000567 <rpc_handler+0x41>
		returnValue = rpcHandlers[rpcID](rpcData);
2000055c:	83 ec 0c             	sub    $0xc,%esp
2000055f:	53                   	push   %ebx
20000560:	ff d0                	call   *%eax
20000562:	83 c4 10             	add    $0x10,%esp
20000565:	eb 03                	jmp    2000056a <rpc_handler+0x44>
20000567:	83 c8 ff             	or     $0xffffffff,%eax
	}

	rpc_return(returnValue);
2000056a:	83 ec 0c             	sub    $0xc,%esp
2000056d:	50                   	push   %eax
2000056e:	e8 76 ff ff ff       	call   200004e9 <rpc_return>
20000573:	83 c4 10             	add    $0x10,%esp
}
20000576:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000579:	c9                   	leave  
2000057a:	c3                   	ret    
	...

2000057c <register_driver>:
#include "driver.h"
#include "syscall.h"


int register_driver(int dOpenID, int dCloseID, int dRemoveID, int dReadID, int dWriteID) {
2000057c:	55                   	push   %ebp
2000057d:	89 e5                	mov    %esp,%ebp
2000057f:	83 ec 34             	sub    $0x34,%esp
	struct regstate state = {
			.eax = 0x300,
			.ebx = dOpenID,
			.ecx = dCloseID, .edx = dRemoveID,
			.esi = dReadID,  .edi = dWriteID };
20000582:	8b 45 08             	mov    0x8(%ebp),%eax
20000585:	c7 45 e0 00 03 00 00 	movl   $0x300,-0x20(%ebp)
2000058c:	89 45 e4             	mov    %eax,-0x1c(%ebp)
2000058f:	8b 45 0c             	mov    0xc(%ebp),%eax
20000592:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000595:	8b 45 10             	mov    0x10(%ebp),%eax
20000598:	89 45 ec             	mov    %eax,-0x14(%ebp)
2000059b:	8b 45 14             	mov    0x14(%ebp),%eax
2000059e:	89 45 f0             	mov    %eax,-0x10(%ebp)
200005a1:	8b 45 18             	mov    0x18(%ebp),%eax
200005a4:	89 45 f4             	mov    %eax,-0xc(%ebp)

	syscall(&state);
200005a7:	8d 45 e0             	lea    -0x20(%ebp),%eax
200005aa:	50                   	push   %eax
200005ab:	e8 80 fc ff ff       	call   20000230 <syscall>

	return state.eax;
}
200005b0:	8b 45 e0             	mov    -0x20(%ebp),%eax
200005b3:	c9                   	leave  
200005b4:	c3                   	ret    
