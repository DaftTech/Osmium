
../../initrfs/drivers/fifo:     file format elf32-i386
../../initrfs/drivers/fifo
architecture: i386, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x200006d8

Program Header:
    LOAD off    0x00001000 vaddr 0x20000000 paddr 0x20000000 align 2**12
         filesz 0x00001195 memsz 0x00001195 flags r-x
    LOAD off    0x00003000 vaddr 0x20002000 paddr 0x20002000 align 2**12
         filesz 0x000010f8 memsz 0x00043014 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001195  20000000  20000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000005  20002000  20002000  00003000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .rodata       00000094  20003000  20003000  00004000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .rodata.str1.1 00000064  20003094  20003094  00004094  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .bss          00041014  20004000  20004000  000040f8  2**5
                  ALLOC
  5 .stab         00004050  00000000  00000000  000040f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  6 .comment      00000090  00000000  00000000  00008148  2**0
                  CONTENTS, READONLY
  7 .stabstr      00001a58  00000000  00000000  000081d8  2**0
                  CONTENTS, READONLY, DEBUGGING
SYMBOL TABLE:
20000000 l    d  .text	00000000 .text
20002000 l    d  .data	00000000 .data
20003000 l    d  .rodata	00000000 .rodata
20003094 l    d  .rodata.str1.1	00000000 .rodata.str1.1
20004000 l    d  .bss	00000000 .bss
00000000 l    d  .stab	00000000 .stab
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .stabstr	00000000 .stabstr
00000000 l    df *ABS*	00000000 main.c
20004000 l     O .bss	00040000 files
20002000 l     O .data	00000004 ownDriverID
00000000 l    df *ABS*	00000000 process.c
00000000 l    df *ABS*	00000000 syscall.c
00000000 l    df *ABS*	00000000 console.c
20002004 l     O .data	00000001 color
20044000 l     O .bss	00000004 kprintf_res
00000000 l    df *ABS*	00000000 rpc.c
20044004 l     O .bss	00001000 rpcHandlers
2000307c l     O .rodata	00000018 C.2.870
00000000 l    df *ABS*	00000000 driver.c
00000000 l    df *ABS*	00000000 memory.c
00000000 l    df *ABS*	00000000 stdlib.c
20000f8e l     F .text	00000069 pop_unused_node
20000bbf g     F .text	0000003e inb
20000d2d g     F .text	00000039 register_driver
2000075d g     F .text	0000003e kputc
20000b07 g     F .text	0000003c fModify
20000700 g     F .text	00000050 syscall
2000097f g     F .text	00000042 rpc_init
20000750 g     F .text	0000000d setclr
20000d84 g     F .text	00000026 memcpy
2000012e g     F .text	00000167 dRead
20000e2e g     F .text	00000057 pcalloc
20000df1 g     F .text	0000003d pfree
20000ff7 g     F .text	00000108 malloc
20000cb6 g     F .text	0000003c register_irq_rpc
2000050a g     F .text	00000017 execn
20000521 g     F .text	0000003c thread
200003e8 g     F .text	000000ba createDriver
200008f4 g     F .text	0000003d rpc_check_future
20000931 g     F .text	0000004e rpc_map
2004500c g     O .bss	00000004 first_free
20000000 g     F .text	0000002a dModify
200008cc g     F .text	00000028 rpc_register_handler
20000b81 g     F .text	0000003e inw
20045010 g     O .bss	00000004 malloced
20001161 g     F .text	00000034 calloc
2000002a g     F .text	00000104 dCall
2000055d g     F .text	0000003e getargsptr
20000a90 g     F .text	0000003c fWrite
200004d0 g     F .text	0000003a exec
200005d8 g     F .text	000000ec execp
200006d8 g     F .text	00000026 _start
20000b43 g     F .text	0000003e inl
200010ff g     F .text	00000062 realloc
20000daa g     F .text	00000047 memcmp
20000e85 g     F .text	0000000f palloc
20000c78 g     F .text	0000003e outb
20045004 g     O .bss	00000004 first_unused
20000d68 g     F .text	0000001c memset
200004a2 g     F .text	0000002c main
20000a0a g     F .text	0000004a rpc_handler
200007c2 g     F .text	0000003b kputn
20000acc g     F .text	0000003b fCall
2000079b g     F .text	00000027 kputs
20045008 g     O .bss	00000004 first_used
20000c3a g     F .text	0000003e outw
200009c1 g     F .text	00000049 rpc_return
20000bfd g     F .text	0000003d outl
200007fd g     F .text	000000ce kprintf
2000059b g     F .text	0000003d exit
200006c4 g     F .text	00000014 execpn
20000a54 g     F .text	0000003c fRead
20000295 g     F .text	00000153 dWrite
20000cf2 g     F .text	0000003b register_path
20000e94 g     F .text	000000fa free



Disassembly of section .text:

20000000 <dModify>:
};

static struct file* files[FIFO_MAX_FILE_COUNT];
static ownDriverID = -1;

int dModify(int resourceID, void* data) {
20000000:	55                   	push   %ebp
20000001:	89 e5                	mov    %esp,%ebp
20000003:	83 ec 10             	sub    $0x10,%esp
	struct driver_data* drvData = data;
20000006:	8b 45 0c             	mov    0xc(%ebp),%eax
20000009:	89 45 fc             	mov    %eax,-0x4(%ebp)
	if(drvData == 0) return 0;
2000000c:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
20000010:	75 07                	jne    20000019 <dModify+0x19>
20000012:	b8 00 00 00 00       	mov    $0x0,%eax
20000017:	eb 0f                	jmp    20000028 <dModify+0x28>

	drvData->result = E_ERROR;
20000019:	8b 45 fc             	mov    -0x4(%ebp),%eax
2000001c:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)
	return 0;
20000023:	b8 00 00 00 00       	mov    $0x0,%eax
}
20000028:	c9                   	leave  
20000029:	c3                   	ret    

2000002a <dCall>:

int dCall(int callID, void* data) {
2000002a:	55                   	push   %ebp
2000002b:	89 e5                	mov    %esp,%ebp
2000002d:	53                   	push   %ebx
2000002e:	83 ec 14             	sub    $0x14,%esp
	struct driver_data* drvData = data;
20000031:	8b 45 0c             	mov    0xc(%ebp),%eax
20000034:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(data == 0) return 0;
20000037:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
2000003b:	75 0a                	jne    20000047 <dCall+0x1d>
2000003d:	b8 00 00 00 00       	mov    $0x0,%eax
20000042:	e9 e2 00 00 00       	jmp    20000129 <dCall+0xff>


	kprintf("Received call!\n");
20000047:	83 ec 0c             	sub    $0xc,%esp
2000004a:	68 00 30 00 20       	push   $0x20003000
2000004f:	e8 a9 07 00 00       	call   200007fd <kprintf>
20000054:	83 c4 10             	add    $0x10,%esp

	drvData->result = E_ERROR;
20000057:	8b 45 e8             	mov    -0x18(%ebp),%eax
2000005a:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)

	switch(callID) {
20000061:	8b 45 08             	mov    0x8(%ebp),%eax
20000064:	3d 00 01 00 00       	cmp    $0x100,%eax
20000069:	0f 85 b5 00 00 00    	jne    20000124 <dCall+0xfa>
	case CALL_CREATE:
		kprintf("Received FIFO Create CALL!\n");
2000006f:	83 ec 0c             	sub    $0xc,%esp
20000072:	68 10 30 00 20       	push   $0x20003010
20000077:	e8 81 07 00 00       	call   200007fd <kprintf>
2000007c:	83 c4 10             	add    $0x10,%esp
		;
		int fileID = -1;
2000007f:	c7 45 ec ff ff ff ff 	movl   $0xffffffff,-0x14(%ebp)

		for(int i = 0; i < FIFO_MAX_FILE_COUNT; i++) {
20000086:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
2000008d:	eb 35                	jmp    200000c4 <dCall+0x9a>
			if(!files[i]) {
2000008f:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000092:	8b 04 85 00 40 00 20 	mov    0x20004000(,%eax,4),%eax
20000099:	85 c0                	test   %eax,%eax
2000009b:	75 24                	jne    200000c1 <dCall+0x97>
				fileID = i;
2000009d:	8b 45 f4             	mov    -0xc(%ebp),%eax
200000a0:	89 45 ec             	mov    %eax,-0x14(%ebp)
				files[i] = calloc(1, sizeof(struct file));
200000a3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
200000a6:	83 ec 08             	sub    $0x8,%esp
200000a9:	68 e0 0e 00 00       	push   $0xee0
200000ae:	6a 01                	push   $0x1
200000b0:	e8 ac 10 00 00       	call   20001161 <calloc>
200000b5:	83 c4 10             	add    $0x10,%esp
200000b8:	89 04 9d 00 40 00 20 	mov    %eax,0x20004000(,%ebx,4)
				break;
200000bf:	eb 0c                	jmp    200000cd <dCall+0xa3>
	case CALL_CREATE:
		kprintf("Received FIFO Create CALL!\n");
		;
		int fileID = -1;

		for(int i = 0; i < FIFO_MAX_FILE_COUNT; i++) {
200000c1:	ff 45 f4             	incl   -0xc(%ebp)
200000c4:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
200000cb:	7e c2                	jle    2000008f <dCall+0x65>
				files[i] = calloc(1, sizeof(struct file));
				break;
			}
		}

		if(fileID == -1) return 0;
200000cd:	83 7d ec ff          	cmpl   $0xffffffff,-0x14(%ebp)
200000d1:	75 07                	jne    200000da <dCall+0xb0>
200000d3:	b8 00 00 00 00       	mov    $0x0,%eax
200000d8:	eb 4f                	jmp    20000129 <dCall+0xff>
		kprintf("Created FIFO %s...\n", drvData->data);
200000da:	8b 45 e8             	mov    -0x18(%ebp),%eax
200000dd:	83 c0 14             	add    $0x14,%eax
200000e0:	83 ec 08             	sub    $0x8,%esp
200000e3:	50                   	push   %eax
200000e4:	68 2c 30 00 20       	push   $0x2000302c
200000e9:	e8 0f 07 00 00       	call   200007fd <kprintf>
200000ee:	83 c4 10             	add    $0x10,%esp
		int r = register_path(drvData->data, ownDriverID, fileID);
200000f1:	8b 15 00 20 00 20    	mov    0x20002000,%edx
200000f7:	8b 45 e8             	mov    -0x18(%ebp),%eax
200000fa:	83 c0 14             	add    $0x14,%eax
200000fd:	83 ec 04             	sub    $0x4,%esp
20000100:	ff 75 ec             	pushl  -0x14(%ebp)
20000103:	52                   	push   %edx
20000104:	50                   	push   %eax
20000105:	e8 e8 0b 00 00       	call   20000cf2 <register_path>
2000010a:	83 c4 10             	add    $0x10,%esp
2000010d:	89 45 f0             	mov    %eax,-0x10(%ebp)
		drvData->result = r ? E_ERROR : S_OK;
20000110:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
20000114:	0f 95 c0             	setne  %al
20000117:	ba 00 00 00 00       	mov    $0x0,%edx
2000011c:	88 c2                	mov    %al,%dl
2000011e:	8b 45 e8             	mov    -0x18(%ebp),%eax
20000121:	89 50 10             	mov    %edx,0x10(%eax)

	default:
		break;
	}

	return 0;
20000124:	b8 00 00 00 00       	mov    $0x0,%eax
}
20000129:	8b 5d fc             	mov    -0x4(%ebp),%ebx
2000012c:	c9                   	leave  
2000012d:	c3                   	ret    

2000012e <dRead>:

int dRead(int resourceID, void* data) {
2000012e:	55                   	push   %ebp
2000012f:	89 e5                	mov    %esp,%ebp
20000131:	53                   	push   %ebx
20000132:	83 ec 24             	sub    $0x24,%esp
	struct driver_data* drvData = data;
20000135:	8b 45 0c             	mov    0xc(%ebp),%eax
20000138:	89 45 dc             	mov    %eax,-0x24(%ebp)
	drvData->result = E_ERROR;
2000013b:	8b 45 dc             	mov    -0x24(%ebp),%eax
2000013e:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)

	struct file* file = files[resourceID];
20000145:	8b 45 08             	mov    0x8(%ebp),%eax
20000148:	8b 04 85 00 40 00 20 	mov    0x20004000(,%eax,4),%eax
2000014f:	89 45 e0             	mov    %eax,-0x20(%ebp)

	int available = ((file->writePos + BUFFER_SIZE) - file->readPos) % BUFFER_SIZE;
20000152:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000155:	8b 10                	mov    (%eax),%edx
20000157:	8b 45 e0             	mov    -0x20(%ebp),%eax
2000015a:	8b 40 04             	mov    0x4(%eax),%eax
2000015d:	89 d1                	mov    %edx,%ecx
2000015f:	29 c1                	sub    %eax,%ecx
20000161:	89 c8                	mov    %ecx,%eax
20000163:	8d 88 d8 0e 00 00    	lea    0xed8(%eax),%ecx
20000169:	b8 35 3a fc 44       	mov    $0x44fc3a35,%eax
2000016e:	f7 e1                	mul    %ecx
20000170:	c1 ea 0a             	shr    $0xa,%edx
20000173:	89 d0                	mov    %edx,%eax
20000175:	01 c0                	add    %eax,%eax
20000177:	01 d0                	add    %edx,%eax
20000179:	c1 e0 05             	shl    $0x5,%eax
2000017c:	29 d0                	sub    %edx,%eax
2000017e:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
20000185:	01 d0                	add    %edx,%eax
20000187:	c1 e0 03             	shl    $0x3,%eax
2000018a:	89 ca                	mov    %ecx,%edx
2000018c:	29 c2                	sub    %eax,%edx
2000018e:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int toRead = drvData->length;
20000191:	8b 45 dc             	mov    -0x24(%ebp),%eax
20000194:	8b 40 08             	mov    0x8(%eax),%eax
20000197:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if(toRead > BUFFER_SIZE) return 0;
2000019a:	81 7d e8 d8 0e 00 00 	cmpl   $0xed8,-0x18(%ebp)
200001a1:	7e 0a                	jle    200001ad <dRead+0x7f>
200001a3:	b8 00 00 00 00       	mov    $0x0,%eax
200001a8:	e9 e3 00 00 00       	jmp    20000290 <dRead+0x162>
	if(toRead > available) toRead = available;
200001ad:	8b 45 e8             	mov    -0x18(%ebp),%eax
200001b0:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
200001b3:	7e 06                	jle    200001bb <dRead+0x8d>
200001b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
200001b8:	89 45 e8             	mov    %eax,-0x18(%ebp)

	int endPos = file->readPos + toRead;
200001bb:	8b 45 e0             	mov    -0x20(%ebp),%eax
200001be:	8b 50 04             	mov    0x4(%eax),%edx
200001c1:	8b 45 e8             	mov    -0x18(%ebp),%eax
200001c4:	8d 04 02             	lea    (%edx,%eax,1),%eax
200001c7:	89 45 ec             	mov    %eax,-0x14(%ebp)

	int readA = toRead;
200001ca:	8b 45 e8             	mov    -0x18(%ebp),%eax
200001cd:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int readB = 0;
200001d0:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if(endPos >= BUFFER_SIZE) {
200001d7:	81 7d ec d7 0e 00 00 	cmpl   $0xed7,-0x14(%ebp)
200001de:	7e 25                	jle    20000205 <dRead+0xd7>
		readA = BUFFER_SIZE - file->readPos;
200001e0:	8b 45 e0             	mov    -0x20(%ebp),%eax
200001e3:	8b 40 04             	mov    0x4(%eax),%eax
200001e6:	ba d8 0e 00 00       	mov    $0xed8,%edx
200001eb:	89 d1                	mov    %edx,%ecx
200001ed:	29 c1                	sub    %eax,%ecx
200001ef:	89 c8                	mov    %ecx,%eax
200001f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
		endPos = readB = endPos - BUFFER_SIZE;
200001f4:	8b 45 ec             	mov    -0x14(%ebp),%eax
200001f7:	2d d8 0e 00 00       	sub    $0xed8,%eax
200001fc:	89 45 f4             	mov    %eax,-0xc(%ebp)
200001ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000202:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	memset(drvData->data, 0, MAX_IO_BUFFER);
20000205:	8b 45 dc             	mov    -0x24(%ebp),%eax
20000208:	83 c0 14             	add    $0x14,%eax
2000020b:	83 ec 04             	sub    $0x4,%esp
2000020e:	68 d8 0e 00 00       	push   $0xed8
20000213:	6a 00                	push   $0x0
20000215:	50                   	push   %eax
20000216:	e8 4d 0b 00 00       	call   20000d68 <memset>
2000021b:	83 c4 10             	add    $0x10,%esp
	memcpy(drvData->data, (file->content + file->readPos), readA);
2000021e:	8b 45 f0             	mov    -0x10(%ebp),%eax
20000221:	8b 55 e0             	mov    -0x20(%ebp),%edx
20000224:	8d 4a 08             	lea    0x8(%edx),%ecx
20000227:	8b 55 e0             	mov    -0x20(%ebp),%edx
2000022a:	8b 52 04             	mov    0x4(%edx),%edx
2000022d:	01 d1                	add    %edx,%ecx
2000022f:	8b 55 dc             	mov    -0x24(%ebp),%edx
20000232:	83 c2 14             	add    $0x14,%edx
20000235:	83 ec 04             	sub    $0x4,%esp
20000238:	50                   	push   %eax
20000239:	51                   	push   %ecx
2000023a:	52                   	push   %edx
2000023b:	e8 44 0b 00 00       	call   20000d84 <memcpy>
20000240:	83 c4 10             	add    $0x10,%esp
	if(readB) memcpy(drvData->data + file->readPos, file->content, readB);
20000243:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
20000247:	74 26                	je     2000026f <dRead+0x141>
20000249:	8b 45 f4             	mov    -0xc(%ebp),%eax
2000024c:	8b 55 e0             	mov    -0x20(%ebp),%edx
2000024f:	8d 4a 08             	lea    0x8(%edx),%ecx
20000252:	8b 55 dc             	mov    -0x24(%ebp),%edx
20000255:	8d 5a 14             	lea    0x14(%edx),%ebx
20000258:	8b 55 e0             	mov    -0x20(%ebp),%edx
2000025b:	8b 52 04             	mov    0x4(%edx),%edx
2000025e:	8d 14 13             	lea    (%ebx,%edx,1),%edx
20000261:	83 ec 04             	sub    $0x4,%esp
20000264:	50                   	push   %eax
20000265:	51                   	push   %ecx
20000266:	52                   	push   %edx
20000267:	e8 18 0b 00 00       	call   20000d84 <memcpy>
2000026c:	83 c4 10             	add    $0x10,%esp

	file->readPos = endPos;
2000026f:	8b 55 ec             	mov    -0x14(%ebp),%edx
20000272:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000275:	89 50 04             	mov    %edx,0x4(%eax)
	drvData->bytesDone = toRead;
20000278:	8b 55 e8             	mov    -0x18(%ebp),%edx
2000027b:	8b 45 dc             	mov    -0x24(%ebp),%eax
2000027e:	89 50 0c             	mov    %edx,0xc(%eax)

	drvData->result = S_OK;
20000281:	8b 45 dc             	mov    -0x24(%ebp),%eax
20000284:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	return 0;
2000028b:	b8 00 00 00 00       	mov    $0x0,%eax
}
20000290:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000293:	c9                   	leave  
20000294:	c3                   	ret    

20000295 <dWrite>:

int dWrite(int resourceID, void* data) {
20000295:	55                   	push   %ebp
20000296:	89 e5                	mov    %esp,%ebp
20000298:	53                   	push   %ebx
20000299:	83 ec 24             	sub    $0x24,%esp
	struct driver_data* drvData = data;
2000029c:	8b 45 0c             	mov    0xc(%ebp),%eax
2000029f:	89 45 dc             	mov    %eax,-0x24(%ebp)
	drvData->result = E_ERROR;
200002a2:	8b 45 dc             	mov    -0x24(%ebp),%eax
200002a5:	c7 40 10 01 00 00 00 	movl   $0x1,0x10(%eax)

	struct file* file = files[resourceID];
200002ac:	8b 45 08             	mov    0x8(%ebp),%eax
200002af:	8b 04 85 00 40 00 20 	mov    0x20004000(,%eax,4),%eax
200002b6:	89 45 e0             	mov    %eax,-0x20(%ebp)

	int toWrite = drvData->length;
200002b9:	8b 45 dc             	mov    -0x24(%ebp),%eax
200002bc:	8b 40 08             	mov    0x8(%eax),%eax
200002bf:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	if(toWrite > BUFFER_SIZE) return 0;
200002c2:	81 7d e4 d8 0e 00 00 	cmpl   $0xed8,-0x1c(%ebp)
200002c9:	7e 0a                	jle    200002d5 <dWrite+0x40>
200002cb:	b8 00 00 00 00       	mov    $0x0,%eax
200002d0:	e9 0e 01 00 00       	jmp    200003e3 <dWrite+0x14e>
	uint32_t writable = BUFFER_SIZE - (((file->writePos + BUFFER_SIZE) - file->readPos) % BUFFER_SIZE) - 1;
200002d5:	8b 45 e0             	mov    -0x20(%ebp),%eax
200002d8:	8b 10                	mov    (%eax),%edx
200002da:	8b 45 e0             	mov    -0x20(%ebp),%eax
200002dd:	8b 40 04             	mov    0x4(%eax),%eax
200002e0:	89 d1                	mov    %edx,%ecx
200002e2:	29 c1                	sub    %eax,%ecx
200002e4:	89 c8                	mov    %ecx,%eax
200002e6:	8d 88 d8 0e 00 00    	lea    0xed8(%eax),%ecx
200002ec:	b8 35 3a fc 44       	mov    $0x44fc3a35,%eax
200002f1:	f7 e1                	mul    %ecx
200002f3:	c1 ea 0a             	shr    $0xa,%edx
200002f6:	89 d0                	mov    %edx,%eax
200002f8:	01 c0                	add    %eax,%eax
200002fa:	01 d0                	add    %edx,%eax
200002fc:	c1 e0 05             	shl    $0x5,%eax
200002ff:	29 d0                	sub    %edx,%eax
20000301:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
20000308:	01 d0                	add    %edx,%eax
2000030a:	c1 e0 03             	shl    $0x3,%eax
2000030d:	89 ca                	mov    %ecx,%edx
2000030f:	29 c2                	sub    %eax,%edx
20000311:	b8 d7 0e 00 00       	mov    $0xed7,%eax
20000316:	29 d0                	sub    %edx,%eax
20000318:	89 45 e8             	mov    %eax,-0x18(%ebp)
	if(toWrite > writable) {
2000031b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
2000031e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
20000321:	76 14                	jbe    20000337 <dWrite+0xa2>
		drvData->result = E_USER0;
20000323:	8b 45 dc             	mov    -0x24(%ebp),%eax
20000326:	c7 40 10 03 00 00 00 	movl   $0x3,0x10(%eax)
		return 0;
2000032d:	b8 00 00 00 00       	mov    $0x0,%eax
20000332:	e9 ac 00 00 00       	jmp    200003e3 <dWrite+0x14e>
	}

	drvData->result = S_OK;
20000337:	8b 45 dc             	mov    -0x24(%ebp),%eax
2000033a:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

	int endPos = toWrite + file->writePos;
20000341:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000344:	8b 10                	mov    (%eax),%edx
20000346:	8b 45 e4             	mov    -0x1c(%ebp),%eax
20000349:	8d 04 02             	lea    (%edx,%eax,1),%eax
2000034c:	89 45 ec             	mov    %eax,-0x14(%ebp)

	int writeA = toWrite;
2000034f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
20000352:	89 45 f0             	mov    %eax,-0x10(%ebp)
	int writeB = 0;
20000355:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if(endPos >= BUFFER_SIZE) {
2000035c:	81 7d ec d7 0e 00 00 	cmpl   $0xed7,-0x14(%ebp)
20000363:	7e 24                	jle    20000389 <dWrite+0xf4>
		writeA = BUFFER_SIZE - file->writePos;
20000365:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000368:	8b 00                	mov    (%eax),%eax
2000036a:	ba d8 0e 00 00       	mov    $0xed8,%edx
2000036f:	89 d1                	mov    %edx,%ecx
20000371:	29 c1                	sub    %eax,%ecx
20000373:	89 c8                	mov    %ecx,%eax
20000375:	89 45 f0             	mov    %eax,-0x10(%ebp)
		endPos = writeB = endPos - BUFFER_SIZE;
20000378:	8b 45 ec             	mov    -0x14(%ebp),%eax
2000037b:	2d d8 0e 00 00       	sub    $0xed8,%eax
20000380:	89 45 f4             	mov    %eax,-0xc(%ebp)
20000383:	8b 45 f4             	mov    -0xc(%ebp),%eax
20000386:	89 45 ec             	mov    %eax,-0x14(%ebp)
	}

	memcpy(file->content + file->writePos, drvData->data, writeA);
20000389:	8b 45 f0             	mov    -0x10(%ebp),%eax
2000038c:	8b 55 dc             	mov    -0x24(%ebp),%edx
2000038f:	8d 4a 14             	lea    0x14(%edx),%ecx
20000392:	8b 55 e0             	mov    -0x20(%ebp),%edx
20000395:	8d 5a 08             	lea    0x8(%edx),%ebx
20000398:	8b 55 e0             	mov    -0x20(%ebp),%edx
2000039b:	8b 12                	mov    (%edx),%edx
2000039d:	8d 14 13             	lea    (%ebx,%edx,1),%edx
200003a0:	83 ec 04             	sub    $0x4,%esp
200003a3:	50                   	push   %eax
200003a4:	51                   	push   %ecx
200003a5:	52                   	push   %edx
200003a6:	e8 d9 09 00 00       	call   20000d84 <memcpy>
200003ab:	83 c4 10             	add    $0x10,%esp
	if(writeB) memcpy(file->content, drvData->data + writeA, writeB);
200003ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
200003b2:	74 22                	je     200003d6 <dWrite+0x141>
200003b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
200003b7:	8b 55 dc             	mov    -0x24(%ebp),%edx
200003ba:	8d 4a 14             	lea    0x14(%edx),%ecx
200003bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
200003c0:	01 d1                	add    %edx,%ecx
200003c2:	8b 55 e0             	mov    -0x20(%ebp),%edx
200003c5:	83 c2 08             	add    $0x8,%edx
200003c8:	83 ec 04             	sub    $0x4,%esp
200003cb:	50                   	push   %eax
200003cc:	51                   	push   %ecx
200003cd:	52                   	push   %edx
200003ce:	e8 b1 09 00 00       	call   20000d84 <memcpy>
200003d3:	83 c4 10             	add    $0x10,%esp

	file->writePos = endPos;
200003d6:	8b 55 ec             	mov    -0x14(%ebp),%edx
200003d9:	8b 45 e0             	mov    -0x20(%ebp),%eax
200003dc:	89 10                	mov    %edx,(%eax)

	return 0;
200003de:	b8 00 00 00 00       	mov    $0x0,%eax
}
200003e3:	8b 5d fc             	mov    -0x4(%ebp),%ebx
200003e6:	c9                   	leave  
200003e7:	c3                   	ret    

200003e8 <createDriver>:

void createDriver() {
200003e8:	55                   	push   %ebp
200003e9:	89 e5                	mov    %esp,%ebp
200003eb:	83 ec 28             	sub    $0x28,%esp
	for(int i = 0; i < FIFO_MAX_FILE_COUNT; i++) {
200003ee:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
200003f5:	eb 11                	jmp    20000408 <createDriver+0x20>
		files[i] = 0;
200003f7:	8b 45 f4             	mov    -0xc(%ebp),%eax
200003fa:	c7 04 85 00 40 00 20 	movl   $0x0,0x20004000(,%eax,4)
20000401:	00 00 00 00 

	return 0;
}

void createDriver() {
	for(int i = 0; i < FIFO_MAX_FILE_COUNT; i++) {
20000405:	ff 45 f4             	incl   -0xc(%ebp)
20000408:	81 7d f4 ff ff 00 00 	cmpl   $0xffff,-0xc(%ebp)
2000040f:	7e e6                	jle    200003f7 <createDriver+0xf>
		files[i] = 0;
	}

	int dModifyID = rpc_register_handler(&dModify);
20000411:	83 ec 0c             	sub    $0xc,%esp
20000414:	68 00 00 00 20       	push   $0x20000000
20000419:	e8 ae 04 00 00       	call   200008cc <rpc_register_handler>
2000041e:	83 c4 10             	add    $0x10,%esp
20000421:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	int dCallID = rpc_register_handler(&dCall);
20000424:	83 ec 0c             	sub    $0xc,%esp
20000427:	68 2a 00 00 20       	push   $0x2000002a
2000042c:	e8 9b 04 00 00       	call   200008cc <rpc_register_handler>
20000431:	83 c4 10             	add    $0x10,%esp
20000434:	89 45 e8             	mov    %eax,-0x18(%ebp)
	int dReadID = rpc_register_handler(&dRead);
20000437:	83 ec 0c             	sub    $0xc,%esp
2000043a:	68 2e 01 00 20       	push   $0x2000012e
2000043f:	e8 88 04 00 00       	call   200008cc <rpc_register_handler>
20000444:	83 c4 10             	add    $0x10,%esp
20000447:	89 45 ec             	mov    %eax,-0x14(%ebp)
	int dWriteID = rpc_register_handler(&dWrite);
2000044a:	83 ec 0c             	sub    $0xc,%esp
2000044d:	68 95 02 00 20       	push   $0x20000295
20000452:	e8 75 04 00 00       	call   200008cc <rpc_register_handler>
20000457:	83 c4 10             	add    $0x10,%esp
2000045a:	89 45 f0             	mov    %eax,-0x10(%ebp)

	ownDriverID = register_driver(dModifyID, dCallID, dReadID, dWriteID, "fifo");
2000045d:	83 ec 0c             	sub    $0xc,%esp
20000460:	68 40 30 00 20       	push   $0x20003040
20000465:	ff 75 f0             	pushl  -0x10(%ebp)
20000468:	ff 75 ec             	pushl  -0x14(%ebp)
2000046b:	ff 75 e8             	pushl  -0x18(%ebp)
2000046e:	ff 75 e4             	pushl  -0x1c(%ebp)
20000471:	e8 b7 08 00 00       	call   20000d2d <register_driver>
20000476:	83 c4 20             	add    $0x20,%esp
20000479:	a3 00 20 00 20       	mov    %eax,0x20002000

	kprintf("FIFO registered driver %d (%d, %d, %d, %d)\n", ownDriverID, dModifyID, dCallID, dReadID, dWriteID);
2000047e:	a1 00 20 00 20       	mov    0x20002000,%eax
20000483:	83 ec 08             	sub    $0x8,%esp
20000486:	ff 75 f0             	pushl  -0x10(%ebp)
20000489:	ff 75 ec             	pushl  -0x14(%ebp)
2000048c:	ff 75 e8             	pushl  -0x18(%ebp)
2000048f:	ff 75 e4             	pushl  -0x1c(%ebp)
20000492:	50                   	push   %eax
20000493:	68 48 30 00 20       	push   $0x20003048
20000498:	e8 60 03 00 00       	call   200007fd <kprintf>
2000049d:	83 c4 20             	add    $0x20,%esp
}
200004a0:	c9                   	leave  
200004a1:	c3                   	ret    

200004a2 <main>:

int main(void* initrfsPtr) {
200004a2:	8d 4c 24 04          	lea    0x4(%esp),%ecx
200004a6:	83 e4 f0             	and    $0xfffffff0,%esp
200004a9:	ff 71 fc             	pushl  -0x4(%ecx)
200004ac:	55                   	push   %ebp
200004ad:	89 e5                	mov    %esp,%ebp
200004af:	51                   	push   %ecx
200004b0:	83 ec 04             	sub    $0x4,%esp
	createDriver();
200004b3:	e8 30 ff ff ff       	call   200003e8 <createDriver>

	fCall("initrfs", 0, 0); //TELL init we are finished here
200004b8:	83 ec 04             	sub    $0x4,%esp
200004bb:	6a 00                	push   $0x0
200004bd:	6a 00                	push   $0x0
200004bf:	68 74 30 00 20       	push   $0x20003074
200004c4:	e8 03 06 00 00       	call   20000acc <fCall>
200004c9:	83 c4 10             	add    $0x10,%esp
	while(1); // kprintf("FIFO Main Loop\n");
200004cc:	eb fe                	jmp    200004cc <main+0x2a>
	...

200004d0 <exec>:

THREAD execn(void* elf, uint32_t elfSize) {
	return exec(elf, elfSize, 0, 0);
}

THREAD exec(void* elf, uint32_t elfSize, void* data, uint32_t dataSize) {
200004d0:	55                   	push   %ebp
200004d1:	89 e5                	mov    %esp,%ebp
200004d3:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x501,
			.ebx = (uint32_t)data,
			.ecx = (uint32_t)dataSize,
			.edx = (uint32_t)elf,
			.esi = (uint32_t)elfSize,
			.edi = 0 };
200004d6:	8b 45 10             	mov    0x10(%ebp),%eax
200004d9:	c7 45 e0 01 05 00 00 	movl   $0x501,-0x20(%ebp)
200004e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
200004e3:	8b 45 14             	mov    0x14(%ebp),%eax
200004e6:	89 45 e8             	mov    %eax,-0x18(%ebp)
200004e9:	8b 45 08             	mov    0x8(%ebp),%eax
200004ec:	89 45 ec             	mov    %eax,-0x14(%ebp)
200004ef:	8b 45 0c             	mov    0xc(%ebp),%eax
200004f2:	89 45 f0             	mov    %eax,-0x10(%ebp)

	syscall(&state);
200004f5:	8d 45 e0             	lea    -0x20(%ebp),%eax
200004f8:	50                   	push   %eax
			.eax = 0x501,
			.ebx = (uint32_t)data,
			.ecx = (uint32_t)dataSize,
			.edx = (uint32_t)elf,
			.esi = (uint32_t)elfSize,
			.edi = 0 };
200004f9:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000500:	e8 fb 01 00 00       	call   20000700 <syscall>

	return state.eax;
}
20000505:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000508:	c9                   	leave  
20000509:	c3                   	ret    

2000050a <execn>:

THREAD execpn(char* path) {
	return execp(path, 0, 0);
}

THREAD execn(void* elf, uint32_t elfSize) {
2000050a:	55                   	push   %ebp
2000050b:	89 e5                	mov    %esp,%ebp
2000050d:	83 ec 08             	sub    $0x8,%esp
	return exec(elf, elfSize, 0, 0);
20000510:	6a 00                	push   $0x0
20000512:	6a 00                	push   $0x0
20000514:	ff 75 0c             	pushl  0xc(%ebp)
20000517:	ff 75 08             	pushl  0x8(%ebp)
2000051a:	e8 b1 ff ff ff       	call   200004d0 <exec>
}
2000051f:	c9                   	leave  
20000520:	c3                   	ret    

20000521 <thread>:

	return (void*) state.eax;
}


THREAD thread(void* function, void* args) {
20000521:	55                   	push   %ebp
20000522:	89 e5                	mov    %esp,%ebp
20000524:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x500,
			.ebx = (uint32_t)function,
			.ecx = (uint32_t)args,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000527:	8b 45 08             	mov    0x8(%ebp),%eax
2000052a:	c7 45 e0 00 05 00 00 	movl   $0x500,-0x20(%ebp)
20000531:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000534:	8b 45 0c             	mov    0xc(%ebp),%eax
20000537:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
2000053a:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000053d:	50                   	push   %eax
			.eax = 0x500,
			.ebx = (uint32_t)function,
			.ecx = (uint32_t)args,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000053e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000545:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000054c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000553:	e8 a8 01 00 00       	call   20000700 <syscall>

	return state.eax;
}
20000558:	8b 45 e0             	mov    -0x20(%ebp),%eax
2000055b:	c9                   	leave  
2000055c:	c3                   	ret    

2000055d <getargsptr>:

	while (1) {
	}
}

void* getargsptr() {
2000055d:	55                   	push   %ebp
2000055e:	89 e5                	mov    %esp,%ebp
20000560:	83 ec 34             	sub    $0x34,%esp
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
20000563:	8d 45 e0             	lea    -0x20(%ebp),%eax
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000566:	c7 45 e0 02 00 00 00 	movl   $0x2,-0x20(%ebp)

	syscall(&state);
2000056d:	50                   	push   %eax
			.eax = 0x2,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000056e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
20000575:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
2000057c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000583:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000058a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000591:	e8 6a 01 00 00       	call   20000700 <syscall>

	return (void*) state.eax;
}
20000596:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000599:	c9                   	leave  
2000059a:	c3                   	ret    

2000059b <exit>:
	int result = main(getargsptr());

	exit(result);
}

void exit(int returncode) {
2000059b:	55                   	push   %ebp
2000059c:	89 e5                	mov    %esp,%ebp
2000059e:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200005a1:	8b 45 08             	mov    0x8(%ebp),%eax
200005a4:	c7 45 e0 01 00 00 00 	movl   $0x1,-0x20(%ebp)
200005ab:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200005ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
200005b1:	50                   	push   %eax
			.eax = 0x1,
			.ebx = returncode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200005b2:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200005b9:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200005c0:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200005c7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200005ce:	e8 2d 01 00 00       	call   20000700 <syscall>
200005d3:	83 c4 10             	add    $0x10,%esp
200005d6:	eb fe                	jmp    200005d6 <exit+0x3b>

200005d8 <execp>:
	syscall(&state);

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
200005d8:	55                   	push   %ebp
200005d9:	89 e5                	mov    %esp,%ebp
200005db:	57                   	push   %edi
200005dc:	56                   	push   %esi
200005dd:	53                   	push   %ebx
200005de:	83 ec 1c             	sub    $0x1c,%esp
		if(driverData->pos + driverData->bytesDone >= elfsize) {
			elfsize *= 2;
			elf = realloc(elf, elfsize);
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
200005e1:	bf d8 0e 00 00       	mov    $0xed8,%edi

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();
200005e6:	e8 9a 08 00 00       	call   20000e85 <palloc>

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
200005eb:	83 ec 0c             	sub    $0xc,%esp

	return state.eax;
}

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();
200005ee:	89 c3                	mov    %eax,%ebx

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
200005f0:	68 d8 0e 00 00       	push   $0xed8
200005f5:	e8 fd 09 00 00       	call   20000ff7 <malloc>

	driverData->length = MAX_IO_BUFFER;
200005fa:	c7 43 08 d8 0e 00 00 	movl   $0xed8,0x8(%ebx)

THREAD execp(char* path, void* data, uint32_t datasize) {
	struct driver_data* driverData = palloc();

	uint32_t elfsize = MAX_IO_BUFFER;
	void* elf = malloc(elfsize); //256KB for init load
20000601:	89 c6                	mov    %eax,%esi

	driverData->length = MAX_IO_BUFFER;

	kprintf("Reading init...\n");
20000603:	c7 04 24 94 30 00 20 	movl   $0x20003094,(%esp)
2000060a:	e8 ee 01 00 00       	call   200007fd <kprintf>
		if(driverData->pos + driverData->bytesDone >= elfsize) {
			elfsize *= 2;
			elf = realloc(elf, elfsize);
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
2000060f:	8d 43 14             	lea    0x14(%ebx),%eax
20000612:	83 c4 10             	add    $0x10,%esp
20000615:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	driverData->length = MAX_IO_BUFFER;

	kprintf("Reading init...\n");

	do {
		FUTURE f = fRead(path, driverData);
20000618:	50                   	push   %eax
20000619:	50                   	push   %eax
2000061a:	53                   	push   %ebx
2000061b:	ff 75 08             	pushl  0x8(%ebp)
2000061e:	e8 31 04 00 00       	call   20000a54 <fRead>
20000623:	83 c4 10             	add    $0x10,%esp
20000626:	89 c2                	mov    %eax,%edx
		while(rpc_check_future(f));
20000628:	83 ec 0c             	sub    $0xc,%esp
2000062b:	89 55 e0             	mov    %edx,-0x20(%ebp)
2000062e:	52                   	push   %edx
2000062f:	e8 c0 02 00 00       	call   200008f4 <rpc_check_future>
20000634:	83 c4 10             	add    $0x10,%esp
20000637:	8b 55 e0             	mov    -0x20(%ebp),%edx
2000063a:	85 c0                	test   %eax,%eax
2000063c:	75 ea                	jne    20000628 <execp+0x50>

		if(driverData->pos + driverData->bytesDone >= elfsize) {
2000063e:	8b 43 0c             	mov    0xc(%ebx),%eax
20000641:	31 d2                	xor    %edx,%edx
20000643:	03 03                	add    (%ebx),%eax
20000645:	13 53 04             	adc    0x4(%ebx),%edx
20000648:	83 fa 00             	cmp    $0x0,%edx
2000064b:	77 04                	ja     20000651 <execp+0x79>
2000064d:	39 f8                	cmp    %edi,%eax
2000064f:	72 10                	jb     20000661 <execp+0x89>
			elfsize *= 2;
20000651:	01 ff                	add    %edi,%edi
			elf = realloc(elf, elfsize);
20000653:	51                   	push   %ecx
20000654:	51                   	push   %ecx
20000655:	57                   	push   %edi
20000656:	56                   	push   %esi
20000657:	e8 a3 0a 00 00       	call   200010ff <realloc>
2000065c:	83 c4 10             	add    $0x10,%esp
2000065f:	89 c6                	mov    %eax,%esi
		}

		if(driverData->bytesDone) memcpy(elf + driverData->pos, driverData->data, driverData->bytesDone);
20000661:	8b 43 0c             	mov    0xc(%ebx),%eax
20000664:	85 c0                	test   %eax,%eax
20000666:	74 12                	je     2000067a <execp+0xa2>
20000668:	52                   	push   %edx
20000669:	50                   	push   %eax
2000066a:	ff 75 e4             	pushl  -0x1c(%ebp)
2000066d:	8b 03                	mov    (%ebx),%eax
2000066f:	01 f0                	add    %esi,%eax
20000671:	50                   	push   %eax
20000672:	e8 0d 07 00 00       	call   20000d84 <memcpy>
20000677:	83 c4 10             	add    $0x10,%esp

		driverData->pos += driverData->bytesDone;
2000067a:	8b 43 0c             	mov    0xc(%ebx),%eax
2000067d:	31 d2                	xor    %edx,%edx
2000067f:	01 03                	add    %eax,(%ebx)
20000681:	11 53 04             	adc    %edx,0x4(%ebx)
	} while(driverData->bytesDone != 0);
20000684:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
20000688:	75 8e                	jne    20000618 <execp+0x40>

	kprintf("Executing init from init...\n");
2000068a:	83 ec 0c             	sub    $0xc,%esp
2000068d:	68 a5 30 00 20       	push   $0x200030a5
20000692:	e8 66 01 00 00       	call   200007fd <kprintf>
	THREAD ret = exec(elf, driverData->pos, data, datasize);
20000697:	ff 75 10             	pushl  0x10(%ebp)
2000069a:	ff 75 0c             	pushl  0xc(%ebp)
2000069d:	ff 33                	pushl  (%ebx)
2000069f:	56                   	push   %esi
200006a0:	e8 2b fe ff ff       	call   200004d0 <exec>

	pfree(driverData);
200006a5:	83 c4 14             	add    $0x14,%esp
200006a8:	89 45 e0             	mov    %eax,-0x20(%ebp)
200006ab:	53                   	push   %ebx
200006ac:	e8 40 07 00 00       	call   20000df1 <pfree>
	free(elf);
200006b1:	89 34 24             	mov    %esi,(%esp)
200006b4:	e8 db 07 00 00       	call   20000e94 <free>

	return ret;
}
200006b9:	8b 45 e0             	mov    -0x20(%ebp),%eax
200006bc:	8d 65 f4             	lea    -0xc(%ebp),%esp
200006bf:	5b                   	pop    %ebx
200006c0:	5e                   	pop    %esi
200006c1:	5f                   	pop    %edi
200006c2:	5d                   	pop    %ebp
200006c3:	c3                   	ret    

200006c4 <execpn>:

THREAD execpn(char* path) {
200006c4:	55                   	push   %ebp
200006c5:	89 e5                	mov    %esp,%ebp
200006c7:	83 ec 0c             	sub    $0xc,%esp
	return execp(path, 0, 0);
200006ca:	6a 00                	push   $0x0
200006cc:	6a 00                	push   $0x0
200006ce:	ff 75 08             	pushl  0x8(%ebp)
200006d1:	e8 02 ff ff ff       	call   200005d8 <execp>
}
200006d6:	c9                   	leave  
200006d7:	c3                   	ret    

200006d8 <_start>:
	syscall(&state);

	return state.eax;
}

void _start() {
200006d8:	55                   	push   %ebp
200006d9:	89 e5                	mov    %esp,%ebp
200006db:	83 ec 08             	sub    $0x8,%esp
	rpc_init();
200006de:	e8 9c 02 00 00       	call   2000097f <rpc_init>

	int result = main(getargsptr());
200006e3:	e8 75 fe ff ff       	call   2000055d <getargsptr>
200006e8:	83 ec 0c             	sub    $0xc,%esp
200006eb:	50                   	push   %eax
200006ec:	e8 b1 fd ff ff       	call   200004a2 <main>

	exit(result);
200006f1:	89 04 24             	mov    %eax,(%esp)
200006f4:	e8 a2 fe ff ff       	call   2000059b <exit>
200006f9:	83 c4 10             	add    $0x10,%esp
}
200006fc:	c9                   	leave  
200006fd:	c3                   	ret    
	...

20000700 <syscall>:
#include "syscall.h"

void syscall(struct regstate* state) {
20000700:	55                   	push   %ebp
20000701:	89 e5                	mov    %esp,%ebp
20000703:	57                   	push   %edi
20000704:	56                   	push   %esi
20000705:	53                   	push   %ebx
20000706:	83 ec 10             	sub    $0x10,%esp
	asm("int $0x30"
20000709:	8b 55 08             	mov    0x8(%ebp),%edx
2000070c:	8b 45 08             	mov    0x8(%ebp),%eax
2000070f:	8b 72 0c             	mov    0xc(%edx),%esi
20000712:	8b 00                	mov    (%eax),%eax
20000714:	89 75 e4             	mov    %esi,-0x1c(%ebp)
20000717:	8b 5a 04             	mov    0x4(%edx),%ebx
2000071a:	8b 4a 08             	mov    0x8(%edx),%ecx
2000071d:	8b 72 10             	mov    0x10(%edx),%esi
20000720:	8b 7a 14             	mov    0x14(%edx),%edi
20000723:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000726:	8b 55 e4             	mov    -0x1c(%ebp),%edx
20000729:	cd 30                	int    $0x30
2000072b:	89 55 e8             	mov    %edx,-0x18(%ebp)
2000072e:	8b 55 08             	mov    0x8(%ebp),%edx
20000731:	89 45 f0             	mov    %eax,-0x10(%ebp)
20000734:	89 02                	mov    %eax,(%edx)
20000736:	8b 45 e8             	mov    -0x18(%ebp),%eax
20000739:	89 5a 04             	mov    %ebx,0x4(%edx)
2000073c:	89 4a 08             	mov    %ecx,0x8(%edx)
2000073f:	89 42 0c             	mov    %eax,0xc(%edx)
20000742:	89 72 10             	mov    %esi,0x10(%edx)
20000745:	89 7a 14             	mov    %edi,0x14(%edx)
			"b" (state->ebx),
			"c" (state->ecx),
			"d" (state->edx),
			"S" (state->esi),
			"D" (state->edi));
}
20000748:	83 c4 10             	add    $0x10,%esp
2000074b:	5b                   	pop    %ebx
2000074c:	5e                   	pop    %esi
2000074d:	5f                   	pop    %edi
2000074e:	5d                   	pop    %ebp
2000074f:	c3                   	ret    

20000750 <setclr>:
        x /= base;
    } while (x);
    kputs(p);
}

void setclr(char clr) {
20000750:	55                   	push   %ebp
20000751:	89 e5                	mov    %esp,%ebp
    color = clr;
20000753:	8b 45 08             	mov    0x8(%ebp),%eax
}
20000756:	5d                   	pop    %ebp
    } while (x);
    kputs(p);
}

void setclr(char clr) {
    color = clr;
20000757:	a2 04 20 00 20       	mov    %al,0x20002004
}
2000075c:	c3                   	ret    

2000075d <kputc>:
static int x = 0;
static int y = 0;
static int kprintf_res = 0;
static char color = 0x07;

void kputc(char c) {
2000075d:	55                   	push   %ebp
2000075e:	89 e5                	mov    %esp,%ebp
20000760:	83 ec 34             	sub    $0x34,%esp
20000763:	0f be 45 08          	movsbl 0x8(%ebp),%eax
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000767:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
2000076a:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000076d:	50                   	push   %eax
			.eax = 0x100,
			.ebx = (uint32_t) c,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000076e:	c7 45 e0 00 01 00 00 	movl   $0x100,-0x20(%ebp)
20000775:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
2000077c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000783:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000078a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000791:	e8 6a ff ff ff       	call   20000700 <syscall>
20000796:	83 c4 10             	add    $0x10,%esp
}
20000799:	c9                   	leave  
2000079a:	c3                   	ret    

2000079b <kputs>:

void kputs(const char* s) {
2000079b:	55                   	push   %ebp
2000079c:	89 e5                	mov    %esp,%ebp
2000079e:	53                   	push   %ebx
2000079f:	83 ec 04             	sub    $0x4,%esp
200007a2:	8b 5d 08             	mov    0x8(%ebp),%ebx
    while (*s) {
200007a5:	eb 10                	jmp    200007b7 <kputs+0x1c>
        kputc(*s++);
200007a7:	83 ec 0c             	sub    $0xc,%esp
200007aa:	43                   	inc    %ebx
200007ab:	0f be c0             	movsbl %al,%eax
200007ae:	50                   	push   %eax
200007af:	e8 a9 ff ff ff       	call   2000075d <kputc>
200007b4:	83 c4 10             	add    $0x10,%esp

	syscall(&state);
}

void kputs(const char* s) {
    while (*s) {
200007b7:	8a 03                	mov    (%ebx),%al
200007b9:	84 c0                	test   %al,%al
200007bb:	75 ea                	jne    200007a7 <kputs+0xc>
        kputc(*s++);
    }
}
200007bd:	8b 5d fc             	mov    -0x4(%ebp),%ebx
200007c0:	c9                   	leave  
200007c1:	c3                   	ret    

200007c2 <kputn>:

void kputn(unsigned long x, int base) {
200007c2:	55                   	push   %ebp
200007c3:	89 e5                	mov    %esp,%ebp
200007c5:	53                   	push   %ebx
200007c6:	83 ec 54             	sub    $0x54,%esp
200007c9:	8b 5d 0c             	mov    0xc(%ebp),%ebx
200007cc:	8b 45 08             	mov    0x8(%ebp),%eax
    char buf[65];
    const char* digits = "0123456789abcdefghijklmnopqrstuvwxyz";
    char* p;

    if (base > 36) {
200007cf:	83 fb 24             	cmp    $0x24,%ebx
200007d2:	7f 24                	jg     200007f8 <kputn+0x36>
        return;
    }

    p = buf + 64;
    *p = '\0';
200007d4:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)
200007d8:	8d 4d f7             	lea    -0x9(%ebp),%ecx
    do {
        *--p = digits[x % base];
200007db:	31 d2                	xor    %edx,%edx
200007dd:	49                   	dec    %ecx
200007de:	f7 f3                	div    %ebx
        x /= base;
    } while (x);
200007e0:	85 c0                	test   %eax,%eax
    }

    p = buf + 64;
    *p = '\0';
    do {
        *--p = digits[x % base];
200007e2:	8a 92 c2 30 00 20    	mov    0x200030c2(%edx),%dl
200007e8:	88 11                	mov    %dl,(%ecx)
        x /= base;
    } while (x);
200007ea:	75 ef                	jne    200007db <kputn+0x19>
    kputs(p);
200007ec:	83 ec 0c             	sub    $0xc,%esp
200007ef:	51                   	push   %ecx
200007f0:	e8 a6 ff ff ff       	call   2000079b <kputs>
200007f5:	83 c4 10             	add    $0x10,%esp
}
200007f8:	8b 5d fc             	mov    -0x4(%ebp),%ebx
200007fb:	c9                   	leave  
200007fc:	c3                   	ret    

200007fd <kprintf>:

void setclr(char clr) {
    color = clr;
}

int kprintf(const char* fmt, ...) {
200007fd:	55                   	push   %ebp
200007fe:	89 e5                	mov    %esp,%ebp
20000800:	57                   	push   %edi
20000801:	56                   	push   %esi
20000802:	53                   	push   %ebx
20000803:	83 ec 0c             	sub    $0xc,%esp
20000806:	8d 5d 0c             	lea    0xc(%ebp),%ebx
20000809:	8b 75 08             	mov    0x8(%ebp),%esi
    const char* s;
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
2000080c:	c7 05 00 40 04 20 00 	movl   $0x0,0x20044000
20000813:	00 00 00 
    while (*fmt) {
20000816:	e9 99 00 00 00       	jmp    200008b4 <kprintf+0xb7>
        if (*fmt == '%') {
2000081b:	3c 25                	cmp    $0x25,%al
2000081d:	0f 85 81 00 00 00    	jne    200008a4 <kprintf+0xa7>
            fmt++;
20000823:	46                   	inc    %esi
            switch (*fmt) {
20000824:	8a 06                	mov    (%esi),%al
20000826:	3c 70                	cmp    $0x70,%al
20000828:	74 40                	je     2000086a <kprintf+0x6d>
2000082a:	7f 1a                	jg     20000846 <kprintf+0x49>
2000082c:	3c 63                	cmp    $0x63,%al
2000082e:	74 4c                	je     2000087c <kprintf+0x7f>
20000830:	7f 0e                	jg     20000840 <kprintf+0x43>
20000832:	84 c0                	test   %al,%al
20000834:	0f 84 84 00 00 00    	je     200008be <kprintf+0xc1>
2000083a:	3c 25                	cmp    $0x25,%al
2000083c:	75 56                	jne    20000894 <kprintf+0x97>
2000083e:	eb 4d                	jmp    2000088d <kprintf+0x90>
20000840:	3c 64                	cmp    $0x64,%al
20000842:	75 50                	jne    20000894 <kprintf+0x97>
20000844:	eb 1b                	jmp    20000861 <kprintf+0x64>
20000846:	3c 75                	cmp    $0x75,%al
20000848:	74 17                	je     20000861 <kprintf+0x64>
2000084a:	3c 78                	cmp    $0x78,%al
2000084c:	74 1c                	je     2000086a <kprintf+0x6d>
2000084e:	3c 73                	cmp    $0x73,%al
20000850:	75 42                	jne    20000894 <kprintf+0x97>
            case 's':
                s = va_arg(ap, char*);
                kputs(s);
20000852:	83 ec 0c             	sub    $0xc,%esp
    while (*fmt) {
        if (*fmt == '%') {
            fmt++;
            switch (*fmt) {
            case 's':
                s = va_arg(ap, char*);
20000855:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputs(s);
20000858:	ff 33                	pushl  (%ebx)
2000085a:	e8 3c ff ff ff       	call   2000079b <kputs>
2000085f:	eb 17                	jmp    20000878 <kprintf+0x7b>
                break;
            case 'd':
            case 'u':
                n = va_arg(ap, unsigned long int);
20000861:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 10);
20000864:	51                   	push   %ecx
20000865:	51                   	push   %ecx
20000866:	6a 0a                	push   $0xa
20000868:	eb 07                	jmp    20000871 <kprintf+0x74>
                break;
            case 'x':
            case 'p':
                n = va_arg(ap, unsigned long int);
2000086a:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputn(n, 16);
2000086d:	52                   	push   %edx
2000086e:	52                   	push   %edx
2000086f:	6a 10                	push   $0x10
20000871:	ff 33                	pushl  (%ebx)
20000873:	e8 4a ff ff ff       	call   200007c2 <kputn>
20000878:	89 fb                	mov    %edi,%ebx
2000087a:	eb 34                	jmp    200008b0 <kprintf+0xb3>
                break;
            case 'c':
                c = va_arg(ap, int);
                kputc(c);
2000087c:	83 ec 0c             	sub    $0xc,%esp
            case 'p':
                n = va_arg(ap, unsigned long int);
                kputn(n, 16);
                break;
            case 'c':
                c = va_arg(ap, int);
2000087f:	8d 7b 04             	lea    0x4(%ebx),%edi
                kputc(c);
20000882:	0f be 03             	movsbl (%ebx),%eax
20000885:	50                   	push   %eax
20000886:	e8 d2 fe ff ff       	call   2000075d <kputc>
2000088b:	eb eb                	jmp    20000878 <kprintf+0x7b>
                break;
            case '%':
                kputc('%');
2000088d:	83 ec 0c             	sub    $0xc,%esp
20000890:	6a 25                	push   $0x25
20000892:	eb 17                	jmp    200008ab <kprintf+0xae>
                break;
            case '\0':
                goto out;
            default:
                kputc('%');
20000894:	83 ec 0c             	sub    $0xc,%esp
20000897:	6a 25                	push   $0x25
20000899:	e8 bf fe ff ff       	call   2000075d <kputc>
                kputc(*fmt);
2000089e:	58                   	pop    %eax
2000089f:	0f be 06             	movsbl (%esi),%eax
200008a2:	eb 06                	jmp    200008aa <kprintf+0xad>
                break;
            }
        } else {
            kputc(*fmt);
200008a4:	83 ec 0c             	sub    $0xc,%esp
200008a7:	0f be c0             	movsbl %al,%eax
200008aa:	50                   	push   %eax
200008ab:	e8 ad fe ff ff       	call   2000075d <kputc>
200008b0:	83 c4 10             	add    $0x10,%esp
        }

        fmt++;
200008b3:	46                   	inc    %esi
    unsigned long n;
    char c;

    va_start(ap, fmt);
    kprintf_res = 0;
    while (*fmt) {
200008b4:	8a 06                	mov    (%esi),%al
200008b6:	84 c0                	test   %al,%al
200008b8:	0f 85 5d ff ff ff    	jne    2000081b <kprintf+0x1e>

    out:
    va_end(ap);

    return kprintf_res;
}
200008be:	a1 00 40 04 20       	mov    0x20044000,%eax
200008c3:	8d 65 f4             	lea    -0xc(%ebp),%esp
200008c6:	5b                   	pop    %ebx
200008c7:	5e                   	pop    %esi
200008c8:	5f                   	pop    %edi
200008c9:	5d                   	pop    %ebp
200008ca:	c3                   	ret    
	...

200008cc <rpc_register_handler>:
	syscall(&state);

	return state.eax;
}

int rpc_register_handler(int(*fptr)(int, void*)) {
200008cc:	55                   	push   %ebp
200008cd:	31 c0                	xor    %eax,%eax
200008cf:	89 e5                	mov    %esp,%ebp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		if(rpcHandlers[i] == (int(*)(int, void*))0) {
200008d1:	83 3c 85 04 40 04 20 	cmpl   $0x0,0x20044004(,%eax,4)
200008d8:	00 
200008d9:	75 0c                	jne    200008e7 <rpc_register_handler+0x1b>
			rpcHandlers[i] = fptr;
200008db:	8b 55 08             	mov    0x8(%ebp),%edx
200008de:	89 14 85 04 40 04 20 	mov    %edx,0x20044004(,%eax,4)
			return i;
200008e5:	eb 0b                	jmp    200008f2 <rpc_register_handler+0x26>

	return state.eax;
}

int rpc_register_handler(int(*fptr)(int, void*)) {
	for(int i = 0; i < RPC_HANDLERS; i++) {
200008e7:	40                   	inc    %eax
200008e8:	3d 00 04 00 00       	cmp    $0x400,%eax
200008ed:	75 e2                	jne    200008d1 <rpc_register_handler+0x5>
200008ef:	83 c8 ff             	or     $0xffffffff,%eax
			rpcHandlers[i] = fptr;
			return i;
		}
	}
	return -1;
}
200008f2:	5d                   	pop    %ebp
200008f3:	c3                   	ret    

200008f4 <rpc_check_future>:
	*rpcARG0 = state.ecx;
	return (void*) state.eax;
}


int rpc_check_future(FUTURE fut) {
200008f4:	55                   	push   %ebp
200008f5:	89 e5                	mov    %esp,%ebp
200008f7:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200008fa:	8b 45 08             	mov    0x8(%ebp),%eax
200008fd:	c7 45 e0 03 02 00 00 	movl   $0x203,-0x20(%ebp)
20000904:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000907:	8d 45 e0             	lea    -0x20(%ebp),%eax
2000090a:	50                   	push   %eax
			.eax = 0x203,
			.ebx = fut,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000090b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000912:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000919:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000920:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000927:	e8 d4 fd ff ff       	call   20000700 <syscall>

	return state.eax;
}
2000092c:	8b 45 e0             	mov    -0x20(%ebp),%eax
2000092f:	c9                   	leave  
20000930:	c3                   	ret    

20000931 <rpc_map>:
			.edi = 0 };

	syscall(&state);
}

void* rpc_map(uint32_t* rpcID, uint32_t* rpcARG0) {
20000931:	55                   	push   %ebp
20000932:	89 e5                	mov    %esp,%ebp
20000934:	83 ec 34             	sub    $0x34,%esp
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
20000937:	8d 45 e0             	lea    -0x20(%ebp),%eax
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000093a:	c7 45 e0 00 02 00 00 	movl   $0x200,-0x20(%ebp)

	syscall(&state);
20000941:	50                   	push   %eax
			.eax = 0x200,
			.ebx = 0,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000942:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
20000949:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000950:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000957:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
2000095e:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000965:	e8 96 fd ff ff       	call   20000700 <syscall>

	*rpcID = state.ebx;
2000096a:	8b 45 08             	mov    0x8(%ebp),%eax
2000096d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
20000970:	89 10                	mov    %edx,(%eax)
	*rpcARG0 = state.ecx;
20000972:	8b 45 0c             	mov    0xc(%ebp),%eax
20000975:	8b 55 e8             	mov    -0x18(%ebp),%edx
20000978:	89 10                	mov    %edx,(%eax)
	return (void*) state.eax;
}
2000097a:	8b 45 e0             	mov    -0x20(%ebp),%eax
2000097d:	c9                   	leave  
2000097e:	c3                   	ret    

2000097f <rpc_init>:
	kprintf("RET RPC NO WORK\n");
	while(1) {
	}
}

void rpc_init() {
2000097f:	55                   	push   %ebp
20000980:	31 c0                	xor    %eax,%eax
20000982:	89 e5                	mov    %esp,%ebp
20000984:	57                   	push   %edi
20000985:	56                   	push   %esi
20000986:	83 ec 20             	sub    $0x20,%esp
	for(int i = 0; i < RPC_HANDLERS; i++) {
		rpcHandlers[i] = (int(*)(int, void*))0;
20000989:	c7 04 85 04 40 04 20 	movl   $0x0,0x20044004(,%eax,4)
20000990:	00 00 00 00 
	while(1) {
	}
}

void rpc_init() {
	for(int i = 0; i < RPC_HANDLERS; i++) {
20000994:	40                   	inc    %eax
20000995:	3d 00 04 00 00       	cmp    $0x400,%eax
2000099a:	75 ed                	jne    20000989 <rpc_init+0xa>
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
2000099c:	8d 7d e0             	lea    -0x20(%ebp),%edi
2000099f:	be 7c 30 00 20       	mov    $0x2000307c,%esi
200009a4:	b9 06 00 00 00       	mov    $0x6,%ecx

	syscall(&state);
200009a9:	83 ec 0c             	sub    $0xc,%esp
			.eax = 0x202,
			.ebx = (uint32_t)&rpc_handler,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200009ac:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)

	syscall(&state);
200009ae:	8d 45 e0             	lea    -0x20(%ebp),%eax
200009b1:	50                   	push   %eax
200009b2:	e8 49 fd ff ff       	call   20000700 <syscall>
200009b7:	83 c4 10             	add    $0x10,%esp
}
200009ba:	8d 65 f8             	lea    -0x8(%ebp),%esp
200009bd:	5e                   	pop    %esi
200009be:	5f                   	pop    %edi
200009bf:	5d                   	pop    %ebp
200009c0:	c3                   	ret    

200009c1 <rpc_return>:

#define RPC_HANDLERS 1024

static int(*rpcHandlers[RPC_HANDLERS])(int, void*);

void rpc_return(int returnCode) {
200009c1:	55                   	push   %ebp
200009c2:	89 e5                	mov    %esp,%ebp
200009c4:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200009c7:	8b 45 08             	mov    0x8(%ebp),%eax
200009ca:	c7 45 e0 01 02 00 00 	movl   $0x201,-0x20(%ebp)
200009d1:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
200009d4:	8d 45 e0             	lea    -0x20(%ebp),%eax
200009d7:	50                   	push   %eax
			.eax = 0x201,
			.ebx = returnCode,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
200009d8:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
200009df:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
200009e6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
200009ed:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
200009f4:	e8 07 fd ff ff       	call   20000700 <syscall>

	kprintf("RET RPC NO WORK\n");
200009f9:	c7 04 24 e7 30 00 20 	movl   $0x200030e7,(%esp)
20000a00:	e8 f8 fd ff ff       	call   200007fd <kprintf>
20000a05:	83 c4 10             	add    $0x10,%esp
20000a08:	eb fe                	jmp    20000a08 <rpc_return+0x47>

20000a0a <rpc_handler>:
		}
	}
	return -1;
}

void rpc_handler() {
20000a0a:	55                   	push   %ebp
20000a0b:	89 e5                	mov    %esp,%ebp
20000a0d:	83 ec 20             	sub    $0x20,%esp
	uint32_t rpcID;
	uint32_t rpcARG0;
	void* rpcData = rpc_map(&rpcID, &rpcARG0);
20000a10:	8d 45 f0             	lea    -0x10(%ebp),%eax
20000a13:	50                   	push   %eax
20000a14:	8d 45 f4             	lea    -0xc(%ebp),%eax
20000a17:	50                   	push   %eax
20000a18:	e8 14 ff ff ff       	call   20000931 <rpc_map>

	int returnValue = -1;

	if(rpcID < RPC_HANDLERS && rpcHandlers[rpcID] != 0) {
20000a1d:	8b 55 f4             	mov    -0xc(%ebp),%edx
20000a20:	83 c4 10             	add    $0x10,%esp
20000a23:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
20000a29:	77 18                	ja     20000a43 <rpc_handler+0x39>
20000a2b:	8b 14 95 04 40 04 20 	mov    0x20044004(,%edx,4),%edx
20000a32:	85 d2                	test   %edx,%edx
20000a34:	74 0d                	je     20000a43 <rpc_handler+0x39>
		returnValue = rpcHandlers[rpcID](rpcARG0, rpcData);
20000a36:	51                   	push   %ecx
20000a37:	51                   	push   %ecx
20000a38:	50                   	push   %eax
20000a39:	ff 75 f0             	pushl  -0x10(%ebp)
20000a3c:	ff d2                	call   *%edx
20000a3e:	83 c4 10             	add    $0x10,%esp
20000a41:	eb 03                	jmp    20000a46 <rpc_handler+0x3c>
20000a43:	83 c8 ff             	or     $0xffffffff,%eax
	}

	rpc_return(returnValue);
20000a46:	83 ec 0c             	sub    $0xc,%esp
20000a49:	50                   	push   %eax
20000a4a:	e8 72 ff ff ff       	call   200009c1 <rpc_return>
20000a4f:	83 c4 10             	add    $0x10,%esp
}
20000a52:	c9                   	leave  
20000a53:	c3                   	ret    

20000a54 <fRead>:
	syscall(&state);

	return state.eax;
}

FUTURE fRead(char* path, struct driver_data* drvData) {
20000a54:	55                   	push   %ebp
20000a55:	89 e5                	mov    %esp,%ebp
20000a57:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x305,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a5a:	8b 45 08             	mov    0x8(%ebp),%eax
20000a5d:	c7 45 e0 05 03 00 00 	movl   $0x305,-0x20(%ebp)
20000a64:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000a67:	8b 45 0c             	mov    0xc(%ebp),%eax
20000a6a:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000a6d:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000a70:	50                   	push   %eax
			.eax = 0x305,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a71:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000a78:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000a7f:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000a86:	e8 75 fc ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000a8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000a8e:	c9                   	leave  
20000a8f:	c3                   	ret    

20000a90 <fWrite>:
	syscall(&state);

	return state.eax;
}

FUTURE fWrite(char* path, struct driver_data* drvData) {
20000a90:	55                   	push   %ebp
20000a91:	89 e5                	mov    %esp,%ebp
20000a93:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x304,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000a96:	8b 45 08             	mov    0x8(%ebp),%eax
20000a99:	c7 45 e0 04 03 00 00 	movl   $0x304,-0x20(%ebp)
20000aa0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000aa3:	8b 45 0c             	mov    0xc(%ebp),%eax
20000aa6:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000aa9:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000aac:	50                   	push   %eax
			.eax = 0x304,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000aad:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000ab4:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000abb:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000ac2:	e8 39 fc ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000ac7:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000aca:	c9                   	leave  
20000acb:	c3                   	ret    

20000acc <fCall>:
	syscall(&state);

	return state.eax;
}

FUTURE fCall(char* driverName, int callID, struct driver_data* drvData) {
20000acc:	55                   	push   %ebp
20000acd:	89 e5                	mov    %esp,%ebp
20000acf:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x303,
			.ebx = (uint32_t)driverName,
			.ecx = (uint32_t)drvData,
			.edx = callID,
			.esi = 0,
			.edi = 0 };
20000ad2:	8b 45 08             	mov    0x8(%ebp),%eax
20000ad5:	c7 45 e0 03 03 00 00 	movl   $0x303,-0x20(%ebp)
20000adc:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000adf:	8b 45 10             	mov    0x10(%ebp),%eax
20000ae2:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000ae5:	8b 45 0c             	mov    0xc(%ebp),%eax
20000ae8:	89 45 ec             	mov    %eax,-0x14(%ebp)

	syscall(&state);
20000aeb:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000aee:	50                   	push   %eax
			.eax = 0x303,
			.ebx = (uint32_t)driverName,
			.ecx = (uint32_t)drvData,
			.edx = callID,
			.esi = 0,
			.edi = 0 };
20000aef:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000af6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000afd:	e8 fe fb ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000b02:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000b05:	c9                   	leave  
20000b06:	c3                   	ret    

20000b07 <fModify>:
	syscall(&state);

	return state.eax;
}

FUTURE fModify(char* path, struct driver_data* drvData) {
20000b07:	55                   	push   %ebp
20000b08:	89 e5                	mov    %esp,%ebp
20000b0a:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x302,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b0d:	8b 45 08             	mov    0x8(%ebp),%eax
20000b10:	c7 45 e0 02 03 00 00 	movl   $0x302,-0x20(%ebp)
20000b17:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000b1a:	8b 45 0c             	mov    0xc(%ebp),%eax
20000b1d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000b20:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b23:	50                   	push   %eax
			.eax = 0x302,
			.ebx = (uint32_t)path,
			.ecx = (uint32_t)drvData,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b24:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000b2b:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000b32:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000b39:	e8 c2 fb ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000b3e:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000b41:	c9                   	leave  
20000b42:	c3                   	ret    

20000b43 <inl>:
	syscall(&state);

	return state.eax;
}

uint32_t inl(uint16_t port) {
20000b43:	55                   	push   %ebp
20000b44:	89 e5                	mov    %esp,%ebp
20000b46:	83 ec 34             	sub    $0x34,%esp
20000b49:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x606,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b4d:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000b50:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b53:	50                   	push   %eax
			.eax = 0x606,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b54:	c7 45 e0 06 06 00 00 	movl   $0x606,-0x20(%ebp)
20000b5b:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000b62:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000b69:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000b70:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000b77:	e8 84 fb ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000b7c:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000b7f:	c9                   	leave  
20000b80:	c3                   	ret    

20000b81 <inw>:
	syscall(&state);

	return state.eax;
}

uint16_t inw(uint16_t port) {
20000b81:	55                   	push   %ebp
20000b82:	89 e5                	mov    %esp,%ebp
20000b84:	83 ec 34             	sub    $0x34,%esp
20000b87:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x605,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b8b:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000b8e:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000b91:	50                   	push   %eax
			.eax = 0x605,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000b92:	c7 45 e0 05 06 00 00 	movl   $0x605,-0x20(%ebp)
20000b99:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000ba0:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000ba7:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000bae:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000bb5:	e8 46 fb ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000bba:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000bbd:	c9                   	leave  
20000bbe:	c3                   	ret    

20000bbf <inb>:
			.edi = 0 };

	syscall(&state);
}

uint8_t inb(uint16_t port) {
20000bbf:	55                   	push   %ebp
20000bc0:	89 e5                	mov    %esp,%ebp
20000bc2:	83 ec 34             	sub    $0x34,%esp
20000bc5:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x604,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000bc9:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000bcc:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000bcf:	50                   	push   %eax
			.eax = 0x604,
			.ebx = port,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000bd0:	c7 45 e0 04 06 00 00 	movl   $0x604,-0x20(%ebp)
20000bd7:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000bde:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000be5:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000bec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000bf3:	e8 08 fb ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000bf8:	8a 45 e0             	mov    -0x20(%ebp),%al
20000bfb:	c9                   	leave  
20000bfc:	c3                   	ret    

20000bfd <outl>:
			.edi = 0 };

	syscall(&state);
}

void outl(uint16_t port, uint32_t value) {
20000bfd:	55                   	push   %ebp
20000bfe:	89 e5                	mov    %esp,%ebp
20000c00:	83 ec 34             	sub    $0x34,%esp
20000c03:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x603,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c07:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000c0a:	8b 45 0c             	mov    0xc(%ebp),%eax
20000c0d:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000c10:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c13:	50                   	push   %eax
			.eax = 0x603,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c14:	c7 45 e0 03 06 00 00 	movl   $0x603,-0x20(%ebp)
20000c1b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000c22:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000c29:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000c30:	e8 cb fa ff ff       	call   20000700 <syscall>
20000c35:	83 c4 10             	add    $0x10,%esp
}
20000c38:	c9                   	leave  
20000c39:	c3                   	ret    

20000c3a <outw>:
			.edi = 0 };

	syscall(&state);
}

void outw(uint16_t port, uint16_t value) {
20000c3a:	55                   	push   %ebp
20000c3b:	89 e5                	mov    %esp,%ebp
20000c3d:	83 ec 34             	sub    $0x34,%esp
20000c40:	0f b7 45 0c          	movzwl 0xc(%ebp),%eax
20000c44:	0f b7 55 08          	movzwl 0x8(%ebp),%edx
			.eax = 0x602,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c48:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000c4b:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c4e:	50                   	push   %eax
			.eax = 0x602,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c4f:	c7 45 e0 02 06 00 00 	movl   $0x602,-0x20(%ebp)
20000c56:	89 55 e4             	mov    %edx,-0x1c(%ebp)
20000c59:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000c60:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000c67:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000c6e:	e8 8d fa ff ff       	call   20000700 <syscall>
20000c73:	83 c4 10             	add    $0x10,%esp
}
20000c76:	c9                   	leave  
20000c77:	c3                   	ret    

20000c78 <outb>:
	syscall(&state);

	return state.eax;
}

void outb(uint16_t port, uint8_t value) {
20000c78:	55                   	push   %ebp
20000c79:	89 e5                	mov    %esp,%ebp
20000c7b:	83 ec 34             	sub    $0x34,%esp
20000c7e:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
			.eax = 0x601,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c82:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000c85:	c7 45 e0 01 06 00 00 	movl   $0x601,-0x20(%ebp)
20000c8c:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
20000c90:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000c93:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000c96:	50                   	push   %eax
			.eax = 0x601,
			.ebx = port,
			.ecx = value,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000c97:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000c9e:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000ca5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000cac:	e8 4f fa ff ff       	call   20000700 <syscall>
20000cb1:	83 c4 10             	add    $0x10,%esp
}
20000cb4:	c9                   	leave  
20000cb5:	c3                   	ret    

20000cb6 <register_irq_rpc>:
	syscall(&state);

	return state.eax;
}

int register_irq_rpc(uint32_t irqID, int rpcID) {
20000cb6:	55                   	push   %ebp
20000cb7:	89 e5                	mov    %esp,%ebp
20000cb9:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x600,
			.ebx = irqID,
			.ecx = rpcID,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000cbc:	8b 45 08             	mov    0x8(%ebp),%eax
20000cbf:	c7 45 e0 00 06 00 00 	movl   $0x600,-0x20(%ebp)
20000cc6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000cc9:	8b 45 0c             	mov    0xc(%ebp),%eax
20000ccc:	89 45 e8             	mov    %eax,-0x18(%ebp)

	syscall(&state);
20000ccf:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000cd2:	50                   	push   %eax
			.eax = 0x600,
			.ebx = irqID,
			.ecx = rpcID,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000cd3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000cda:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000ce1:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000ce8:	e8 13 fa ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000ced:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000cf0:	c9                   	leave  
20000cf1:	c3                   	ret    

20000cf2 <register_path>:
	syscall(&state);

	return state.eax;
}

int register_path(char* path, int driverID, int resourceID) {
20000cf2:	55                   	push   %ebp
20000cf3:	89 e5                	mov    %esp,%ebp
20000cf5:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x301,
			.ebx = (uint32_t)path,
			.ecx = driverID,
			.edx = resourceID,
			.esi = 0,
			.edi = 0 };
20000cf8:	8b 45 08             	mov    0x8(%ebp),%eax
20000cfb:	c7 45 e0 01 03 00 00 	movl   $0x301,-0x20(%ebp)
20000d02:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000d05:	8b 45 0c             	mov    0xc(%ebp),%eax
20000d08:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000d0b:	8b 45 10             	mov    0x10(%ebp),%eax
20000d0e:	89 45 ec             	mov    %eax,-0x14(%ebp)

	syscall(&state);
20000d11:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000d14:	50                   	push   %eax
			.eax = 0x301,
			.ebx = (uint32_t)path,
			.ecx = driverID,
			.edx = resourceID,
			.esi = 0,
			.edi = 0 };
20000d15:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000d1c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000d23:	e8 d8 f9 ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000d28:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000d2b:	c9                   	leave  
20000d2c:	c3                   	ret    

20000d2d <register_driver>:
#include "driver.h"
#include "syscall.h"
#include "memory.h"

int register_driver(int dModifyID, int dInfoID, int dReadID, int dWriteID, char* drvName) {
20000d2d:	55                   	push   %ebp
20000d2e:	89 e5                	mov    %esp,%ebp
20000d30:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x300,
			.ebx = dModifyID,
			.ecx = dInfoID,
			.edx = dReadID,
			.esi = dWriteID,
			.edi = (uint32_t)drvName };
20000d33:	8b 45 08             	mov    0x8(%ebp),%eax
20000d36:	c7 45 e0 00 03 00 00 	movl   $0x300,-0x20(%ebp)
20000d3d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
20000d40:	8b 45 0c             	mov    0xc(%ebp),%eax
20000d43:	89 45 e8             	mov    %eax,-0x18(%ebp)
20000d46:	8b 45 10             	mov    0x10(%ebp),%eax
20000d49:	89 45 ec             	mov    %eax,-0x14(%ebp)
20000d4c:	8b 45 14             	mov    0x14(%ebp),%eax
20000d4f:	89 45 f0             	mov    %eax,-0x10(%ebp)
20000d52:	8b 45 18             	mov    0x18(%ebp),%eax
20000d55:	89 45 f4             	mov    %eax,-0xc(%ebp)

	syscall(&state);
20000d58:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000d5b:	50                   	push   %eax
20000d5c:	e8 9f f9 ff ff       	call   20000700 <syscall>

	return state.eax;
}
20000d61:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000d64:	c9                   	leave  
20000d65:	c3                   	ret    
	...

20000d68 <memset>:
			.edi = 0 };

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
20000d68:	55                   	push   %ebp
20000d69:	89 e5                	mov    %esp,%ebp
20000d6b:	53                   	push   %ebx
20000d6c:	8b 45 08             	mov    0x8(%ebp),%eax
20000d6f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
20000d72:	8b 4d 10             	mov    0x10(%ebp),%ecx
	unsigned char* p = buf;
20000d75:	89 c2                	mov    %eax,%edx

	while (n--) {
20000d77:	eb 04                	jmp    20000d7d <memset+0x15>
		*p++ = c;
20000d79:	88 1a                	mov    %bl,(%edx)
20000d7b:	49                   	dec    %ecx
20000d7c:	42                   	inc    %edx
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;

	while (n--) {
20000d7d:	85 c9                	test   %ecx,%ecx
20000d7f:	75 f8                	jne    20000d79 <memset+0x11>
		*p++ = c;
	}

	return buf;
}
20000d81:	5b                   	pop    %ebx
20000d82:	5d                   	pop    %ebp
20000d83:	c3                   	ret    

20000d84 <memcpy>:

void* memcpy(void* dest, const void* src, uint32_t n) {
20000d84:	55                   	push   %ebp
	unsigned char* d = dest;
	const unsigned char* s = src;

	if (n == 0)
20000d85:	31 c9                	xor    %ecx,%ecx
	}

	return buf;
}

void* memcpy(void* dest, const void* src, uint32_t n) {
20000d87:	89 e5                	mov    %esp,%ebp
20000d89:	56                   	push   %esi
20000d8a:	53                   	push   %ebx
20000d8b:	8b 75 10             	mov    0x10(%ebp),%esi
20000d8e:	8b 45 08             	mov    0x8(%ebp),%eax
20000d91:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	unsigned char* d = dest;
	const unsigned char* s = src;

	if (n == 0)
20000d94:	85 f6                	test   %esi,%esi
20000d96:	75 04                	jne    20000d9c <memcpy+0x18>
20000d98:	31 c0                	xor    %eax,%eax
20000d9a:	eb 0a                	jmp    20000da6 <memcpy+0x22>
		return 0;

	while (n--) {
		*(d++) = *(s++);
20000d9c:	8a 14 0b             	mov    (%ebx,%ecx,1),%dl
20000d9f:	88 14 08             	mov    %dl,(%eax,%ecx,1)
20000da2:	41                   	inc    %ecx
	const unsigned char* s = src;

	if (n == 0)
		return 0;

	while (n--) {
20000da3:	4e                   	dec    %esi
20000da4:	75 f6                	jne    20000d9c <memcpy+0x18>
		*(d++) = *(s++);
	}

	return dest;
}
20000da6:	5b                   	pop    %ebx
20000da7:	5e                   	pop    %esi
20000da8:	5d                   	pop    %ebp
20000da9:	c3                   	ret    

20000daa <memcmp>:

int memcmp(const void* ptr1, const void* ptr2, uint32_t num) {
20000daa:	55                   	push   %ebp
	if (ptr1 == 0)
20000dab:	83 c8 ff             	or     $0xffffffff,%eax
	}

	return dest;
}

int memcmp(const void* ptr1, const void* ptr2, uint32_t num) {
20000dae:	89 e5                	mov    %esp,%ebp
20000db0:	57                   	push   %edi
20000db1:	56                   	push   %esi
20000db2:	53                   	push   %ebx
20000db3:	8b 75 08             	mov    0x8(%ebp),%esi
20000db6:	8b 7d 0c             	mov    0xc(%ebp),%edi
20000db9:	8b 5d 10             	mov    0x10(%ebp),%ebx
	if (ptr1 == 0)
20000dbc:	85 f6                	test   %esi,%esi
20000dbe:	74 2c                	je     20000dec <memcmp+0x42>
		return -1;
	if (ptr2 == 0)
20000dc0:	b8 01 00 00 00       	mov    $0x1,%eax
20000dc5:	85 ff                	test   %edi,%edi
20000dc7:	74 23                	je     20000dec <memcmp+0x42>
		return 1;
	if (num == 0)
20000dc9:	31 d2                	xor    %edx,%edx
20000dcb:	85 db                	test   %ebx,%ebx
20000dcd:	75 17                	jne    20000de6 <memcmp+0x3c>
20000dcf:	eb 19                	jmp    20000dea <memcmp+0x40>

	const uint8_t* pa = ptr1;
	const uint8_t* pb = ptr2;

	for (uint32_t i = 0; i < num; i++) {
		if (pa[i] != pb[i]) {
20000dd1:	8a 04 16             	mov    (%esi,%edx,1),%al
20000dd4:	8a 0c 17             	mov    (%edi,%edx,1),%cl
20000dd7:	38 c8                	cmp    %cl,%al
20000dd9:	74 0a                	je     20000de5 <memcmp+0x3b>
			return pa[i] - pb[i];
20000ddb:	0f b6 c0             	movzbl %al,%eax
20000dde:	0f b6 c9             	movzbl %cl,%ecx
20000de1:	29 c8                	sub    %ecx,%eax
20000de3:	eb 07                	jmp    20000dec <memcmp+0x42>
		return 0;

	const uint8_t* pa = ptr1;
	const uint8_t* pb = ptr2;

	for (uint32_t i = 0; i < num; i++) {
20000de5:	42                   	inc    %edx
20000de6:	39 da                	cmp    %ebx,%edx
20000de8:	72 e7                	jb     20000dd1 <memcmp+0x27>
20000dea:	31 c0                	xor    %eax,%eax
		if (pa[i] != pb[i]) {
			return pa[i] - pb[i];
		}
	}
	return 0;
}
20000dec:	5b                   	pop    %ebx
20000ded:	5e                   	pop    %esi
20000dee:	5f                   	pop    %edi
20000def:	5d                   	pop    %ebp
20000df0:	c3                   	ret    

20000df1 <pfree>:
	memset((void*)state.eax, 0, pages * 0x1000);

	return (void*)state.eax;
}

void pfree(void* page) {
20000df1:	55                   	push   %ebp
20000df2:	89 e5                	mov    %esp,%ebp
20000df4:	83 ec 34             	sub    $0x34,%esp
			.eax = 0x401,
			.ebx = (uint32_t)page,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000df7:	8b 45 08             	mov    0x8(%ebp),%eax
20000dfa:	c7 45 e0 01 04 00 00 	movl   $0x401,-0x20(%ebp)
20000e01:	89 45 e4             	mov    %eax,-0x1c(%ebp)

	syscall(&state);
20000e04:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000e07:	50                   	push   %eax
			.eax = 0x401,
			.ebx = (uint32_t)page,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000e08:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000e0f:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000e16:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000e1d:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000e24:	e8 d7 f8 ff ff       	call   20000700 <syscall>
20000e29:	83 c4 10             	add    $0x10,%esp
}
20000e2c:	c9                   	leave  
20000e2d:	c3                   	ret    

20000e2e <pcalloc>:

void* palloc() {
	return pcalloc(1);
}

void* pcalloc(uint32_t pages) {
20000e2e:	55                   	push   %ebp
20000e2f:	89 e5                	mov    %esp,%ebp
20000e31:	53                   	push   %ebx
20000e32:	83 ec 30             	sub    $0x30,%esp
20000e35:	8b 5d 08             	mov    0x8(%ebp),%ebx
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };

	syscall(&state);
20000e38:	8d 45 e0             	lea    -0x20(%ebp),%eax
20000e3b:	50                   	push   %eax
			.eax = 0x400,
			.ebx = pages,
			.ecx = 0,
			.edx = 0,
			.esi = 0,
			.edi = 0 };
20000e3c:	c7 45 e0 00 04 00 00 	movl   $0x400,-0x20(%ebp)
20000e43:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
20000e46:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
20000e4d:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
20000e54:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
20000e5b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	syscall(&state);
20000e62:	e8 99 f8 ff ff       	call   20000700 <syscall>

	memset((void*)state.eax, 0, pages * 0x1000);
20000e67:	89 da                	mov    %ebx,%edx

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;
20000e69:	8b 45 e0             	mov    -0x20(%ebp),%eax
			.esi = 0,
			.edi = 0 };

	syscall(&state);

	memset((void*)state.eax, 0, pages * 0x1000);
20000e6c:	c1 e2 0c             	shl    $0xc,%edx

	syscall(&state);
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;
20000e6f:	83 c4 10             	add    $0x10,%esp
20000e72:	eb 05                	jmp    20000e79 <pcalloc+0x4b>

	while (n--) {
		*p++ = c;
20000e74:	c6 00 00             	movb   $0x0,(%eax)
20000e77:	4a                   	dec    %edx
20000e78:	40                   	inc    %eax
}

void* memset(void* buf, int c, uint32_t n) {
	unsigned char* p = buf;

	while (n--) {
20000e79:	85 d2                	test   %edx,%edx
20000e7b:	75 f7                	jne    20000e74 <pcalloc+0x46>
	syscall(&state);

	memset((void*)state.eax, 0, pages * 0x1000);

	return (void*)state.eax;
}
20000e7d:	8b 45 e0             	mov    -0x20(%ebp),%eax
20000e80:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000e83:	c9                   	leave  
20000e84:	c3                   	ret    

20000e85 <palloc>:
#include "memory.h"
#include "syscall.h"

void* palloc() {
20000e85:	55                   	push   %ebp
20000e86:	89 e5                	mov    %esp,%ebp
20000e88:	83 ec 14             	sub    $0x14,%esp
	return pcalloc(1);
20000e8b:	6a 01                	push   $0x1
20000e8d:	e8 9c ff ff ff       	call   20000e2e <pcalloc>
}
20000e92:	c9                   	leave  
20000e93:	c3                   	ret    

20000e94 <free>:
		cur = cur->next;
	}
	return NULL;
}

void free(void* ptr) {
20000e94:	55                   	push   %ebp
20000e95:	89 e5                	mov    %esp,%ebp
20000e97:	57                   	push   %edi
20000e98:	56                   	push   %esi
20000e99:	53                   	push   %ebx
20000e9a:	83 ec 2c             	sub    $0x2c,%esp
20000e9d:	8b 45 08             	mov    0x8(%ebp),%eax
	struct memory_node* cur = first_used;
20000ea0:	8b 1d 08 50 04 20    	mov    0x20045008,%ebx

	while (cur != NULL) {
20000ea6:	e9 d3 00 00 00       	jmp    20000f7e <free+0xea>
		if (cur->address == (uint32_t) ptr) {
20000eab:	3b 43 04             	cmp    0x4(%ebx),%eax
20000eae:	0f 85 c7 00 00 00    	jne    20000f7b <free+0xe7>
			memset(ptr, 0, cur->size);
20000eb4:	52                   	push   %edx
20000eb5:	ff 33                	pushl  (%ebx)
20000eb7:	6a 00                	push   $0x0
20000eb9:	50                   	push   %eax
20000eba:	e8 a9 fe ff ff       	call   20000d68 <memset>
			malloced -= cur->size;
20000ebf:	8b 03                	mov    (%ebx),%eax
20000ec1:	29 05 10 50 04 20    	sub    %eax,0x20045010
struct memory_node* first_used = 0;
struct memory_node* first_free = 0;

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;
20000ec7:	31 d2                	xor    %edx,%edx
20000ec9:	a1 08 50 04 20       	mov    0x20045008,%eax
20000ece:	83 c4 10             	add    $0x10,%esp
20000ed1:	eb 22                	jmp    20000ef5 <free+0x61>

	while (cur != NULL) {
		if (cur == element) {
20000ed3:	39 d8                	cmp    %ebx,%eax
20000ed5:	75 19                	jne    20000ef0 <free+0x5c>
			if (last == NULL) {
20000ed7:	85 d2                	test   %edx,%edx
20000ed9:	8b 43 08             	mov    0x8(%ebx),%eax
20000edc:	75 0d                	jne    20000eeb <free+0x57>
				*root = cur->next;
20000ede:	a3 08 50 04 20       	mov    %eax,0x20045008
20000ee3:	8b 15 0c 50 04 20    	mov    0x2004500c,%edx
20000ee9:	eb 10                	jmp    20000efb <free+0x67>
				return;
			} else {
				last->next = cur->next;
20000eeb:	89 42 08             	mov    %eax,0x8(%edx)
20000eee:	eb f3                	jmp    20000ee3 <free+0x4f>
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000ef0:	89 c2                	mov    %eax,%edx
20000ef2:	8b 40 08             	mov    0x8(%eax),%eax

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000ef5:	85 c0                	test   %eax,%eax
20000ef7:	75 da                	jne    20000ed3 <free+0x3f>
20000ef9:	eb e8                	jmp    20000ee3 <free+0x4f>
20000efb:	89 d0                	mov    %edx,%eax
20000efd:	eb 6d                	jmp    20000f6c <free+0xd8>
	struct memory_node* cur;

	editedList: cur = first_free;

	while (cur != NULL) {
		if (cur->address + cur->size == tf->address) {
20000eff:	8b 48 04             	mov    0x4(%eax),%ecx
20000f02:	8b 30                	mov    (%eax),%esi
20000f04:	8b 7b 04             	mov    0x4(%ebx),%edi
20000f07:	89 7d d4             	mov    %edi,-0x2c(%ebp)
20000f0a:	8d 3c 0e             	lea    (%esi,%ecx,1),%edi
20000f0d:	89 7d e4             	mov    %edi,-0x1c(%ebp)
20000f10:	8b 7d d4             	mov    -0x2c(%ebp),%edi
20000f13:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
20000f16:	75 18                	jne    20000f30 <free+0x9c>
			tf->address = cur->address;
20000f18:	89 4b 04             	mov    %ecx,0x4(%ebx)
20000f1b:	31 f6                	xor    %esi,%esi
20000f1d:	89 d1                	mov    %edx,%ecx
20000f1f:	eb 09                	jmp    20000f2a <free+0x96>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000f21:	39 c1                	cmp    %eax,%ecx
20000f23:	74 29                	je     20000f4e <free+0xba>
				last->next = cur->next;
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000f25:	89 ce                	mov    %ecx,%esi
20000f27:	8b 49 08             	mov    0x8(%ecx),%ecx

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000f2a:	85 c9                	test   %ecx,%ecx
20000f2c:	75 f3                	jne    20000f21 <free+0x8d>
20000f2e:	eb cb                	jmp    20000efb <free+0x67>
			tf->address = cur->address;
			remove_from_list(&first_free, cur);
			goto editedList;
		}

		if (cur->address == tf->address + tf->size) {
20000f30:	8b 3b                	mov    (%ebx),%edi
20000f32:	89 7d e4             	mov    %edi,-0x1c(%ebp)
20000f35:	8b 7d d4             	mov    -0x2c(%ebp),%edi
20000f38:	03 7d e4             	add    -0x1c(%ebp),%edi
20000f3b:	39 f9                	cmp    %edi,%ecx
20000f3d:	75 2a                	jne    20000f69 <free+0xd5>
			tf->size += cur->size;
20000f3f:	03 75 e4             	add    -0x1c(%ebp),%esi
20000f42:	89 d1                	mov    %edx,%ecx
20000f44:	89 33                	mov    %esi,(%ebx)
20000f46:	31 f6                	xor    %esi,%esi
20000f48:	eb 19                	jmp    20000f63 <free+0xcf>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20000f4a:	39 c1                	cmp    %eax,%ecx
20000f4c:	75 10                	jne    20000f5e <free+0xca>
			if (last == NULL) {
20000f4e:	85 f6                	test   %esi,%esi
20000f50:	8b 41 08             	mov    0x8(%ecx),%eax
20000f53:	75 04                	jne    20000f59 <free+0xc5>
				*root = cur->next;
20000f55:	89 c2                	mov    %eax,%edx
20000f57:	eb a2                	jmp    20000efb <free+0x67>
				return;
			} else {
				last->next = cur->next;
20000f59:	89 46 08             	mov    %eax,0x8(%esi)
20000f5c:	eb 9d                	jmp    20000efb <free+0x67>
				return;
			}
		}
		last = cur;
		cur = cur->next;
20000f5e:	89 ce                	mov    %ecx,%esi
20000f60:	8b 49 08             	mov    0x8(%ecx),%ecx

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20000f63:	85 c9                	test   %ecx,%ecx
20000f65:	75 e3                	jne    20000f4a <free+0xb6>
20000f67:	eb 92                	jmp    20000efb <free+0x67>
			tf->size += cur->size;
			remove_from_list(&first_free, cur);
			goto editedList;
		}

		cur = cur->next;
20000f69:	8b 40 08             	mov    0x8(%eax),%eax

	struct memory_node* cur;

	editedList: cur = first_free;

	while (cur != NULL) {
20000f6c:	85 c0                	test   %eax,%eax
20000f6e:	75 8f                	jne    20000eff <free+0x6b>
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000f70:	89 53 08             	mov    %edx,0x8(%ebx)
	*root = element;
20000f73:	89 1d 0c 50 04 20    	mov    %ebx,0x2004500c
		if (cur->address == (uint32_t) ptr) {
			memset(ptr, 0, cur->size);
			malloced -= cur->size;

			merge_into_frees(cur);
			break;
20000f79:	eb 0b                	jmp    20000f86 <free+0xf2>
		}
		cur = cur->next;
20000f7b:	8b 5b 08             	mov    0x8(%ebx),%ebx
}

void free(void* ptr) {
	struct memory_node* cur = first_used;

	while (cur != NULL) {
20000f7e:	85 db                	test   %ebx,%ebx
20000f80:	0f 85 25 ff ff ff    	jne    20000eab <free+0x17>
			merge_into_frees(cur);
			break;
		}
		cur = cur->next;
	}
}
20000f86:	8d 65 f4             	lea    -0xc(%ebp),%esp
20000f89:	5b                   	pop    %ebx
20000f8a:	5e                   	pop    %esi
20000f8b:	5f                   	pop    %edi
20000f8c:	5d                   	pop    %ebp
20000f8d:	c3                   	ret    

20000f8e <pop_unused_node>:
	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
		append_to_list(&first_unused, &(new_nodes[i]));
	}
}

static struct memory_node* pop_unused_node() {
20000f8e:	55                   	push   %ebp
20000f8f:	89 e5                	mov    %esp,%ebp
20000f91:	53                   	push   %ebx
20000f92:	83 ec 04             	sub    $0x4,%esp
	element->next = *root;
	*root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
	if (*root == NULL) return NULL;
20000f95:	a1 04 50 04 20       	mov    0x20045004,%eax
20000f9a:	eb 45                	jmp    20000fe1 <pop_unused_node+0x53>
	remove_from_list(root, pop);
	return pop;
}

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
20000f9c:	83 ec 0c             	sub    $0xc,%esp
20000f9f:	6a 01                	push   $0x1
20000fa1:	e8 88 fe ff ff       	call   20000e2e <pcalloc>
	memset(new_nodes, 0, PAGESIZE);
20000fa6:	83 c4 0c             	add    $0xc,%esp
	remove_from_list(root, pop);
	return pop;
}

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
20000fa9:	89 c3                	mov    %eax,%ebx
	memset(new_nodes, 0, PAGESIZE);
20000fab:	68 00 10 00 00       	push   $0x1000
20000fb0:	6a 00                	push   $0x0
20000fb2:	50                   	push   %eax
20000fb3:	e8 b0 fd ff ff       	call   20000d68 <memset>
20000fb8:	8b 15 04 50 04 20    	mov    0x20045004,%edx
20000fbe:	8d 43 0c             	lea    0xc(%ebx),%eax
	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
		append_to_list(&first_unused, &(new_nodes[i]));
	}
}

static struct memory_node* pop_unused_node() {
20000fc1:	8d 8b fc 0f 00 00    	lea    0xffc(%ebx),%ecx
20000fc7:	83 c4 10             	add    $0x10,%esp
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20000fca:	89 50 08             	mov    %edx,0x8(%eax)
20000fcd:	89 c2                	mov    %eax,%edx
20000fcf:	83 c0 0c             	add    $0xc,%eax

static void allocate_unused_nodes() {
	struct memory_node* new_nodes = pcalloc(1);
	memset(new_nodes, 0, PAGESIZE);

	for (uint32_t i = 1; i < (PAGESIZE / sizeof(struct memory_node)); i++) {
20000fd2:	39 c8                	cmp    %ecx,%eax
20000fd4:	75 f4                	jne    20000fca <pop_unused_node+0x3c>
20000fd6:	8d 83 f0 0f 00 00    	lea    0xff0(%ebx),%eax
20000fdc:	a3 04 50 04 20       	mov    %eax,0x20045004
	element->next = *root;
	*root = element;
}

static struct memory_node* pop_from_list(struct memory_node** root) {
	if (*root == NULL) return NULL;
20000fe1:	85 c0                	test   %eax,%eax
20000fe3:	74 b7                	je     20000f9c <pop_unused_node+0xe>
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
			if (last == NULL) {
				*root = cur->next;
20000fe5:	8b 50 08             	mov    0x8(%eax),%edx
}

static struct memory_node* pop_unused_node() {
	struct memory_node* ret = pop_from_list(&first_unused);

	while (ret == NULL) {
20000fe8:	85 c0                	test   %eax,%eax
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
			if (last == NULL) {
				*root = cur->next;
20000fea:	89 15 04 50 04 20    	mov    %edx,0x20045004
}

static struct memory_node* pop_unused_node() {
	struct memory_node* ret = pop_from_list(&first_unused);

	while (ret == NULL) {
20000ff0:	74 aa                	je     20000f9c <pop_unused_node+0xe>
		allocate_unused_nodes();
		ret = pop_from_list(&first_unused);
	}

	return ret;
}
20000ff2:	8b 5d fc             	mov    -0x4(%ebp),%ebx
20000ff5:	c9                   	leave  
20000ff6:	c3                   	ret    

20000ff7 <malloc>:
	append_to_list(&first_free, tf);
}

uint32_t malloced = 0;

void* malloc(size_t size) {
20000ff7:	55                   	push   %ebp
	if (size == 0)
20000ff8:	31 c0                	xor    %eax,%eax
	append_to_list(&first_free, tf);
}

uint32_t malloced = 0;

void* malloc(size_t size) {
20000ffa:	89 e5                	mov    %esp,%ebp
20000ffc:	57                   	push   %edi
20000ffd:	56                   	push   %esi
20000ffe:	53                   	push   %ebx
20000fff:	83 ec 1c             	sub    $0x1c,%esp
20001002:	8b 75 08             	mov    0x8(%ebp),%esi
	if (size == 0)
20001005:	85 f6                	test   %esi,%esi
20001007:	0f 84 aa 00 00 00    	je     200010b7 <malloc+0xc0>
		return NULL;

	malloced += size;

	struct memory_node* cur = first_free;
2000100d:	a1 0c 50 04 20       	mov    0x2004500c,%eax

void* malloc(size_t size) {
	if (size == 0)
		return NULL;

	malloced += size;
20001012:	01 35 10 50 04 20    	add    %esi,0x20045010

	struct memory_node* cur = first_free;
20001018:	89 c3                	mov    %eax,%ebx

	while (cur != NULL) {
2000101a:	eb 07                	jmp    20001023 <malloc+0x2c>
		if (cur->size >= size) {
2000101c:	39 33                	cmp    %esi,(%ebx)
2000101e:	73 0c                	jae    2000102c <malloc+0x35>
			break;
		}
		cur = cur->next;
20001020:	8b 5b 08             	mov    0x8(%ebx),%ebx

	malloced += size;

	struct memory_node* cur = first_free;

	while (cur != NULL) {
20001023:	85 db                	test   %ebx,%ebx
20001025:	75 f5                	jne    2000101c <malloc+0x25>
20001027:	e9 93 00 00 00       	jmp    200010bf <malloc+0xc8>

		append_to_list(&first_used, fill);

		return (void*) fill->address;
	} else {
		uint32_t freesize = cur->size - size;
2000102c:	8b 3b                	mov    (%ebx),%edi

		cur->size = size;
2000102e:	31 d2                	xor    %edx,%edx

		append_to_list(&first_used, fill);

		return (void*) fill->address;
	} else {
		uint32_t freesize = cur->size - size;
20001030:	29 f7                	sub    %esi,%edi

		cur->size = size;
20001032:	89 33                	mov    %esi,(%ebx)
20001034:	eb 4b                	jmp    20001081 <malloc+0x8a>

		fill->address = (uint32_t) addr;
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();
20001036:	e8 53 ff ff ff       	call   20000f8e <pop_unused_node>

			free->address = fill->address + fill->size;
2000103b:	8b 13                	mov    (%ebx),%edx
2000103d:	03 53 04             	add    0x4(%ebx),%edx
			free->size = pgs * PAGESIZE - size;
20001040:	29 f7                	sub    %esi,%edi
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();

			free->address = fill->address + fill->size;
20001042:	89 50 04             	mov    %edx,0x4(%eax)
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20001045:	8b 15 0c 50 04 20    	mov    0x2004500c,%edx
2000104b:	89 50 08             	mov    %edx,0x8(%eax)

		if (pgs * PAGESIZE > size) {
			struct memory_node* free = pop_unused_node();

			free->address = fill->address + fill->size;
			free->size = pgs * PAGESIZE - size;
2000104e:	89 38                	mov    %edi,(%eax)
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
	*root = element;
20001050:	a3 0c 50 04 20       	mov    %eax,0x2004500c
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20001055:	a1 08 50 04 20       	mov    0x20045008,%eax
2000105a:	89 43 08             	mov    %eax,0x8(%ebx)
	*root = element;
2000105d:	89 1d 08 50 04 20    	mov    %ebx,0x20045008
20001063:	eb 4f                	jmp    200010b4 <malloc+0xbd>
static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
		if (cur == element) {
20001065:	39 d8                	cmp    %ebx,%eax
20001067:	75 13                	jne    2000107c <malloc+0x85>
			if (last == NULL) {
20001069:	85 d2                	test   %edx,%edx
2000106b:	8b 43 08             	mov    0x8(%ebx),%eax
2000106e:	75 07                	jne    20001077 <malloc+0x80>
				*root = cur->next;
20001070:	a3 0c 50 04 20       	mov    %eax,0x2004500c
20001075:	eb 0e                	jmp    20001085 <malloc+0x8e>
				return;
			} else {
				last->next = cur->next;
20001077:	89 42 08             	mov    %eax,0x8(%edx)
2000107a:	eb 09                	jmp    20001085 <malloc+0x8e>
				return;
			}
		}
		last = cur;
		cur = cur->next;
2000107c:	89 c2                	mov    %eax,%edx
2000107e:	8b 40 08             	mov    0x8(%eax),%eax

static void remove_from_list(struct memory_node** root, struct memory_node* element) {
	struct memory_node* last = 0;
	struct memory_node* cur = *root;

	while (cur != NULL) {
20001081:	85 c0                	test   %eax,%eax
20001083:	75 e0                	jne    20001065 <malloc+0x6e>
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
20001085:	a1 08 50 04 20       	mov    0x20045008,%eax
		cur->size = size;

		remove_from_list(&first_free, cur);
		append_to_list(&first_used, cur);

		if (freesize > 0) {
2000108a:	85 ff                	test   %edi,%edi
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
2000108c:	89 43 08             	mov    %eax,0x8(%ebx)
	*root = element;
2000108f:	89 1d 08 50 04 20    	mov    %ebx,0x20045008
		cur->size = size;

		remove_from_list(&first_free, cur);
		append_to_list(&first_used, cur);

		if (freesize > 0) {
20001095:	74 1d                	je     200010b4 <malloc+0xbd>
			struct memory_node* free = pop_unused_node();
20001097:	e8 f2 fe ff ff       	call   20000f8e <pop_unused_node>

			free->address = cur->address + cur->size;
2000109c:	8b 13                	mov    (%ebx),%edx
2000109e:	03 53 04             	add    0x4(%ebx),%edx
200010a1:	89 50 04             	mov    %edx,0x4(%eax)
		cur = cur->next;
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
200010a4:	8b 15 0c 50 04 20    	mov    0x2004500c,%edx
200010aa:	89 50 08             	mov    %edx,0x8(%eax)

		if (freesize > 0) {
			struct memory_node* free = pop_unused_node();

			free->address = cur->address + cur->size;
			free->size = freesize;
200010ad:	89 38                	mov    %edi,(%eax)
	}
}

static void append_to_list(struct memory_node** root, struct memory_node* element) {
	element->next = *root;
	*root = element;
200010af:	a3 0c 50 04 20       	mov    %eax,0x2004500c
			free->size = freesize;

			append_to_list(&first_free, free);
		}

		return (void*) cur->address;
200010b4:	8b 43 04             	mov    0x4(%ebx),%eax
	}
}
200010b7:	8d 65 f4             	lea    -0xc(%ebp),%esp
200010ba:	5b                   	pop    %ebx
200010bb:	5e                   	pop    %esi
200010bc:	5f                   	pop    %edi
200010bd:	5d                   	pop    %ebp
200010be:	c3                   	ret    
	}

	if (cur == NULL) {
		uint32_t pgs = size / PAGESIZE;

		if ((size % PAGESIZE) != 0)
200010bf:	89 f0                	mov    %esi,%eax
		}
		cur = cur->next;
	}

	if (cur == NULL) {
		uint32_t pgs = size / PAGESIZE;
200010c1:	89 f7                	mov    %esi,%edi
200010c3:	c1 ef 0c             	shr    $0xc,%edi

		if ((size % PAGESIZE) != 0)
200010c6:	25 ff 0f 00 00       	and    $0xfff,%eax
			pgs++;
200010cb:	83 f8 01             	cmp    $0x1,%eax
200010ce:	83 df ff             	sbb    $0xffffffff,%edi

		void* addr = pcalloc(pgs);
200010d1:	83 ec 0c             	sub    $0xc,%esp
200010d4:	57                   	push   %edi
200010d5:	e8 54 fd ff ff       	call   20000e2e <pcalloc>
		struct memory_node* fill = pop_unused_node();

		fill->address = (uint32_t) addr;
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
200010da:	c1 e7 0c             	shl    $0xc,%edi
		if ((size % PAGESIZE) != 0)
			pgs++;

		void* addr = pcalloc(pgs);

		struct memory_node* fill = pop_unused_node();
200010dd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
200010e0:	e8 a9 fe ff ff       	call   20000f8e <pop_unused_node>

		fill->address = (uint32_t) addr;
200010e5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
		fill->size = (uint32_t) size;

		if (pgs * PAGESIZE > size) {
200010e8:	83 c4 10             	add    $0x10,%esp
		if ((size % PAGESIZE) != 0)
			pgs++;

		void* addr = pcalloc(pgs);

		struct memory_node* fill = pop_unused_node();
200010eb:	89 c3                	mov    %eax,%ebx

		fill->address = (uint32_t) addr;
200010ed:	89 50 04             	mov    %edx,0x4(%eax)
		fill->size = (uint32_t) size;
200010f0:	89 30                	mov    %esi,(%eax)

		if (pgs * PAGESIZE > size) {
200010f2:	39 f7                	cmp    %esi,%edi
200010f4:	0f 86 5b ff ff ff    	jbe    20001055 <malloc+0x5e>
200010fa:	e9 37 ff ff ff       	jmp    20001036 <malloc+0x3f>

200010ff <realloc>:
	}

	return p;
}

void* realloc(void* ptr, size_t size) {
200010ff:	55                   	push   %ebp
20001100:	89 e5                	mov    %esp,%ebp
20001102:	56                   	push   %esi
20001103:	53                   	push   %ebx
	struct memory_node* cur = first_used;
20001104:	8b 1d 08 50 04 20    	mov    0x20045008,%ebx
	}

	return p;
}

void* realloc(void* ptr, size_t size) {
2000110a:	8b 55 08             	mov    0x8(%ebp),%edx
2000110d:	8b 45 0c             	mov    0xc(%ebp),%eax
	struct memory_node* cur = first_used;

	while (cur != NULL) {
20001110:	eb 40                	jmp    20001152 <realloc+0x53>
		if (cur->address == (uint32_t) ptr) {
20001112:	3b 53 04             	cmp    0x4(%ebx),%edx
20001115:	75 38                	jne    2000114f <realloc+0x50>
			if (size == 0) {
20001117:	85 c0                	test   %eax,%eax
20001119:	75 0d                	jne    20001128 <realloc+0x29>
				free(ptr);
2000111b:	83 ec 0c             	sub    $0xc,%esp
2000111e:	31 f6                	xor    %esi,%esi
20001120:	52                   	push   %edx
20001121:	e8 6e fd ff ff       	call   20000e94 <free>
20001126:	eb 22                	jmp    2000114a <realloc+0x4b>
				return NULL;
			} else {
				void* new = malloc(size);
20001128:	83 ec 0c             	sub    $0xc,%esp
2000112b:	50                   	push   %eax
2000112c:	e8 c6 fe ff ff       	call   20000ff7 <malloc>
				memcpy(new, (void*) cur->address, cur->size);
20001131:	83 c4 0c             	add    $0xc,%esp
		if (cur->address == (uint32_t) ptr) {
			if (size == 0) {
				free(ptr);
				return NULL;
			} else {
				void* new = malloc(size);
20001134:	89 c6                	mov    %eax,%esi
				memcpy(new, (void*) cur->address, cur->size);
20001136:	ff 33                	pushl  (%ebx)
20001138:	ff 73 04             	pushl  0x4(%ebx)
2000113b:	50                   	push   %eax
2000113c:	e8 43 fc ff ff       	call   20000d84 <memcpy>
				free((void*) cur->address);
20001141:	59                   	pop    %ecx
20001142:	ff 73 04             	pushl  0x4(%ebx)
20001145:	e8 4a fd ff ff       	call   20000e94 <free>

				return new;
2000114a:	83 c4 10             	add    $0x10,%esp
2000114d:	eb 09                	jmp    20001158 <realloc+0x59>
			}
		}
		cur = cur->next;
2000114f:	8b 5b 08             	mov    0x8(%ebx),%ebx
}

void* realloc(void* ptr, size_t size) {
	struct memory_node* cur = first_used;

	while (cur != NULL) {
20001152:	85 db                	test   %ebx,%ebx
20001154:	75 bc                	jne    20001112 <realloc+0x13>
20001156:	31 f6                	xor    %esi,%esi
			}
		}
		cur = cur->next;
	}
	return NULL;
}
20001158:	8d 65 f8             	lea    -0x8(%ebp),%esp
2000115b:	89 f0                	mov    %esi,%eax
2000115d:	5b                   	pop    %ebx
2000115e:	5e                   	pop    %esi
2000115f:	5d                   	pop    %ebp
20001160:	c3                   	ret    

20001161 <calloc>:

		return (void*) cur->address;
	}
}

void* calloc(size_t num, size_t size) {
20001161:	55                   	push   %ebp
20001162:	89 e5                	mov    %esp,%ebp
20001164:	56                   	push   %esi
20001165:	53                   	push   %ebx
20001166:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	size_t gsize = num * size;
	void* p = malloc(gsize);
20001169:	83 ec 0c             	sub    $0xc,%esp
		return (void*) cur->address;
	}
}

void* calloc(size_t num, size_t size) {
	size_t gsize = num * size;
2000116c:	0f af 5d 08          	imul   0x8(%ebp),%ebx
	void* p = malloc(gsize);
20001170:	53                   	push   %ebx
20001171:	e8 81 fe ff ff       	call   20000ff7 <malloc>

	if (p != NULL) {
20001176:	83 c4 10             	add    $0x10,%esp
	}
}

void* calloc(size_t num, size_t size) {
	size_t gsize = num * size;
	void* p = malloc(gsize);
20001179:	89 c6                	mov    %eax,%esi

	if (p != NULL) {
2000117b:	85 c0                	test   %eax,%eax
2000117d:	74 0d                	je     2000118c <calloc+0x2b>
		memset(p, 0, gsize);
2000117f:	50                   	push   %eax
20001180:	53                   	push   %ebx
20001181:	6a 00                	push   $0x0
20001183:	56                   	push   %esi
20001184:	e8 df fb ff ff       	call   20000d68 <memset>
20001189:	83 c4 10             	add    $0x10,%esp
	}

	return p;
}
2000118c:	8d 65 f8             	lea    -0x8(%ebp),%esp
2000118f:	89 f0                	mov    %esi,%eax
20001191:	5b                   	pop    %ebx
20001192:	5e                   	pop    %esi
20001193:	5d                   	pop    %ebp
20001194:	c3                   	ret    
